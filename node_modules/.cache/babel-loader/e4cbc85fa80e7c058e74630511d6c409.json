{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getterParameters = exports.definitionToAbi = exports.isContractPayable = exports.mutability = exports.functionClass = exports.functionKind = exports.parameters = exports.valueDefinition = exports.keyDefinition = exports.baseDefinition = exports.rationalValue = exports.regularizeTypeIdentifier = exports.spliceLocation = exports.isSimpleConstant = exports.stackSize = exports.contractKind = exports.referenceType = exports.isReference = exports.isEnum = exports.isMapping = exports.isStruct = exports.staticLengthAsString = exports.staticLength = exports.isDynamicArray = exports.isArray = exports.decimalPlaces = exports.specifiedSize = exports.visibility = exports.typeId = exports.typeClassLongForm = exports.typeClass = exports.typeStringWithoutLocation = exports.typeString = exports.typeIdentifier = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:ast:utils\");\n\nconst Common = __importStar(require(\"../common\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst cloneDeep_1 = __importDefault(require(\"lodash/cloneDeep\"));\n/** @category Definition Reading */\n\n\nfunction typeIdentifier(definition) {\n  return definition.typeDescriptions.typeIdentifier;\n}\n\nexports.typeIdentifier = typeIdentifier;\n/** @category Definition Reading */\n\nfunction typeString(definition) {\n  return definition.typeDescriptions.typeString;\n}\n\nexports.typeString = typeString;\n/**\n * Returns the type string, but with location (if any) stripped off the end\n * @category Definition Reading\n */\n\nfunction typeStringWithoutLocation(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    //for handling Yul variables\n    return \"bytes32\";\n  }\n\n  return typeString(definition).replace(/ (storage|memory|calldata)( slice)?$/, \"\");\n}\n\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n/**\n * returns basic type class for a variable definition node\n * e.g.:\n *  `t_uint256` becomes `uint`\n *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`\n * @category Definition Reading\n */\n\nfunction typeClass(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    //for handling Yul variables\n    return \"bytes\";\n  }\n\n  return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];\n}\n\nexports.typeClass = typeClass;\n/**\n * similar to typeClass, but includes any numeric qualifiers\n * e.g.:\n * `t_uint256` becomes `uint256`\n * @category Definition Reading\n */\n\nfunction typeClassLongForm(definition) {\n  return typeIdentifier(definition).match(/t_([^$_]+)/)[1];\n}\n\nexports.typeClassLongForm = typeClassLongForm;\n/**\n * for user-defined types -- structs, enums, contracts\n * often you can get these from referencedDeclaration, but not\n * always\n * @category Definition Reading\n */\n\nfunction typeId(definition) {\n  debug(\"definition %O\", definition);\n  return parseInt(typeIdentifier(definition).match(/\\$(\\d+)(_(storage|memory|calldata)(_ptr(_slice)?)?)?$/)[1]);\n}\n\nexports.typeId = typeId;\n/**\n * For function types; returns internal or external\n * (not for use on other types! will cause an error!)\n * should only return \"internal\" or \"external\"\n * @category Definition Reading\n */\n\nfunction visibility(definition) {\n  return definition.typeName ? definition.typeName.visibility : definition.visibility;\n}\n\nexports.visibility = visibility;\n/**\n * e.g. uint48 -> 6\n * @return size in bytes for explicit type size, or `null` if not stated\n * @category Definition Reading\n */\n\nfunction specifiedSize(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    return 32; //for handling Yul variables\n  }\n\n  let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);\n\n  if (!specified) {\n    return null;\n  }\n\n  let num = parseInt(specified[1]);\n\n  switch (typeClass(definition)) {\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n      return num / 8;\n\n    case \"bytes\":\n      return num;\n\n    default:\n      debug(\"Unknown type for size specification: %s\", typeIdentifier(definition));\n  }\n}\n\nexports.specifiedSize = specifiedSize;\n/**\n * for fixed-point types, obviously\n * @category Definition Reading\n */\n\nfunction decimalPlaces(definition) {\n  return parseInt(typeIdentifier(definition).match(/t_[a-z]+[0-9]+x([0-9]+)/)[1]);\n}\n\nexports.decimalPlaces = decimalPlaces;\n/** @category Definition Reading */\n\nfunction isArray(definition) {\n  return typeIdentifier(definition).match(/^t_array/) != null;\n}\n\nexports.isArray = isArray;\n/** @category Definition Reading */\n\nfunction isDynamicArray(definition) {\n  return isArray(definition) && //NOTE: we do this by parsing the type identifier, rather than by just\n  //checking the length field, because we might be using this on a faked-up\n  //definition\n  typeIdentifier(definition).match(/\\$dyn_(storage|memory|calldata)(_ptr(_slice)?)?$/) != null;\n}\n\nexports.isDynamicArray = isDynamicArray;\n/**\n * length of a statically sized array -- please only use for arrays\n * already verified to be static!\n * @category Definition Reading\n */\n\nfunction staticLength(definition) {\n  //NOTE: we do this by parsing the type identifier, rather than by just\n  //checking the length field, because we might be using this on a faked-up\n  //definition\n  return parseInt(staticLengthAsString(definition));\n}\n\nexports.staticLength = staticLength;\n/**\n * see staticLength for explanation\n * @category Definition Reading\n */\n\nfunction staticLengthAsString(definition) {\n  return typeIdentifier(definition).match(/\\$(\\d+)_(storage|memory|calldata)(_ptr(_slice)?)?$/)[1];\n}\n\nexports.staticLengthAsString = staticLengthAsString;\n/** @category Definition Reading */\n\nfunction isStruct(definition) {\n  return typeIdentifier(definition).match(/^t_struct/) != null;\n}\n\nexports.isStruct = isStruct;\n/** @category Definition Reading */\n\nfunction isMapping(definition) {\n  return typeIdentifier(definition).match(/^t_mapping/) != null;\n}\n\nexports.isMapping = isMapping;\n/** @category Definition Reading */\n\nfunction isEnum(definition) {\n  return typeIdentifier(definition).match(/^t_enum/) != null;\n}\n\nexports.isEnum = isEnum;\n/** @category Definition Reading */\n\nfunction isReference(definition) {\n  return typeIdentifier(definition).match(/_(memory|storage|calldata)(_ptr(_slice)?)?$/) != null;\n}\n\nexports.isReference = isReference;\n/**\n * note: only use this on things already verified to be references\n * @category Definition Reading\n */\n\nfunction referenceType(definition) {\n  return typeIdentifier(definition).match(/_([^_]+)(_ptr(_slice)?)?$/)[1];\n}\n\nexports.referenceType = referenceType;\n/**\n * only for contract types, obviously! will yield nonsense otherwise!\n * @category Definition Reading\n */\n\nfunction contractKind(definition) {\n  return typeString(definition).split(\" \")[0];\n}\n\nexports.contractKind = contractKind;\n/**\n * stack size, in words, of a given type\n * note: this function assumes that UDVTs only ever take up\n * a single word, which is currently true\n * @category Definition Reading\n */\n\nfunction stackSize(definition) {\n  if (typeClass(definition) === \"function\" && visibility(definition) === \"external\") {\n    return 2;\n  }\n\n  if (isReference(definition) && referenceType(definition) === \"calldata\") {\n    if (typeClass(definition) === \"string\" || typeClass(definition) === \"bytes\") {\n      return 2;\n    }\n\n    if (isDynamicArray(definition)) {\n      return 2;\n    }\n  }\n\n  return 1;\n}\n\nexports.stackSize = stackSize;\n/** @category Definition Reading */\n\nfunction isSimpleConstant(definition) {\n  const types = [\"stringliteral\", \"rational\"];\n  return types.includes(typeClass(definition));\n}\n\nexports.isSimpleConstant = isSimpleConstant;\n/**\n * definition: a storage reference definition\n * location: the location you want it to refer to instead\n * @category Definition Reading\n */\n\nfunction spliceLocation(definition, location) {\n  debug(\"definition %O\", definition);\n  return Object.assign(Object.assign({}, definition), {\n    typeDescriptions: Object.assign(Object.assign({}, definition.typeDescriptions), {\n      typeIdentifier: definition.typeDescriptions.typeIdentifier.replace(/_(storage|memory|calldata)(?=((_slice)?_ptr)?$)/, \"_\" + location)\n    })\n  });\n}\n\nexports.spliceLocation = spliceLocation;\n/**\n * adds \"_ptr\" on to the end of type identifiers that might need it; note that\n * this operates on identifiers, not definitions\n * @category Definition Reading\n */\n\nfunction regularizeTypeIdentifier(identifier) {\n  return identifier.replace(/(_(storage|memory|calldata))((_slice)?_ptr)?$/, \"$1_ptr\" //this used to use lookbehind for clarity, but Firefox...\n  //(see: https://github.com/trufflesuite/truffle/issues/3068 )\n  );\n}\n\nexports.regularizeTypeIdentifier = regularizeTypeIdentifier;\n/**\n * extract the actual numerical value from a node of type rational.\n * currently assumes result will be integer (currently returns BN)\n * @category Definition Reading\n */\n\nfunction rationalValue(definition) {\n  let identifier = typeIdentifier(definition);\n  let absoluteValue = identifier.match(/_(\\d+)_by_1$/)[1];\n  let isNegative = identifier.match(/_minus_/) != null;\n  return isNegative ? new bn_js_1.default(absoluteValue).neg() : new bn_js_1.default(absoluteValue);\n}\n\nexports.rationalValue = rationalValue;\n/** @category Definition Reading */\n\nfunction baseDefinition(definition) {\n  if (definition.typeName && definition.typeName.baseType) {\n    return definition.typeName.baseType;\n  }\n\n  if (definition.baseType) {\n    return definition.baseType;\n  } //otherwise, we'll have to spoof it up ourselves\n\n\n  let baseIdentifier = typeIdentifier(definition).match(/^t_array\\$_(.*)_\\$/)[1]; //greedy match to extract everything from first to last dollar sign\n  // HACK - internal types for memory or storage also seem to be pointers\n\n  baseIdentifier = regularizeTypeIdentifier(baseIdentifier); // another HACK - we get away with it because we're only using that one property\n\n  let result = (0, cloneDeep_1.default)(definition);\n  result.typeDescriptions.typeIdentifier = baseIdentifier;\n  return result; //WARNING -- these hacks do *not* correctly handle all cases!\n  //they do, however, handle the cases we currently need.\n}\n\nexports.baseDefinition = baseDefinition;\n/**\n * for use for mappings and arrays only!\n * for arrays, fakes up a uint definition\n * @category Definition Reading\n */\n\nfunction keyDefinition(definition, scopes) {\n  let result;\n\n  switch (typeClass(definition)) {\n    case \"mapping\":\n      //first: is there a key type already there? if so just use that\n      if (definition.keyType) {\n        return definition.keyType;\n      }\n\n      if (definition.typeName && definition.typeName.keyType) {\n        return definition.typeName.keyType;\n      } //otherwise: is there a referencedDeclaration? if so try using that\n\n\n      let baseDeclarationId = definition.referencedDeclaration;\n      debug(\"baseDeclarationId %d\", baseDeclarationId); //if there's a referencedDeclaration, we'll use that\n\n      if (baseDeclarationId !== undefined) {\n        let baseDeclaration = scopes[baseDeclarationId].definition;\n        return baseDeclaration.keyType || baseDeclaration.typeName.keyType;\n      } //otherwise, we'll need to perform some hackery, similarly to in baseDefinition;\n      //we'll have to spoof it up ourselves\n\n\n      let keyIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_(.*?)_\\$_/)[1]; //use *non*-greedy match; note that if the key type could include\n      //the sequence \"_$_\", this could cause a problem, but they can't; the only\n      //valid key types that include dollar signs at all are user-defined types,\n      //which contain both \"$_\" and \"_$\" but never \"_$_\".\n      // HACK - internal types for memory or storage also seem to be pointers\n\n      keyIdentifier = regularizeTypeIdentifier(keyIdentifier);\n      let keyString = typeString(definition).match(/mapping\\((.*?) => .*\\)( storage)?$/)[1]; //use *non*-greedy match; note that if the key type could include\n      //\"=>\", this could cause a problem, but mappings are not allowed as key\n      //types, so this can't come up\n      // another HACK - we get away with it because we're only using that one property\n\n      result = (0, cloneDeep_1.default)(definition);\n      result.typeDescriptions = {\n        typeIdentifier: keyIdentifier,\n        typeString: keyString\n      };\n      return result;\n\n    case \"array\":\n      //HACK -- again we should get away with it because for a uint256 we don't\n      //really need to inspect the other properties\n      result = (0, cloneDeep_1.default)(definition);\n      result.typeDescriptions = {\n        typeIdentifier: \"t_uint256\",\n        typeString: \"uint256\"\n      };\n      return result;\n\n    default:\n      debug(\"unrecognized index access!\");\n  }\n}\n\nexports.keyDefinition = keyDefinition;\n/**\n * for use for mappings only!\n * @category Definition Reading\n */\n\nfunction valueDefinition(definition, scopes) {\n  let result; //first: is there a value type already there? if so just use that\n\n  if (definition.valueType) {\n    return definition.valueType;\n  }\n\n  if (definition.typeName && definition.typeName.valueType) {\n    return definition.typeName.valueType;\n  } //otherwise: is there a referencedDeclaration? if so try using that\n\n\n  let baseDeclarationId = definition.referencedDeclaration;\n  debug(\"baseDeclarationId %d\", baseDeclarationId); //if there's a referencedDeclaration, we'll use that\n\n  if (baseDeclarationId !== undefined) {\n    let baseDeclaration = scopes[baseDeclarationId].definition;\n    return baseDeclaration.valueType || baseDeclaration.typeName.valueType;\n  } //otherwise, we'll need to perform some hackery, similarly to in keyDefinition;\n  //we'll have to spoof it up ourselves\n\n\n  let valueIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_.*?_\\$_(.*)_\\$/)[1]; //use *non*-greedy match on the key; note that if the key type could include\n  //the sequence \"_$_\", this could cause a problem, but they can't; the only\n  //valid key types that include dollar signs at all are user-defined types,\n  //which contain both \"$_\" and \"_$\" but never \"_$_\".\n  // HACK - internal types for memory or storage also seem to be pointers\n\n  valueIdentifier = regularizeTypeIdentifier(valueIdentifier);\n  let valueString = typeString(definition).match(/mapping\\(.*? => (.*)\\)( storage)?$/)[1]; //use *non*-greedy match; note that if the key type could include\n  //\"=>\", this could cause a problem, but mappings are not allowed as key\n  //types, so this can't come up\n  // another HACK - we get away with it because we're only using that one property\n\n  result = (0, cloneDeep_1.default)(definition);\n  result.typeDescriptions = {\n    typeIdentifier: valueIdentifier,\n    typeString: valueString\n  };\n  return result;\n}\n\nexports.valueDefinition = valueDefinition;\n/**\n * returns input parameters, then output parameters\n * NOTE: ONLY FOR VARIABLE DECLARATIONS OF FUNCTION TYPE\n * NOT FOR FUNCTION DEFINITIONS\n * @category Definition Reading\n */\n\nfunction parameters(definition) {\n  let typeObject = definition.typeName || definition;\n\n  if (typeObject.parameterTypes && typeObject.returnParameterTypes) {\n    return [typeObject.parameterTypes.parameters, typeObject.returnParameterTypes.parameters];\n  } else {\n    return undefined;\n  }\n}\n\nexports.parameters = parameters;\n/**\n * compatibility function, since pre-0.5.0 functions don't have node.kind\n * returns undefined if you don't put in a function node\n * @category Definition Reading\n */\n\nfunction functionKind(node) {\n  if (node.nodeType !== \"FunctionDefinition\") {\n    return undefined;\n  }\n\n  if (node.kind !== undefined) {\n    //if we're dealing with 0.5.x, we can just read node.kind\n    return node.kind;\n  } //otherwise, we need this little shim\n\n\n  if (node.isConstructor) {\n    return \"constructor\";\n  }\n\n  return node.name === \"\" ? \"fallback\" : \"function\";\n}\n\nexports.functionKind = functionKind; //this is kind of a weird one, it exposes some Solidity internals.\n//for internal functions it'll return \"internal\".\n//for external functions it'll return \"external\".\n//for library functions it'll return \"delegatecall\".\n//and for builtin functions, it'll return an internal name for\n//that particular builtin function.\n//(there are more possibilities but I'm not going to list them all here)\n\nfunction functionClass(node) {\n  const match = typeIdentifier(node).match(/^t_function_([^_]+)_/);\n  return match ? match[1] : undefined;\n}\n\nexports.functionClass = functionClass;\n/**\n * similar compatibility function for mutability for pre-0.4.16 versions\n * returns undefined if you don't give it a FunctionDefinition or\n * VariableDeclaration\n * @category Definition Reading\n */\n\nfunction mutability(node) {\n  node = node.typeName || node;\n\n  if (node.nodeType !== \"FunctionDefinition\" && node.nodeType !== \"FunctionTypeName\") {\n    return undefined;\n  }\n\n  if (node.stateMutability !== undefined) {\n    //if we're dealing with 0.4.16 or later, we can just read node.stateMutability\n    return node.stateMutability;\n  } //otherwise, we need this little shim\n\n\n  if (node.payable) {\n    return \"payable\";\n  }\n\n  if (node.constant) {\n    //yes, it means \"view\" even if you're looking at a variable declaration!\n    //old Solidity was weird!\n    return \"view\";\n  }\n\n  return \"nonpayable\";\n}\n\nexports.mutability = mutability;\n/**\n * takes a contract definition and asks, does it have a payable fallback\n * function?\n * @category Definition Reading\n */\n\nfunction isContractPayable(definition) {\n  return definition.nodes.some(node => node.nodeType === \"FunctionDefinition\" && (functionKind(node) === \"fallback\" || functionKind(node) === \"receive\") && mutability(node) === \"payable\");\n}\n\nexports.isContractPayable = isContractPayable;\n/**\n * the main function. just does some dispatch.\n * returns undefined on bad input\n */\n\nfunction definitionToAbi(node, referenceDeclarations) {\n  switch (node.nodeType) {\n    case \"FunctionDefinition\":\n      if (node.visibility === \"public\" || node.visibility === \"external\") {\n        return functionDefinitionToAbi(node, referenceDeclarations);\n      } else {\n        return undefined;\n      }\n\n    case \"EventDefinition\":\n      return eventDefinitionToAbi(node, referenceDeclarations);\n\n    case \"ErrorDefinition\":\n      return errorDefinitionToAbi(node, referenceDeclarations);\n\n    case \"VariableDeclaration\":\n      if (node.visibility === \"public\") {\n        return getterDefinitionToAbi(node, referenceDeclarations);\n      } else {\n        return undefined;\n      }\n\n    default:\n      return undefined;\n  }\n}\n\nexports.definitionToAbi = definitionToAbi; //note: not for FunctionTypeNames or VariableDeclarations\n\nfunction functionDefinitionToAbi(node, referenceDeclarations) {\n  let kind = functionKind(node);\n  let stateMutability = mutability(node);\n  let payable = stateMutability === \"payable\";\n  let inputs;\n\n  switch (kind) {\n    case \"function\":\n      let name = node.name;\n      let outputs = parametersToAbi(node.returnParameters.parameters, referenceDeclarations);\n      inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n      return {\n        type: \"function\",\n        name,\n        inputs,\n        outputs,\n        stateMutability\n      };\n\n    case \"constructor\":\n      inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations); //note: need to coerce because of mutability restrictions\n\n      return {\n        type: \"constructor\",\n        inputs,\n        stateMutability,\n        payable\n      };\n\n    case \"fallback\":\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"fallback\",\n        stateMutability,\n        payable\n      };\n\n    case \"receive\":\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"receive\",\n        stateMutability,\n        payable\n      };\n  }\n}\n\nfunction eventDefinitionToAbi(node, referenceDeclarations) {\n  let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n  let name = node.name;\n  let anonymous = node.anonymous;\n  return {\n    type: \"event\",\n    inputs,\n    name,\n    anonymous\n  };\n}\n\nfunction errorDefinitionToAbi(node, referenceDeclarations) {\n  let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n  let name = node.name;\n  return {\n    type: \"error\",\n    inputs,\n    name\n  };\n}\n\nfunction parametersToAbi(nodes, referenceDeclarations) {\n  return nodes.map(node => parameterToAbi(node, referenceDeclarations));\n} //NOTE: This function is only for types that could potentially go in the ABI!\n//(otherwise it could, say, loop infinitely)\n//currently it will only ever be called on those because it's only called from\n//definitionToAbi, which filters out any definitions that are not for\n//this that *actually* go in the ABI\n//if you want to expand it to handle those (by throwing an exception, say),\n//you'll need to give it a way to detect circularities\n\n\nfunction parameterToAbi(node, referenceDeclarations) {\n  let name = node.name; //may be the empty string... or even undefined for a base type\n\n  let components;\n  let internalType = typeStringWithoutLocation(node); //is this an array? if so use separate logic\n\n  if (typeClass(node) === \"array\") {\n    let baseType = node.typeName ? node.typeName.baseType : node.baseType;\n    let baseAbi = parameterToAbi(baseType, referenceDeclarations);\n    let arraySuffix = isDynamicArray(node) ? `[]` : `[${staticLength(node)}]`;\n    const parameter = {\n      name,\n      type: baseAbi.type + arraySuffix,\n      components: baseAbi.components,\n      internalType\n    };\n\n    if (\"indexed\" in node) {\n      return Object.assign(Object.assign({}, parameter), {\n        indexed: node.indexed\n      });\n    } else {\n      return parameter;\n    }\n  }\n\n  let abiTypeString = toAbiType(node, referenceDeclarations); //otherwise... is it a struct? if so we need to populate components\n\n  if (typeClass(node) === \"struct\") {\n    let id = typeId(node);\n    let referenceDeclaration = referenceDeclarations[id];\n\n    if (referenceDeclaration === undefined) {\n      let typeToDisplay = typeString(node);\n      throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n    }\n\n    components = parametersToAbi(referenceDeclaration.members, referenceDeclarations);\n  }\n\n  const parameter = {\n    name,\n    type: abiTypeString,\n    components,\n    internalType\n  };\n\n  if (\"indexed\" in node) {\n    return Object.assign(Object.assign({}, parameter), {\n      indexed: node.indexed\n    });\n  } else {\n    return parameter;\n  }\n} //note: this is only meant for non-array types that can go in the ABI\n//it returns how that type is notated in the ABI -- just the string,\n//to be clear, not components of tuples\n//again, NOT FOR ARRAYS\n\n\nfunction toAbiType(node, referenceDeclarations) {\n  let basicType = typeClassLongForm(node); //get that whole first segment!\n\n  switch (basicType) {\n    case \"contract\":\n      return \"address\";\n\n    case \"struct\":\n      return \"tuple\";\n    //the more detailed checking will be handled elsewhere\n\n    case \"enum\":\n      {\n        const referenceId = typeId(node);\n        const referenceDeclaration = referenceDeclarations[referenceId];\n\n        if (referenceDeclaration === undefined) {\n          const typeToDisplay = typeString(node);\n          throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);\n        }\n\n        const numOptions = referenceDeclaration.members.length;\n        const bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n        return `uint${bits}`;\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const referenceId = typeId(node);\n        const referenceDeclaration = referenceDeclarations[referenceId];\n\n        if (referenceDeclaration === undefined) {\n          const typeToDisplay = typeString(node);\n          throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);\n        }\n\n        const underlyingType = referenceDeclaration.underlyingType;\n        return toAbiType(underlyingType, referenceDeclarations);\n      }\n\n    default:\n      return basicType;\n    //note that: int/uint/fixed/ufixed/bytes will have their size and such left on;\n    //address will have \"payable\" left off;\n    //external functions will be reduced to \"function\" (and internal functions shouldn't\n    //be passed in!)\n    //(mappings shouldn't be passed in either obviously)\n    //(nor arrays :P )\n  }\n}\n\nfunction getterDefinitionToAbi(node, referenceDeclarations) {\n  debug(\"getter node: %O\", node);\n  let name = node.name;\n  let {\n    inputs,\n    outputs\n  } = getterParameters(node, referenceDeclarations);\n  let inputsAbi = parametersToAbi(inputs, referenceDeclarations);\n  let outputsAbi = parametersToAbi(outputs, referenceDeclarations);\n  return {\n    type: \"function\",\n    name,\n    inputs: inputsAbi,\n    outputs: outputsAbi,\n    stateMutability: \"view\"\n  };\n} //how getter parameters work:\n//INPUT:\n//types other than arrays and mappings take no input.\n//array getters take uint256 input. mapping getters take input of their key type.\n//if arrays, mappings, stacked, then takes multiple inputs, in order from outside\n//to in.\n//These parameters are unnamed.\n//OUTPUT:\n//if base type (beneath mappings & arrays) is not a struct, returns that.\n//(This return parameter has no name -- it is *not* named for the variable!)\n//if it is a struct, returns multiple outputs, one for each member of the struct,\n//*except* arrays and mappings.  (And they have names, the names of the members.)\n//important note: inner structs within a struct are just returned, not\n//partially destructured like the outermost struct!  Yes, this is confusing.\n\n\nfunction getterParameters(node, referenceDeclarations) {\n  let baseNode = node.typeName || node;\n  let inputs = [];\n\n  while (typeClass(baseNode) === \"array\" || typeClass(baseNode) === \"mapping\") {\n    let keyNode = keyDefinition(baseNode); //note: if baseNode is an array, this spoofs up a uint256 definition\n\n    inputs.push(Object.assign(Object.assign({}, keyNode), {\n      name: \"\"\n    })); //again, getter input params have no name\n\n    switch (typeClass(baseNode)) {\n      case \"array\":\n        baseNode = baseNode.baseType;\n        break;\n\n      case \"mapping\":\n        baseNode = baseNode.valueType;\n        break;\n    }\n  } //at this point, baseNode should hold the base type\n  //now we face the question: is it a struct?\n\n\n  if (typeClass(baseNode) === \"struct\") {\n    let id = typeId(baseNode);\n    let referenceDeclaration = referenceDeclarations[id];\n\n    if (referenceDeclaration === undefined) {\n      let typeToDisplay = typeString(baseNode);\n      throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n    }\n\n    let outputs = referenceDeclaration.members.filter(member => typeClass(member) !== \"array\" && typeClass(member) !== \"mapping\");\n    return {\n      inputs,\n      outputs\n    }; //no need to wash name!\n  } else {\n    //only one output; it's just the base node, with its name washed\n    return {\n      inputs,\n      outputs: [Object.assign(Object.assign({}, baseNode), {\n        name: \"\"\n      })]\n    };\n  }\n}\n\nexports.getterParameters = getterParameters;","map":{"version":3,"mappings":"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","names":["debug","typeIdentifier","definition","typeDescriptions","exports","typeString","typeStringWithoutLocation","nodeType","replace","typeClass","match","typeClassLongForm","typeId","parseInt","visibility","typeName","specifiedSize","specified","num","decimalPlaces","isArray","isDynamicArray","staticLength","staticLengthAsString","isStruct","isMapping","isEnum","isReference","referenceType","contractKind","split","stackSize","isSimpleConstant","types","includes","spliceLocation","location","regularizeTypeIdentifier","identifier","rationalValue","absoluteValue","isNegative","bn_js_1","neg","baseDefinition","baseType","baseIdentifier","result","keyDefinition","scopes","keyType","baseDeclarationId","referencedDeclaration","undefined","baseDeclaration","keyIdentifier","keyString","valueDefinition","valueType","valueIdentifier","valueString","parameters","typeObject","parameterTypes","returnParameterTypes","functionKind","node","kind","isConstructor","name","functionClass","mutability","stateMutability","payable","constant","isContractPayable","nodes","some","definitionToAbi","referenceDeclarations","functionDefinitionToAbi","eventDefinitionToAbi","errorDefinitionToAbi","getterDefinitionToAbi","inputs","outputs","parametersToAbi","returnParameters","type","anonymous","map","parameterToAbi","components","internalType","baseAbi","arraySuffix","parameter","Object","indexed","abiTypeString","toAbiType","id","referenceDeclaration","typeToDisplay","Common","UnknownUserDefinedTypeError","toString","members","basicType","referenceId","numOptions","length","bits","Math","ceil","log2","underlyingType","getterParameters","inputsAbi","outputsAbi","baseNode","keyNode","push","filter","member"],"sourceRoot":"","sources":["../../../lib/ast/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}