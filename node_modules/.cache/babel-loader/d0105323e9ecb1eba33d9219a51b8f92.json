{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isMoreSpecific = exports.isMoreSpecificMultiple = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:priority\");\n\nconst Format = __importStar(require(\"../format\"));\n\nconst utils_1 = require(\"./utils\"); //is input 1 more specific than input 2? (nonstrict)\n\n\nfunction isMoreSpecificMultiple(types1, types2, userDefinedTypes) {\n  //just wrap the types in tuples and defer to isMoreSpecific()\n  const combinedType1 = {\n    typeClass: \"tuple\",\n    memberTypes: types1\n  };\n  const combinedType2 = {\n    typeClass: \"tuple\",\n    memberTypes: types2\n  };\n  return isMoreSpecific(combinedType1, combinedType2, userDefinedTypes, true); //that last flag is so we ignore variable names at top level\n}\n\nexports.isMoreSpecificMultiple = isMoreSpecificMultiple; //is input 1 more specific than input 2?\n//(this is nonstrict)\n\nfunction isMoreSpecific(type1, type2, userDefinedTypes) {\n  let ignoreComponentNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  //udvts get priority of underlying type!\n  if (type1.typeClass === \"userDefinedValueType\") {\n    type1 = getUnderlyingType(type1, userDefinedTypes);\n  }\n\n  if (type2.typeClass === \"userDefinedValueType\") {\n    type2 = getUnderlyingType(type2, userDefinedTypes);\n  }\n\n  const typeClasses = [[\"options\"], [\"array\"], [\"struct\", \"tuple\"], [\"address\", \"contract\"], [\"bytes\"], [\"function\"], [\"uint\", \"int\", \"fixed\", \"ufixed\"], [\"enum\"], [\"string\"], [\"bool\"]]; //for each type, what's the first one it counts as?\n\n  const index1 = typeClasses.findIndex(classes => classes.includes(type1.typeClass));\n  const index2 = typeClasses.findIndex(classes => classes.includes(type2.typeClass)); //NOTE: I am assuming neither will be -1!\n  //If either is, something has gone very wrong!\n\n  if (index1 < index2) {\n    return true;\n  } else if (index2 < index1) {\n    return false;\n  } //otherwise, indices are equal, defer to tiebreaker\n\n\n  switch (type1.typeClass) {\n    case \"options\":\n      return isMoreSpecificOptions(type1, type2);\n\n    case \"address\":\n    case \"contract\":\n      return isMoreSpecificAddress(type1, type2);\n\n    case \"function\":\n      return isMoreSpecificFunction( //we haven't actually checked visibility, so we'll have to coerce\n      type1, type2, userDefinedTypes);\n\n    case \"array\":\n      return isMoreSpecificArray(type1, type2, userDefinedTypes);\n\n    case \"bytes\":\n      return isMoreSpecificBytes(type1, type2);\n\n    case \"uint\":\n    case \"int\":\n    case \"fixed\":\n    case \"ufixed\":\n      return isMoreSpecificNumeric(type1, type2);\n\n    case \"enum\":\n      return isMoreSpecificEnum(type1, type2);\n\n    case \"string\":\n      return isMoreSpecificString(type1, type2);\n\n    case \"struct\":\n    case \"tuple\":\n      return isMoreSpecificTuple(type1, type2, userDefinedTypes, ignoreComponentNames);\n\n    case \"bool\":\n      return isMoreSpecificBool(type1, type2);\n  }\n}\n\nexports.isMoreSpecific = isMoreSpecific;\n\nfunction isMoreSpecificAddress(type1, type2) {\n  //address payable more specific than address\n  //contract types more specific than address\n  //*payable* contract types more specific than address payable\n  if (type1.typeClass === \"address\" && type2.typeClass === \"address\") {\n    if (type1.kind === \"specific\" && type2.kind === \"specific\") {\n      return type1.payable || !type2.payable;\n    } else if (type2.kind === \"general\") {\n      //specific is more specific than general :P\n      return true;\n    }\n  }\n\n  if (type1.typeClass === \"contract\" && type2.typeClass === \"contract\") {\n    if (type1.kind === \"native\" && type2.kind === \"native\") {\n      return type1.id === type2.id;\n    } //foreign contract types will always be incomparable, I guess?\n    //(they shouldn't come up here anyway)\n\n  }\n\n  if (type1.typeClass === \"contract\" && type2.typeClass === \"address\") {\n    return type2.kind === \"general\" || type2.kind === \"specific\" && !type2.payable || type2.kind === \"specific\" && type1.payable;\n  }\n\n  return false; //otherwise\n}\n\nfunction isMoreSpecificBytes(type1, type2) {\n  //static more specific than dynamic, with shorter\n  //lengths more specific than longer ones\n  return type1.kind === \"dynamic\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"static\" && type1.length <= type2.length;\n}\n\nfunction isMoreSpecificNumeric(type1, type2) {\n  return (0, utils_1.maxValue)(type1).lte((0, utils_1.maxValue)(type2)) && (0, utils_1.minValue)(type1).gte((0, utils_1.minValue)(type2)) && (0, utils_1.places)(type1) <= (0, utils_1.places)(type2) && //note: I don't know whether this final bit is actually necessary\n  //since we don't actually know yet whether fixedNx0 will be legal\n  !((type1.typeClass === \"fixed\" || type1.typeClass === \"ufixed\") && (type2.typeClass === \"int\" || type2.typeClass === \"uint\"));\n}\n\nfunction isMoreSpecificEnum(type1, type2) {\n  //different enum types are incomparable\n  return type1.id === type2.id;\n}\n\nfunction isMoreSpecificString(_type1, _type2) {\n  //only one string type\n  return true;\n}\n\nfunction isMoreSpecificArray(type1, type2, userDefinedTypes) {\n  //static is more specific than dynamic, but\n  //different static lengths are incomparable\n  const moreSpecificLength = type1.kind === \"dynamic\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"dynamic\" || type1.kind === \"static\" && type2.kind === \"static\" && type1.length.eq(type2.length); //length and types must both be more specific\n\n  return moreSpecificLength && isMoreSpecific(type1.baseType, type2.baseType, userDefinedTypes);\n}\n\nfunction isMoreSpecificFunction(type1, type2, userDefinedTypes) {\n  switch (type2.kind) {\n    case \"general\":\n      return true;\n\n    case \"specific\":\n      switch (type1.kind) {\n        case \"general\":\n          return false;\n\n        case \"specific\":\n          //now: if they're both specific...\n          //(this case doesn't really matter, but let's do it anyway)\n          if (!isMutabilityMoreSpecific(type1.mutability, type2.mutability)) {\n            return false;\n          }\n\n          if (type1.outputParameterTypes.length !== type2.outputParameterTypes.length) {\n            return false;\n          }\n\n          for (let i = 0; i < type1.outputParameterTypes.length; i++) {\n            if (!isMoreSpecific(type1.outputParameterTypes[i], type2.outputParameterTypes[i], userDefinedTypes)) {\n              return false;\n            }\n          }\n\n          if (type1.inputParameterTypes.length !== type2.inputParameterTypes.length) {\n            return false;\n          }\n\n          for (let i = 0; i < type1.inputParameterTypes.length; i++) {\n            if (!isMoreSpecific( //swapped for contravariance, I guess...?\n            type2.inputParameterTypes[i], type1.inputParameterTypes[i], userDefinedTypes)) {\n              return false;\n            }\n          }\n\n          return true;\n      }\n\n  }\n}\n\nfunction isMutabilityMoreSpecific(mutability1, mutability2) {\n  //pure <= view <= nonpayable, payable <= nonpayable\n  return mutability1 === mutability2 || mutability1 === \"pure\" && mutability2 !== \"payable\" || mutability2 === \"nonpayable\";\n}\n\nfunction isMoreSpecificTuple(type1, type2, userDefinedTypes) {\n  let ignoreComponentNames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  debug(\"type1: %O\", type1);\n  debug(\"type2: %O\", type2);\n  const fullType1 = Format.Types.fullType(type1, userDefinedTypes);\n  const fullType2 = Format.Types.fullType(type2, userDefinedTypes);\n  const types1 = fullType1.memberTypes.map(member => member.type);\n  const types2 = fullType2.memberTypes.map(member => member.type); //lengths must match\n\n  if (types1.length !== types2.length) {\n    return false;\n  } //individual types must satisfy isMoreSpecific\n\n\n  for (let i = 0; i < types1.length; i++) {\n    //note we do *not* pass along the ignoreComponentNames flag\n    if (!isMoreSpecific(types1[i], types2[i], userDefinedTypes)) {\n      return false;\n    }\n  }\n\n  if (!ignoreComponentNames) {\n    debug(\"checking by name\"); //if this flag is not set, *and* the component names match,\n    //(and all exist)\n    //then compare by component names in addition to by position\n\n    let names1 = fullType1.memberTypes.map(member => member.name);\n    let names2 = fullType2.memberTypes.map(member => member.name); //we just created these via a map so it's OK to sort in-place\n\n    names1.sort();\n    names2.sort();\n    let namesEqual = true;\n\n    for (let i = 0; i < names1.length; i++) {\n      if (!names1[i] || !names2[i] || names1[i] !== names2[i]) {\n        namesEqual = false;\n        break;\n      }\n    }\n\n    if (namesEqual) {\n      debug(\"names equal\");\n\n      for (let i = 0; i < types1.length; i++) {\n        const type1 = types1[i];\n        const name = fullType1.memberTypes[i].name;\n        const type2 = fullType2.memberTypes.find(_ref => {\n          let {\n            name: name2\n          } = _ref;\n          return name2 === name;\n        }).type;\n        debug(\"name: %s\", name);\n        debug(\"type1: %O\", type1);\n        debug(\"type2: %O\", type2);\n\n        if (!isMoreSpecific(type1, type2, userDefinedTypes)) {\n          debug(\"returning false\");\n          return false;\n        }\n      }\n\n      debug(\"name check ok\");\n    }\n  }\n\n  return true; //I was going to make structs more specific than their underlying\n  //tuples, and different equivalent structs incomparable, but I\n  //couldn't find a good way to do that, so whatever, they're all\n  //just equivalent, it won't come up\n}\n\nfunction isMoreSpecificOptions(_type1, _type2) {\n  //only one options type\n  return true;\n}\n\nfunction isMoreSpecificBool(_type1, _type2) {\n  //only one boolean type\n  return true;\n}\n\nfunction getUnderlyingType(udvtType, userDefinedTypes) {\n  return Format.Types.fullType(udvtType, userDefinedTypes).underlyingType;\n}","map":{"version":3,"mappings":"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","names":["debug","isMoreSpecificMultiple","types1","types2","userDefinedTypes","combinedType1","typeClass","memberTypes","combinedType2","isMoreSpecific","exports","type1","type2","ignoreComponentNames","getUnderlyingType","typeClasses","index1","findIndex","classes","includes","index2","isMoreSpecificOptions","isMoreSpecificAddress","isMoreSpecificFunction","isMoreSpecificArray","isMoreSpecificBytes","isMoreSpecificNumeric","isMoreSpecificEnum","isMoreSpecificString","isMoreSpecificTuple","isMoreSpecificBool","kind","payable","id","length","lte","gte","_type1","_type2","moreSpecificLength","eq","baseType","isMutabilityMoreSpecific","mutability","outputParameterTypes","i","inputParameterTypes","mutability1","mutability2","fullType1","Format","Types","fullType","fullType2","map","member","type","names1","name","names2","sort","namesEqual","find","name2","udvtType","underlyingType"],"sourceRoot":"","sources":["../../../lib/wrap/priority.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}