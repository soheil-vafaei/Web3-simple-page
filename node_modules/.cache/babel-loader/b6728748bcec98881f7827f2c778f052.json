{"ast":null,"code":"import { MaxLengthUpperBound } from '../helpers/MaxLengthFromMinLength.js';\nexport function patternsToStringMapper(tab) {\n  return tab.join('');\n}\nexport function patternsToStringUnmapperFor(patternsArb, constraints) {\n  return function patternsToStringUnmapper(value) {\n    if (typeof value !== 'string') {\n      throw new Error('Unsupported value');\n    }\n\n    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthUpperBound;\n\n    if (value.length === 0) {\n      if (minLength > 0) {\n        throw new Error('Unable to unmap received string');\n      }\n\n      return [];\n    }\n\n    const stack = [{\n      endIndexChunks: 0,\n      nextStartIndex: 1,\n      chunks: []\n    }];\n\n    while (stack.length > 0) {\n      const last = stack.pop();\n\n      for (let index = last.nextStartIndex; index <= value.length; ++index) {\n        const chunk = value.substring(last.endIndexChunks, index);\n\n        if (patternsArb.canShrinkWithoutContext(chunk)) {\n          const newChunks = last.chunks.concat([chunk]);\n\n          if (index === value.length) {\n            if (newChunks.length < minLength || newChunks.length > maxLength) {\n              break;\n            }\n\n            return newChunks;\n          }\n\n          stack.push({\n            endIndexChunks: last.endIndexChunks,\n            nextStartIndex: index + 1,\n            chunks: last.chunks\n          });\n          stack.push({\n            endIndexChunks: index,\n            nextStartIndex: index + 1,\n            chunks: newChunks\n          });\n          break;\n        }\n      }\n    }\n\n    throw new Error('Unable to unmap received string');\n  };\n}","map":{"version":3,"names":["MaxLengthUpperBound","patternsToStringMapper","tab","join","patternsToStringUnmapperFor","patternsArb","constraints","patternsToStringUnmapper","value","Error","minLength","undefined","maxLength","length","stack","endIndexChunks","nextStartIndex","chunks","last","pop","index","chunk","substring","canShrinkWithoutContext","newChunks","concat","push"],"sources":["/Users/soheilvafaei/Documents/project/web/resume/ex7/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js"],"sourcesContent":["import { MaxLengthUpperBound } from '../helpers/MaxLengthFromMinLength.js';\nexport function patternsToStringMapper(tab) {\n    return tab.join('');\n}\nexport function patternsToStringUnmapperFor(patternsArb, constraints) {\n    return function patternsToStringUnmapper(value) {\n        if (typeof value !== 'string') {\n            throw new Error('Unsupported value');\n        }\n        const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n        const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthUpperBound;\n        if (value.length === 0) {\n            if (minLength > 0) {\n                throw new Error('Unable to unmap received string');\n            }\n            return [];\n        }\n        const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];\n        while (stack.length > 0) {\n            const last = stack.pop();\n            for (let index = last.nextStartIndex; index <= value.length; ++index) {\n                const chunk = value.substring(last.endIndexChunks, index);\n                if (patternsArb.canShrinkWithoutContext(chunk)) {\n                    const newChunks = last.chunks.concat([chunk]);\n                    if (index === value.length) {\n                        if (newChunks.length < minLength || newChunks.length > maxLength) {\n                            break;\n                        }\n                        return newChunks;\n                    }\n                    stack.push({ endIndexChunks: last.endIndexChunks, nextStartIndex: index + 1, chunks: last.chunks });\n                    stack.push({ endIndexChunks: index, nextStartIndex: index + 1, chunks: newChunks });\n                    break;\n                }\n            }\n        }\n        throw new Error('Unable to unmap received string');\n    };\n}\n"],"mappings":"AAAA,SAASA,mBAAT,QAAoC,sCAApC;AACA,OAAO,SAASC,sBAAT,CAAgCC,GAAhC,EAAqC;EACxC,OAAOA,GAAG,CAACC,IAAJ,CAAS,EAAT,CAAP;AACH;AACD,OAAO,SAASC,2BAAT,CAAqCC,WAArC,EAAkDC,WAAlD,EAA+D;EAClE,OAAO,SAASC,wBAAT,CAAkCC,KAAlC,EAAyC;IAC5C,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;MAC3B,MAAM,IAAIC,KAAJ,CAAU,mBAAV,CAAN;IACH;;IACD,MAAMC,SAAS,GAAGJ,WAAW,CAACI,SAAZ,KAA0BC,SAA1B,GAAsCL,WAAW,CAACI,SAAlD,GAA8D,CAAhF;IACA,MAAME,SAAS,GAAGN,WAAW,CAACM,SAAZ,KAA0BD,SAA1B,GAAsCL,WAAW,CAACM,SAAlD,GAA8DZ,mBAAhF;;IACA,IAAIQ,KAAK,CAACK,MAAN,KAAiB,CAArB,EAAwB;MACpB,IAAIH,SAAS,GAAG,CAAhB,EAAmB;QACf,MAAM,IAAID,KAAJ,CAAU,iCAAV,CAAN;MACH;;MACD,OAAO,EAAP;IACH;;IACD,MAAMK,KAAK,GAAG,CAAC;MAAEC,cAAc,EAAE,CAAlB;MAAqBC,cAAc,EAAE,CAArC;MAAwCC,MAAM,EAAE;IAAhD,CAAD,CAAd;;IACA,OAAOH,KAAK,CAACD,MAAN,GAAe,CAAtB,EAAyB;MACrB,MAAMK,IAAI,GAAGJ,KAAK,CAACK,GAAN,EAAb;;MACA,KAAK,IAAIC,KAAK,GAAGF,IAAI,CAACF,cAAtB,EAAsCI,KAAK,IAAIZ,KAAK,CAACK,MAArD,EAA6D,EAAEO,KAA/D,EAAsE;QAClE,MAAMC,KAAK,GAAGb,KAAK,CAACc,SAAN,CAAgBJ,IAAI,CAACH,cAArB,EAAqCK,KAArC,CAAd;;QACA,IAAIf,WAAW,CAACkB,uBAAZ,CAAoCF,KAApC,CAAJ,EAAgD;UAC5C,MAAMG,SAAS,GAAGN,IAAI,CAACD,MAAL,CAAYQ,MAAZ,CAAmB,CAACJ,KAAD,CAAnB,CAAlB;;UACA,IAAID,KAAK,KAAKZ,KAAK,CAACK,MAApB,EAA4B;YACxB,IAAIW,SAAS,CAACX,MAAV,GAAmBH,SAAnB,IAAgCc,SAAS,CAACX,MAAV,GAAmBD,SAAvD,EAAkE;cAC9D;YACH;;YACD,OAAOY,SAAP;UACH;;UACDV,KAAK,CAACY,IAAN,CAAW;YAAEX,cAAc,EAAEG,IAAI,CAACH,cAAvB;YAAuCC,cAAc,EAAEI,KAAK,GAAG,CAA/D;YAAkEH,MAAM,EAAEC,IAAI,CAACD;UAA/E,CAAX;UACAH,KAAK,CAACY,IAAN,CAAW;YAAEX,cAAc,EAAEK,KAAlB;YAAyBJ,cAAc,EAAEI,KAAK,GAAG,CAAjD;YAAoDH,MAAM,EAAEO;UAA5D,CAAX;UACA;QACH;MACJ;IACJ;;IACD,MAAM,IAAIf,KAAJ,CAAU,iCAAV,CAAN;EACH,CAhCD;AAiCH"},"metadata":{},"sourceType":"module"}