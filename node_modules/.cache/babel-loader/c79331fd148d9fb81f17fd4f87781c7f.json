{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAndWrap = exports.wrapForMethod = exports.wrapMultiple = exports.Messages = exports.wrap = exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap\");\n\nconst priority_1 = require(\"./priority\");\n\nconst errors_1 = require(\"./errors\");\n\nObject.defineProperty(exports, \"NoOverloadsMatchedError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoOverloadsMatchedError;\n  }\n});\nObject.defineProperty(exports, \"NoUniqueBestOverloadError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.NoUniqueBestOverloadError;\n  }\n});\nObject.defineProperty(exports, \"TypeMismatchError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.TypeMismatchError;\n  }\n});\nObject.defineProperty(exports, \"BadResponseTypeError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.BadResponseTypeError;\n  }\n});\n\n__exportStar(require(\"./errors\"), exports);\n\nconst wrap_1 = require(\"./wrap\");\n\nObject.defineProperty(exports, \"wrap\", {\n  enumerable: true,\n  get: function () {\n    return wrap_1.wrap;\n  }\n});\n\n__exportStar(require(\"./types\"), exports);\n\nexports.Messages = __importStar(require(\"./messages\"));\n\nfunction* wrapMultiple(types, inputs, wrapOptions) {\n  //just wrap the types in a tuple and defer to wrap()\n  const combinedType = {\n    typeClass: \"tuple\",\n    memberTypes: types\n  };\n  debug(\"wrapping multiple\");\n  const wrappedTogether = yield* (0, wrap_1.wrap)(combinedType, inputs, wrapOptions);\n  return wrappedTogether.value.map(_ref => {\n    let {\n      value\n    } = _ref;\n    return value;\n  });\n}\n\nexports.wrapMultiple = wrapMultiple; //note: turns on loose\n\nfunction* wrapForMethod(method, inputs, resolveOptions) {\n  const wrapped = yield* wrapForMethodRaw(method, inputs, resolveOptions, true);\n  return wrappingToResolution(method, wrapped);\n}\n\nexports.wrapForMethod = wrapForMethod;\n\nfunction wrappingToResolution(method, wrapped) {\n  if (wrapped.length > 0 && wrapped[wrapped.length - 1].type.typeClass === \"options\") {\n    //there's options\n    const wrappedArguments = wrapped.slice(0, -1); //cut off options\n\n    const options = wrapped[wrapped.length - 1].value;\n    return {\n      method,\n      arguments: wrappedArguments,\n      options\n    };\n  } else {\n    //no options\n    return {\n      method,\n      arguments: wrapped,\n      options: {}\n    };\n  }\n} //doesn't separate out options from arguments & doesn't turn on loose\n\n\nfunction* wrapForMethodRaw(method, inputs, _ref2) {\n  let {\n    userDefinedTypes,\n    allowOptions,\n    allowJson,\n    strictBooleans\n  } = _ref2;\n  let loose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  debug(\"wrapping for method\");\n\n  if (method.inputs.length === inputs.length) {\n    //no options case\n    debug(\"no options\");\n    return yield* wrapMultiple(method.inputs, inputs, {\n      userDefinedTypes,\n      oldOptionsBehavior: true,\n      loose,\n      name: \"<arguments>\",\n      allowJson,\n      strictBooleans\n    });\n  } else if (allowOptions && method.inputs.length === inputs.length - 1) {\n    //options case\n    debug(\"options\");\n    const inputsWithOptions = [...method.inputs, {\n      name: \"<options>\",\n      type: {\n        typeClass: \"options\"\n      }\n    }];\n    return yield* wrapMultiple(inputsWithOptions, inputs, {\n      userDefinedTypes,\n      oldOptionsBehavior: true,\n      loose,\n      name: \"<arguments>\",\n      allowJson,\n      strictBooleans\n    });\n  } else {\n    //invalid length case\n    const orOneMore = allowOptions ? ` (or ${method.inputs.length + 1} counting transaction options)` : \"\";\n    throw new errors_1.TypeMismatchError({\n      typeClass: \"tuple\",\n      memberTypes: method.inputs\n    }, inputs, \"<arguments>\", 5, `Incorrect number of arguments (expected ${method.inputs.length}${orOneMore}, got ${inputs.length})`);\n  }\n}\n\nfunction* resolveAndWrap(methods, inputs, _ref3) {\n  let {\n    userDefinedTypes,\n    allowOptions,\n    allowJson,\n    strictBooleans\n  } = _ref3;\n\n  //despite us having a good system for overload resolution, we want to\n  //use it as little as possible!  That's because using it means we don't\n  //get great error messages.  As such, we're going to do a bunch to filter\n  //things beforehand, so that we get good error messages.\n  if (methods.length === 1) {\n    //if there's only one possibility, we just defer to wrapForMethod\n    //if we ignore error messages this is silly... but we're not!\n    //this is important for good error messages in this case\n    return yield* wrapForMethod(methods[0], inputs, {\n      userDefinedTypes,\n      allowOptions,\n      allowJson,\n      strictBooleans\n    });\n  } //OK, so, there are multiple possibilities then.  let's try to filter things down by length.\n\n\n  const possibleMatches = methods.filter(method => method.inputs.length === inputs.length); //but, we've also got to account for the possibility of options\n\n  let possibleMatchesWithOptions = [];\n  let possibleOptions = {};\n\n  if (allowOptions && inputs.length > 0) {\n    //if options are allowed, we'll have to account for that.\n    //*however*, in order to minimize the number of possibilities, we won't\n    //use these unless the last argument of inputs actually looks like an options!\n    const lastInput = inputs[inputs.length - 1];\n    let isOptionsPossible = true;\n\n    try {\n      const wrappedOptions = yield* (0, wrap_1.wrap)({\n        typeClass: \"options\"\n      }, lastInput, {\n        name: \"<options>\",\n        loose: true,\n        oldOptionsBehavior: true,\n        userDefinedTypes,\n        allowJson,\n        strictBooleans\n      });\n      possibleOptions = wrappedOptions.value;\n    } catch (error) {\n      if (error instanceof errors_1.TypeMismatchError) {\n        isOptionsPossible = false;\n      } else {\n        throw error; //rethrow unexpected errors\n      }\n    }\n\n    if (isOptionsPossible) {\n      possibleMatchesWithOptions = methods.filter(method => method.inputs.length === inputs.length - 1);\n    }\n  }\n\n  debug(\"possibleMatches: %o\", possibleMatches);\n  debug(\"possibleMatchesWithOptions: %o\", possibleMatchesWithOptions); //if there's now only one possibility, great!\n\n  if (possibleMatches.length === 1 && possibleMatchesWithOptions.length === 0) {\n    //only one possibility, no options. we can just defer to wrapMultiple.\n    //(again, point is to have good error messaging)\n    debug(\"only one possibility, no options\");\n    const method = possibleMatches[0];\n    return {\n      method,\n      arguments: yield* wrapMultiple(method.inputs, inputs, {\n        userDefinedTypes,\n        loose: true,\n        name: \"<arguments>\",\n        allowJson,\n        strictBooleans\n      }),\n      options: {}\n    };\n  } else if (possibleMatchesWithOptions.length === 1 && possibleMatches.length === 0) {\n    //only one possibility, with options.  moreover, we already determined the options\n    //above, so we can once again just defer to wrapMultiple\n    debug(\"only one possiblity, with options\");\n    const method = possibleMatchesWithOptions[0];\n    return {\n      method,\n      arguments: yield* wrapMultiple(method.inputs, inputs, {\n        userDefinedTypes,\n        loose: true,\n        name: \"<arguments>\",\n        allowJson,\n        strictBooleans\n      }),\n      options: possibleOptions\n    };\n  } else if (possibleMatches.length === 0 && possibleMatchesWithOptions.length === 0) {\n    debug(\"no possibilities\"); //nothing matches!\n\n    throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n  } //if all of our attempts to avoid it have failed, we'll have to actually use\n  //our overload resolution system. note how we do *not* turn on loose in this\n  //case!\n\n\n  debug(\"attempting overload resolution\");\n  let resolutions = [];\n\n  for (const method of methods) {\n    let wrapped;\n\n    try {\n      //note this part takes care of options for us...\n      //although yes this means options will be re-wrapped, oh well\n      wrapped = yield* wrapForMethodRaw(method, inputs, {\n        userDefinedTypes,\n        allowOptions,\n        allowJson,\n        strictBooleans\n      });\n    } catch (error) {\n      //if there's an error, don't add it\n      debug(\"failed: %O\", method);\n      debug(\"because: %O\", error);\n      continue;\n    } //note that options and arguments here are both not correct, but we'll\n    //fix them up later!\n\n\n    debug(\"adding: %O\", method);\n    resolutions.push({\n      method,\n      arguments: wrapped,\n      options: {}\n    });\n  } //now: narrow it down to the most specific one(s)\n\n\n  debug(\"resolutions: %O\", resolutions);\n  resolutions = resolutions.filter(resolution => resolutions.every(comparisonResolution => !(0, priority_1.isMoreSpecificMultiple)(comparisonResolution.arguments, resolution.arguments, userDefinedTypes) || //because the comparison is nonstrict, this comparison is added to\n  //effectively make it strict\n  // i.e. we have !(x<=y) but we want !(x<y), i.e.,\n  // !(x<=y) | x=y, i.e., !(x<=y) | (x<=y & y<=x),\n  // i.e., !(x<=y) | y<=x\n  (0, priority_1.isMoreSpecificMultiple)(resolution.arguments, comparisonResolution.arguments, userDefinedTypes)));\n  debug(\"resolutions remaining: %O\", resolutions);\n\n  switch (resolutions.length) {\n    case 0:\n      //no resolution worked\n      throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);\n\n    case 1:\n      //there was a most specific resolution; fix up options and arguments\n      //before returning\n      const {\n        method,\n        arguments: wrapped\n      } = resolutions[0];\n      return wrappingToResolution(method, wrapped);\n\n    default:\n      //no unique most-specific resolution\n      throw new errors_1.NoUniqueBestOverloadError(resolutions);\n  }\n}\n\nexports.resolveAndWrap = resolveAndWrap;","map":{"version":3,"mappings":"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","names":["debug","Object","enumerable","get","errors_1","__exportStar","wrap_1","exports","wrapMultiple","types","inputs","wrapOptions","combinedType","typeClass","memberTypes","wrappedTogether","value","map","wrapForMethod","method","resolveOptions","wrapped","wrapForMethodRaw","wrappingToResolution","length","type","wrappedArguments","slice","options","arguments","userDefinedTypes","allowOptions","allowJson","strictBooleans","loose","oldOptionsBehavior","name","inputsWithOptions","orOneMore","resolveAndWrap","methods","possibleMatches","filter","possibleMatchesWithOptions","possibleOptions","lastInput","isOptionsPossible","wrappedOptions","error","resolutions","push","resolution","every","comparisonResolution"],"sourceRoot":"","sources":["../../../lib/wrap/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}