{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\n\nconst Tagged = require('./tagged');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst NoFilter = require('nofilter');\n\nconst constants = require('./constants'); // Do not fix this if you want to support node v4\n\n\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SIMPLE = constants.SIMPLE;\nconst SYMS = constants.SYMS;\nconst BI = utils.bigIntize(constants.BI);\nconst BN = constants.BN;\nconst COUNT = Symbol('count');\nconst PENDING_KEY = Symbol('pending_key');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\n\nfunction parentArray(parent, typ, count) {\n  const a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n/**\n * @param {Buffer} v\n * @private\n */\n\n\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v);\n}\n/**\n * @param {BigInt} v\n * @private\n */\n\n\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v);\n}\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\n\n\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  constructor(options) {\n    options = options || {};\n    const tags = options.tags;\n    delete options.tags;\n    const max_depth = options.max_depth != null ? options.max_depth : -1;\n    delete options.max_depth;\n    const bigI = utils.hasBigInt ? !!options.bigint : false;\n    delete options.bigint;\n    super(options);\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n\n    if (bigI) {\n      if (this.tags == null) {\n        this.tags = {};\n      }\n\n      if (this.tags[2] == null) {\n        this.tags[2] = _tag_2;\n      }\n\n      if (this.tags[3] == null) {\n        this.tags[3] = _tag_3;\n      }\n    }\n  }\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n\n\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n\n      case SYMS.UNDEFINED:\n        return undefined;\n\n      case NOT_FOUND:\n        throw new Error('Value not found');\n\n      default:\n        return val;\n    }\n  }\n  /**\n   * @typedef DecodeOptions\n   * @property {string} [encoding='hex'] - The encoding of the input.\n   *   Ignored if input is a Buffer.\n   */\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw an\n   * exception if the input is not valid CBOR.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options\n   * @returns {any} - the decoded value\n   */\n\n\n  static decodeFirstSync(input, options) {\n    options = options || {\n      encoding: 'hex'\n    };\n    let opts = {};\n    let encod;\n\n    switch (typeof options) {\n      case 'string':\n        encod = options;\n        break;\n\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding;\n        delete opts.encoding;\n        break;\n    }\n\n    const c = new Decoder(opts);\n    const s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input)); // for/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n\n    const parser = c._parse();\n\n    let state = parser.next();\n\n    while (!state.done) {\n      const b = s.read(state.value);\n\n      if (b == null || b.length !== state.value) {\n        throw new Error('Insufficient data');\n      }\n\n      state = parser.next(b);\n    }\n\n    const val = Decoder.nullcheck(state.value);\n\n    if (s.length > 0) {\n      const nextByte = s.read(1);\n      s.unshift(nextByte);\n      const er = new Error('Unexpected data: 0x' + nextByte[0].toString(16));\n      er.value = val;\n      throw er;\n    }\n\n    return val;\n  }\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options or encoding string\n   * @returns {Array} - Array of all found items\n   */\n\n\n  static decodeAllSync(input, options) {\n    options = options || {\n      encoding: 'hex'\n    };\n    let opts = {};\n    let encod;\n\n    switch (typeof options) {\n      case 'string':\n        encod = options;\n        break;\n\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding;\n        delete opts.encoding;\n    }\n\n    const c = new Decoder(opts);\n    const s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));\n    const res = [];\n\n    while (s.length > 0) {\n      const parser = c._parse();\n\n      let state = parser.next();\n\n      while (!state.done) {\n        const b = s.read(state.value);\n\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n\n        state = parser.next(b);\n      }\n\n      res.push(Decoder.nullcheck(state.value));\n    }\n\n    return res;\n  }\n  /**\n   * @callback decodeCallback\n   * @param {Error} [error] - if one was generated\n   * @param {any} [value] - the decoded value\n   */\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are more\n   * bytes left over at the end, and optionally if there were no valid CBOR\n   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n   * if no data was found and the `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer} input - the input to parse\n   * @param {DecodeOptions|decodeCallback|string} [options] - options\n   * @param {decodeCallback} [cb] callback\n   * @returns {Promise<any>} returned even if callback is specified\n   */\n\n\n  static decodeFirst(input, options, cb) {\n    let opts = {};\n    let required = false;\n    let encod = 'hex';\n\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        encod = utils.guessEncoding(input);\n        break;\n\n      case 'string':\n        encod = options;\n        break;\n\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n        required = opts.required != null ? opts.required : false;\n        delete opts.required;\n    }\n\n    const c = new Decoder(opts);\n    let v = NOT_FOUND;\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val);\n        c.close();\n      });\n      c.once('error', er => {\n        if (v !== NOT_FOUND) {\n          er.value = v;\n        }\n\n        v = ERROR;\n        c.close();\n        return reject(er);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'));\n            } else {\n              return resolve(v);\n            }\n\n          case ERROR:\n            return void 0;\n\n          default:\n            return resolve(v);\n        }\n      });\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb);\n    }\n\n    c.end(input, encod);\n    return p;\n  }\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {(string|Buffer)} input - the input to parse\n   * @param {(string|Object)} options - Decoding options.\n   *   If string, the input encoding.\n   * @param {decodeAllCallback} cb callback\n   * @returns {Promise<Array>} even if callback is specified\n   */\n\n\n  static decodeAll(input, options, cb) {\n    let opts = {};\n    let encod = 'hex';\n\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        encod = utils.guessEncoding(input);\n        break;\n\n      case 'string':\n        encod = options;\n        break;\n\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n    }\n\n    const c = new Decoder(opts);\n    const vals = [];\n    c.on('data', val => {\n      return vals.push(Decoder.nullcheck(val));\n    });\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject);\n      c.on('end', () => resolve(vals));\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb);\n    }\n\n    c.end(input, encod);\n    return p;\n  }\n  /**\n   * Stop processing\n   */\n\n\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n\n    while (true) {\n      if (this.max_depth >= 0 && depth > this.max_depth) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded');\n      }\n\n      const octet = (yield 1)[0];\n\n      if (!this.running) {\n        throw new Error('Unexpected data: 0x' + octet.toString(16));\n      }\n\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = parent != null ? parent[MAJOR] : undefined;\n      const parent_length = parent != null ? parent.length : undefined;\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          val = (yield 1)[0];\n          break;\n\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << ai - 24;\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n          const buf = yield numbytes;\n          val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);\n          break;\n\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error('Additional info not implemented: ' + ai);\n\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`);\n          }\n\n          val = -1;\n          break;\n\n        default:\n          val = ai;\n      }\n\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break;\n\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BN.NEG_MAX;\n          } else if (val instanceof bignumber) {\n            val = BN.MINUS_ONE.minus(val);\n          } else {\n            val = -1 - val;\n          }\n\n          break;\n\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = mt === MT.BYTE_STRING ? Buffer.allocUnsafe(0) : '';\n              break;\n\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              }\n\n          }\n\n          break;\n\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = mt === MT.MAP ? {} : [];\n              break;\n\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n\n          break;\n\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if (ai === NUMBYTES.ONE && val < 32) {\n              throw new Error(`Invalid two-byte encoding of simple value ${val}`);\n            }\n\n            const hasParent = parent != null;\n            val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n\n      }\n\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1;\n            break;\n\n          case !Array.isArray(parent):\n            parent.push(val);\n            break;\n\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR];\n\n            if (pm != null && pm !== mt) {\n              this.running = false;\n              throw new Error('Invalid major type in indefinite encoding');\n            }\n\n            parent.write(val);\n        }\n\n        if (--parent[COUNT] !== 0) {\n          again = true;\n          break;\n        }\n\n        --depth;\n        delete parent[COUNT];\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n\n            case MT.MAP:\n              let allstrings = true;\n\n              if (parent.length % 2 !== 0) {\n                throw new Error('Invalid map length: ' + parent.length);\n              }\n\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false;\n                  break;\n                }\n              }\n\n              if (allstrings) {\n                val = {};\n\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1];\n                }\n              } else {\n                val = new Map();\n\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1]);\n                }\n              }\n\n              break;\n\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1]);\n              val = t.convert(this.tags);\n              break;\n          }\n        } else if (parent instanceof NoFilter) {\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice();\n              break;\n\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8');\n              break;\n          }\n        }\n\n        this.emit('stop', parent[MAJOR]);\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n\n      if (!again) {\n        return val;\n      }\n    }\n  }\n\n}\n\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":{"version":3,"names":["stream","require","BinaryParseStream","Tagged","Simple","utils","bignumber","BigNumber","NoFilter","constants","MT","NUMBYTES","SIMPLE","SYMS","BI","bigIntize","BN","COUNT","Symbol","PENDING_KEY","MAJOR","ERROR","NOT_FOUND","parentArray","parent","typ","count","a","PARENT","parentBufferStream","b","_tag_2","v","bufferToBigInt","_tag_3","MINUS_ONE","Decoder","constructor","options","tags","max_depth","bigI","hasBigInt","bigint","running","nullcheck","val","NULL","UNDEFINED","undefined","Error","decodeFirstSync","input","encoding","opts","encod","extend","c","s","Readable","guessEncoding","parser","_parse","state","next","done","read","value","length","nextByte","unshift","er","toString","decodeAllSync","res","push","decodeFirst","cb","required","p","Promise","resolve","reject","on","close","once","then","end","decodeAll","vals","__fresh","depth","octet","mt","ai","parent_major","parent_length","ONE","emit","TWO","FOUR","EIGHT","numbytes","buf","SIMPLE_FLOAT","parseCBORint","INDEFINITE","POS_INT","NEG_INT","TAG","Number","MAX_SAFE_INTEGER","NEG_MAX","minus","BYTE_STRING","UTF8_STRING","Buffer","allocUnsafe","STREAM","utf8","ARRAY","MAP","hasParent","decode","parseCBORfloat","again","BREAK","Array","isArray","pm","write","allstrings","i","len","Map","set","t","convert","slice","old","module","exports"],"sources":["/Users/soheilvafaei/Documents/project/web/web3/ex7/node_modules/cbor/lib/decoder.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst BinaryParseStream = require('../vendor/binary-parse-stream')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\nconst constants = require('./constants')\n// Do not fix this if you want to support node v4\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\nconst BI = utils.bigIntize(constants.BI)\nconst BN = constants.BN\nconst COUNT = Symbol('count')\nconst PENDING_KEY = Symbol('pending_key')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\n/**\n * @param {Buffer} v\n * @private\n */\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v)\n}\n\n/**\n * @param {BigInt} v\n * @private\n */\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v)\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\nclass Decoder extends BinaryParseStream {\n\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  constructor(options) {\n    options = options || {}\n    const tags = options.tags\n    delete options.tags\n    const max_depth = (options.max_depth != null) ? options.max_depth : -1\n    delete options.max_depth\n    const bigI = utils.hasBigInt ? (!!options.bigint) : false\n    delete options.bigint\n    super(options)\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    if (bigI) {\n      if (this.tags == null) {\n        this.tags = {}\n      }\n      if (this.tags[2] == null) {\n        this.tags[2] = _tag_2\n      }\n      if (this.tags[3] == null) {\n        this.tags[3] = _tag_3\n      }\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      case NOT_FOUND:\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * @typedef DecodeOptions\n   * @property {string} [encoding='hex'] - The encoding of the input.\n   *   Ignored if input is a Buffer.\n   */\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw an\n   * exception if the input is not valid CBOR.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options\n   * @returns {any} - the decoded value\n   */\n  static decodeFirstSync(input, options) {\n    options = options || { encoding: 'hex' }\n    let opts = {}\n    let encod\n    switch (typeof options) {\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = opts.encoding\n        delete opts.encoding\n        break\n    }\n    const c = new Decoder(opts)\n    const s = (input instanceof stream.Readable) ? input : new NoFilter(\n      input,\n      encod != null ? encod : utils.guessEncoding(input))\n\n    // for/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse()\n    let state = parser.next()\n    while (!state.done) {\n      const b = s.read(state.value)\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      state = parser.next(b)\n    }\n    const val = Decoder.nullcheck(state.value)\n    if (s.length > 0) {\n      const nextByte = s.read(1)\n      s.unshift(nextByte)\n      const er = new Error(\n        'Unexpected data: 0x' + nextByte[0].toString(16))\n      er.value = val\n      throw er\n    }\n    return val\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options or encoding string\n   * @returns {Array} - Array of all found items\n   */\n  static decodeAllSync(input, options) {\n    options = options || { encoding: 'hex' }\n    let opts = {}\n    let encod\n    switch (typeof options) {\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = opts.encoding\n        delete opts.encoding\n    }\n    const c = new Decoder(opts)\n    const s = (input instanceof stream.Readable) ? input : new NoFilter(\n      input,\n      encod != null ? encod : utils.guessEncoding(input))\n    const res = []\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n      while (!state.done) {\n        const b = s.read(state.value)\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * @callback decodeCallback\n   * @param {Error} [error] - if one was generated\n   * @param {any} [value] - the decoded value\n   */\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are more\n   * bytes left over at the end, and optionally if there were no valid CBOR\n   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n   * if no data was found and the `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer} input - the input to parse\n   * @param {DecodeOptions|decodeCallback|string} [options] - options\n   * @param {decodeCallback} [cb] callback\n   * @returns {Promise<any>} returned even if callback is specified\n   */\n  static decodeFirst(input, options, cb) {\n    let opts = {}\n    let required = false\n    let encod = 'hex'\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        encod = utils.guessEncoding(input)\n        break\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n        required = (opts.required != null) ? opts.required : false\n        delete opts.required\n    }\n    const c = new Decoder(opts)\n    let v = NOT_FOUND\n    const p = new Promise((resolve, reject) => {\n      c.on('data', (val) => {\n        v = Decoder.nullcheck(val)\n        c.close()\n      })\n      c.once('error', (er) => {\n        if (v !== NOT_FOUND) {\n          er.value = v\n        }\n        v = ERROR\n        c.close()\n        return reject(er)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'))\n            } else {\n              return resolve(v)\n            }\n          case ERROR:\n            return void 0\n          default:\n            return resolve(v)\n        }\n      })\n    })\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb)\n    }\n    c.end(input, encod)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {(string|Buffer)} input - the input to parse\n   * @param {(string|Object)} options - Decoding options.\n   *   If string, the input encoding.\n   * @param {decodeAllCallback} cb callback\n   * @returns {Promise<Array>} even if callback is specified\n   */\n  static decodeAll(input, options, cb) {\n    let opts = {}\n    let encod = 'hex'\n    switch (typeof options) {\n      case 'function':\n        cb = options\n        encod = utils.guessEncoding(input)\n        break\n      case 'string':\n        encod = options\n        break\n      case 'object':\n        opts = utils.extend({}, options)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n    }\n    const c = new Decoder(opts)\n    const vals = []\n    c.on('data', (val) => {\n      return vals.push(Decoder.nullcheck(val))\n    })\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject)\n      c.on('end', () => resolve(vals))\n    })\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb)\n    }\n    c.end(input, encod)\n    return p\n  }\n\n  /**\n   * Stop processing\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded')\n      }\n      const octet = (yield 1)[0]\n      if (!this.running) {\n        throw new Error('Unexpected data: 0x' + (octet.toString(16)))\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent != null) ? parent[MAJOR] : undefined\n      const parent_length = (parent != null) ? parent.length : undefined\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          val = (yield 1)[0]\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << (ai - 24)\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ? buf : utils.parseCBORint(ai, buf)\n          break\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error('Additional info not implemented: ' + ai)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BN.NEG_MAX\n          } else if (val instanceof bignumber) {\n            val = BN.MINUS_ONE.minus(val)\n          } else {\n            val = -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = (mt === MT.BYTE_STRING) ? Buffer.allocUnsafe(0) : ''\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = (mt === MT.MAP) ? {} : []\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0))\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1\n            break\n          case !Array.isArray(parent):\n            parent.push(val)\n            break\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR]\n            if ((pm != null) && (pm !== mt)) {\n              this.running = false\n              throw new Error('Invalid major type in indefinite encoding')\n            }\n            parent.write(val)\n        }\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP:\n              let allstrings = true\n              if ((parent.length % 2) !== 0) {\n                throw new Error('Invalid map length: ' + parent.length)\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1])\n              val = t.convert(this.tags)\n              break\n          }\n        } else if (parent instanceof NoFilter) {\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n        this.emit('stop', parent[MAJOR])\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}