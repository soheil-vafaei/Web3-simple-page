{"ast":null,"code":"const debug = require(\"debug\")(\"contract:manual-send\");\n\nconst ethers = require(\"ethers\");\n\nconst Utils = require(\"./utils\");\n\nconst {\n  formatters\n} = require(\"web3-core-helpers\"); //used for reproducing web3's behavior\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\n\n\nasync function sendTransactionManual(web3, params, promiEvent) {\n  debug(\"executing manually!\"); //set up ethers provider\n\n  const ethersProvider = new ethers.providers.Web3Provider(web3.currentProvider); //let's clone params and set it up properly\n\n  const {\n    transaction,\n    from\n  } = setUpParameters(params, web3); //now: if the from address is in the wallet, web3 will sign the transaction before\n  //sending, so we have to account for that\n\n  const account = web3.eth.accounts.wallet[from];\n  const ethersSigner = account ? new ethers.Wallet(account.privateKey, ethersProvider) : ethersProvider.getSigner(from);\n  debug(\"got signer\");\n  let txHash, receipt, ethersResponse;\n\n  try {\n    //note: the following code won't work with ethers v5.\n    //wth ethers v5, in the getSigner() case, you'll need to\n    //use sendUncheckedTransaction instead of sendTransaction.\n    //I don't know why.\n    ethersResponse = await ethersSigner.sendTransaction(transaction);\n    txHash = ethersResponse.hash;\n    receipt = await ethersProvider.waitForTransaction(txHash);\n    debug(\"no error\");\n  } catch (error) {\n    ({\n      txHash,\n      receipt\n    } = handleError(error));\n\n    if (!receipt) {\n      receipt = await ethersProvider.waitForTransaction(txHash);\n    }\n  }\n\n  debug(\"txHash: %s\", txHash);\n  receipt = translateReceipt(receipt);\n  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n\n  return await handleResult(receipt, transaction.to == null);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n\n  if (error.data && error.data.hash) {\n    //ganache v7.x\n    return {\n      txHash: error.data.hash\n    };\n  } else if (error.data && Object.keys(error.data).length === 3) {\n    //ganache v2.x\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(key => key !== \"stack\" && key !== \"name\");\n    return {\n      txHash: transactionHash\n    };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nasync function handleResult(receipt, isDeployment) {\n  const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n\n  if (receipt.status) {\n    if (isDeployment) {\n      //in the deployment case, web3 might error even when technically successful @_@\n      if ((await web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n        throw new Error(deploymentFailedMessage);\n      }\n    }\n\n    return receipt;\n  } else {\n    //otherwise: we have to mimic web3's errors @_@\n    if (isDeployment) {\n      //deployment case\n      throw new Error(deploymentFailedMessage);\n    }\n\n    throw new Error(\"Transaction has been reverted by the EVM:\" + \"\\n\" + JSON.stringify(receipt));\n  }\n}\n\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from = transaction.from != undefined ? transaction.from : web3.eth.defaultAccount; //now let's have web3 check our inputs\n\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas; //also, it insists \"from\" be kept separate\n\n  const {\n    from\n  } = transaction;\n  delete transaction.from;\n  return {\n    transaction,\n    from\n  };\n} //translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\n\n\nfunction translateReceipt(receipt) {\n  return Object.assign({}, ...Object.entries(receipt).map(_ref => {\n    let [key, value] = _ref;\n    return {\n      [key]: Utils.is_big_number(value) ? value.toNumber() : value\n    };\n  }));\n}\n\nmodule.exports = {\n  sendTransactionManual\n};","map":{"version":3,"names":["debug","require","ethers","Utils","formatters","sendTransactionManual","web3","params","promiEvent","ethersProvider","providers","Web3Provider","currentProvider","transaction","from","setUpParameters","account","eth","accounts","wallet","ethersSigner","Wallet","privateKey","getSigner","txHash","receipt","ethersResponse","sendTransaction","hash","waitForTransaction","error","handleError","translateReceipt","setTransactionHash","handleResult","to","data","Object","keys","length","transactionHash","find","key","isDeployment","deploymentFailedMessage","status","getCode","contractAddress","Error","JSON","stringify","assign","undefined","defaultAccount","inputTransactionFormatter","gasLimit","gas","entries","map","value","is_big_number","toNumber","module","exports"],"sources":["/Users/soheilvafaei/Documents/project/web/resume/ex7/node_modules/@truffle/contract/lib/manual-send.js"],"sourcesContent":["const debug = require(\"debug\")(\"contract:manual-send\");\nconst ethers = require(\"ethers\");\nconst Utils = require (\"./utils\");\nconst { formatters } = require(\"web3-core-helpers\"); //used for reproducing web3's behavior\n\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\nasync function sendTransactionManual(web3, params, promiEvent) {\n  debug(\"executing manually!\");\n  //set up ethers provider\n  const ethersProvider = new ethers.providers.Web3Provider(\n    web3.currentProvider\n  );\n  //let's clone params and set it up properly\n  const { transaction, from } = setUpParameters(params, web3);\n  //now: if the from address is in the wallet, web3 will sign the transaction before\n  //sending, so we have to account for that\n  const account = web3.eth.accounts.wallet[from];\n  const ethersSigner = account\n    ? new ethers.Wallet(account.privateKey, ethersProvider)\n    : ethersProvider.getSigner(from);\n  debug(\"got signer\");\n  let txHash, receipt, ethersResponse;\n  try {\n    //note: the following code won't work with ethers v5.\n    //wth ethers v5, in the getSigner() case, you'll need to\n    //use sendUncheckedTransaction instead of sendTransaction.\n    //I don't know why.\n    ethersResponse = await ethersSigner.sendTransaction(transaction);\n    txHash = ethersResponse.hash;\n    receipt = await ethersProvider.waitForTransaction(txHash);\n    debug(\"no error\");\n  } catch (error) {\n    ({ txHash, receipt } = handleError(error));\n    if (!receipt) {\n      receipt = await ethersProvider.waitForTransaction(txHash);\n    }\n  }\n  debug(\"txHash: %s\", txHash);\n  receipt = translateReceipt(receipt);\n  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n  return await handleResult(receipt, transaction.to == null);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n  if (error.data && error.data.hash) {\n    //ganache v7.x\n    return { txHash: error.data.hash };\n  } else if (error.data && Object.keys(error.data).length === 3) {\n    //ganache v2.x\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(\n      key => key !== \"stack\" && key !== \"name\"\n    );\n    return { txHash: transactionHash };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nasync function handleResult(receipt, isDeployment) {\n  const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n  if (receipt.status) {\n    if (isDeployment) {\n      //in the deployment case, web3 might error even when technically successful @_@\n      if ((await web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n        throw new Error(deploymentFailedMessage);\n      }\n    }\n    return receipt;\n  } else {\n    //otherwise: we have to mimic web3's errors @_@\n    if (isDeployment) {\n      //deployment case\n      throw new Error(deploymentFailedMessage);\n    }\n    throw new Error(\n      \"Transaction has been reverted by the EVM:\" +\n        \"\\n\" +\n        JSON.stringify(receipt)\n    );\n  }\n}\n\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from =\n    transaction.from != undefined\n      ? transaction.from\n      : web3.eth.defaultAccount;\n  //now let's have web3 check our inputs\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas;\n  //also, it insists \"from\" be kept separate\n  const { from } = transaction;\n  delete transaction.from;\n  return { transaction, from }\n}\n\n//translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\nfunction translateReceipt(receipt) {\n  return Object.assign({},\n    ...Object.entries(receipt).map(([key, value]) => ({\n      [key]: Utils.is_big_number(value)\n        ? value.toNumber()\n        : value\n    }))\n  );\n}\n\nmodule.exports = {\n  sendTransactionManual\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}