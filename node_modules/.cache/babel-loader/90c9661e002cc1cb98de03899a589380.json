{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBytes = exports.readCode = void 0;\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* readCode(pointer, state) {\n  let code = state.code;\n\n  if (!code) {\n    const address = Evm.Utils.toAddress(state.specials.this);\n    code = yield {\n      type: \"code\",\n      address\n    };\n\n    if (code === null) {\n      //check for null as a way to deliberately indicate an error\n      throw new errors_1.DecodingError({\n        kind: \"CodeNotSuppliedError\",\n        address\n      });\n    }\n  }\n\n  return readBytes(pointer, Object.assign(Object.assign({}, state), {\n    code\n  }));\n}\n\nexports.readCode = readCode;\n\nfunction readBytes(pointer, state) {\n  let sourceBytes = state[pointer.location];\n  const {\n    start: offset,\n    length\n  } = pointer;\n\n  if (!Number.isSafeInteger(offset + length)) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorBytes\",\n      location: pointer.location,\n      start: offset,\n      length\n    });\n  } // grab `length` bytes no matter what, here fill this array\n\n\n  var bytes = new Uint8Array(length);\n  bytes.fill(0); //fill it wil zeroes to start\n  //if the start is beyond the end of the source, just return those 0s\n\n  if (offset >= sourceBytes.length) {\n    return bytes;\n  } // if we're reading past the end of the source, truncate the length to read\n\n\n  let excess = offset + length - sourceBytes.length;\n  let readLength;\n\n  if (excess > 0) {\n    readLength = sourceBytes.length - offset;\n  } else {\n    readLength = length;\n  } //get the (truncated) bytes\n\n\n  let existing = new Uint8Array(sourceBytes.buffer, offset, readLength); //copy it into our buffer\n\n  bytes.set(existing);\n  return bytes;\n}\n\nexports.readBytes = readBytes;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA;;AAGA,UAAiBA,QAAjB,CACEC,OADF,EAEEC,KAFF,EAEqB;EAEnB,IAAIC,IAAI,GAAGD,KAAK,CAACC,IAAjB;;EACA,IAAI,CAACA,IAAL,EAAW;IACT,MAAMC,OAAO,GAAGC,GAAG,CAACC,KAAJ,CAAUC,SAAV,CAAoBL,KAAK,CAACM,QAAN,CAAeC,IAAnC,CAAhB;IACAN,IAAI,GAAG,MAAM;MACXO,IAAI,EAAE,MADK;MAEXN;IAFW,CAAb;;IAIA,IAAID,IAAI,KAAK,IAAb,EAAmB;MACjB;MACA,MAAM,IAAIQ,sBAAJ,CAAkB;QACtBC,IAAI,EAAE,sBADgB;QAEtBR;MAFsB,CAAlB,CAAN;IAID;EACF;;EACD,OAAOS,SAAS,CAACZ,OAAD,EAAQa,gCAAOZ,KAAP,GAAY;IAAEC;EAAF,CAAZ,CAAR,CAAhB;AACD;;AApBDY;;AAsBA,SAAgBF,SAAhB,CACEZ,OADF,EAEEC,KAFF,EAEqB;EAEnB,IAAIc,WAAW,GAAGd,KAAK,CAACD,OAAO,CAACgB,QAAT,CAAvB;EAEA,MAAM;IAAEC,KAAK,EAAEC,MAAT;IAAiBC;EAAjB,IAA4BnB,OAAlC;;EACA,IAAI,CAACoB,MAAM,CAACC,aAAP,CAAqBH,MAAM,GAAGC,MAA9B,CAAL,EAA4C;IAC1C,MAAM,IAAIT,sBAAJ,CAAkB;MACtBC,IAAI,EAAE,gBADgB;MAEtBK,QAAQ,EAAEhB,OAAO,CAACgB,QAFI;MAGtBC,KAAK,EAAEC,MAHe;MAItBC;IAJsB,CAAlB,CAAN;EAMD,CAZkB,CAcnB;;;EACA,IAAIG,KAAK,GAAG,IAAIC,UAAJ,CAAeJ,MAAf,CAAZ;EACAG,KAAK,CAACE,IAAN,CAAW,CAAX,EAhBmB,CAgBJ;EAEf;;EACA,IAAIN,MAAM,IAAIH,WAAW,CAACI,MAA1B,EAAkC;IAChC,OAAOG,KAAP;EACD,CArBkB,CAuBnB;;;EACA,IAAIG,MAAM,GAAGP,MAAM,GAAGC,MAAT,GAAkBJ,WAAW,CAACI,MAA3C;EACA,IAAIO,UAAJ;;EACA,IAAID,MAAM,GAAG,CAAb,EAAgB;IACdC,UAAU,GAAGX,WAAW,CAACI,MAAZ,GAAqBD,MAAlC;EACD,CAFD,MAEO;IACLQ,UAAU,GAAGP,MAAb;EACD,CA9BkB,CAgCnB;;;EACA,IAAIQ,QAAQ,GAAG,IAAIJ,UAAJ,CAAeR,WAAW,CAACa,MAA3B,EAAmCV,MAAnC,EAA2CQ,UAA3C,CAAf,CAjCmB,CAmCnB;;EACAJ,KAAK,CAACO,GAAN,CAAUF,QAAV;EAEA,OAAOL,KAAP;AACD;;AAzCDR","names":["readCode","pointer","state","code","address","Evm","Utils","toAddress","specials","this","type","errors_1","kind","readBytes","Object","exports","sourceBytes","location","start","offset","length","Number","isSafeInteger","bytes","Uint8Array","fill","excess","readLength","existing","buffer","set"],"sourceRoot":"","sources":["../../../../lib/bytes/read/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}