{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBasic = void 0;\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Evm = __importStar(require(\"../../evm\")); //UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n\n/**\n * Handles encoding of basic types; yes the input type is broader than\n * it should be but it's hard to fix this without causing other problems,\n * sorry!\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeBasic(input) {\n  let bytes;\n\n  switch (input.type.typeClass) {\n    case \"userDefinedValueType\":\n      return encodeBasic(input.value);\n\n    case \"uint\":\n    case \"int\":\n      return Conversion.toBytes(input.value.asBN, Evm.Utils.WORD_SIZE);\n\n    case \"enum\":\n      return Conversion.toBytes(input.value.numericAsBN, Evm.Utils.WORD_SIZE);\n\n    case \"bool\":\n      {\n        bytes = new Uint8Array(Evm.Utils.WORD_SIZE); //is initialized to zeroes\n\n        if (input.value.asBoolean) {\n          bytes[Evm.Utils.WORD_SIZE - 1] = 1;\n        }\n\n        return bytes;\n      }\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        //deliberately not handling dynamic case!\n        case \"static\":\n          bytes = Conversion.toBytes(input.value.asHex);\n          let padded = new Uint8Array(Evm.Utils.WORD_SIZE); //initialized to zeroes\n\n          padded.set(bytes);\n          return padded;\n      }\n\n    case \"address\":\n      return Conversion.toBytes(input.value.asAddress, Evm.Utils.WORD_SIZE);\n\n    case \"contract\":\n      return Conversion.toBytes(input.value.address, Evm.Utils.WORD_SIZE);\n\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          //for our purposes here, we will NOT count internal functions as a\n          //basic type!  so no handling of internal case\n          case \"external\":\n            let coercedInput = input;\n            let encoded = new Uint8Array(Evm.Utils.WORD_SIZE); //starts filled w/0s\n\n            let addressBytes = Conversion.toBytes(coercedInput.value.contract.address); //should already be correct length\n\n            let selectorBytes = Conversion.toBytes(coercedInput.value.selector); //should already be correct length\n\n            encoded.set(addressBytes);\n            encoded.set(selectorBytes, Evm.Utils.ADDRESS_SIZE); //set it after the address\n\n            return encoded;\n        }\n\n        break; //to satisfy TS\n      }\n\n    case \"fixed\":\n    case \"ufixed\":\n      let bigValue = input.value.asBig;\n      let shiftedValue = Conversion.shiftBigUp(bigValue, input.type.places);\n      return Conversion.toBytes(shiftedValue, Evm.Utils.WORD_SIZE);\n  }\n}\n\nexports.encodeBasic = encodeBasic;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AACA,+C,CAEA;AACA;AACA;;AAEA;;;;;;;;AAMA,SAAgBA,WAAhB,CAA4BC,KAA5B,EAAsD;EACpD,IAAIC,KAAJ;;EACA,QAAQD,KAAK,CAACE,IAAN,CAAWC,SAAnB;IACE,KAAK,sBAAL;MACE,OAAOJ,WAAW,CAA2CC,KAAM,CAACI,KAAlD,CAAlB;;IACF,KAAK,MAAL;IACA,KAAK,KAAL;MACE,OAAOC,UAAU,CAACC,OAAX,CAC8CN,KAAM,CAACI,KAAP,CAAaG,IAD3D,EAELC,GAAG,CAACC,KAAJ,CAAUC,SAFL,CAAP;;IAIF,KAAK,MAAL;MACE,OAAOL,UAAU,CAACC,OAAX,CACqBN,KAAM,CAACI,KAAP,CAAaO,WADlC,EAELH,GAAG,CAACC,KAAJ,CAAUC,SAFL,CAAP;;IAIF,KAAK,MAAL;MAAa;QACXT,KAAK,GAAG,IAAIW,UAAJ,CAAeJ,GAAG,CAACC,KAAJ,CAAUC,SAAzB,CAAR,CADW,CACkC;;QAC7C,IAA8BV,KAAM,CAACI,KAAP,CAAaS,SAA3C,EAAsD;UACpDZ,KAAK,CAACO,GAAG,CAACC,KAAJ,CAAUC,SAAV,GAAsB,CAAvB,CAAL,GAAiC,CAAjC;QACD;;QACD,OAAOT,KAAP;MACD;;IACD,KAAK,OAAL;MACE,QAAQD,KAAK,CAACE,IAAN,CAAWY,IAAnB;QACE;QACA,KAAK,QAAL;UACEb,KAAK,GAAGI,UAAU,CAACC,OAAX,CACqBN,KAAM,CAACI,KAAP,CAAaW,KADlC,CAAR;UAGA,IAAIC,MAAM,GAAG,IAAIJ,UAAJ,CAAeJ,GAAG,CAACC,KAAJ,CAAUC,SAAzB,CAAb,CAJF,CAIoD;;UAClDM,MAAM,CAACC,GAAP,CAAWhB,KAAX;UACA,OAAOe,MAAP;MARJ;;IAUF,KAAK,SAAL;MACE,OAAOX,UAAU,CAACC,OAAX,CACwBN,KAAM,CAACI,KAAP,CAAac,SADrC,EAELV,GAAG,CAACC,KAAJ,CAAUC,SAFL,CAAP;;IAIF,KAAK,UAAL;MACE,OAAOL,UAAU,CAACC,OAAX,CACyBN,KAAM,CAACI,KAAP,CAAae,OADtC,EAELX,GAAG,CAACC,KAAJ,CAAUC,SAFL,CAAP;;IAIF,KAAK,UAAL;MAAiB;QACf,QAAQV,KAAK,CAACE,IAAN,CAAWkB,UAAnB;UACE;UACA;UACA,KAAK,UAAL;YACE,IAAIC,YAAY,GAEfrB,KAFD;YAGA,IAAIsB,OAAO,GAAG,IAAIV,UAAJ,CAAeJ,GAAG,CAACC,KAAJ,CAAUC,SAAzB,CAAd,CAJF,CAIqD;;YACnD,IAAIa,YAAY,GAAGlB,UAAU,CAACC,OAAX,CACjBe,YAAY,CAACjB,KAAb,CAAmBoB,QAAnB,CAA4BL,OADX,CAAnB,CALF,CAOK;;YACH,IAAIM,aAAa,GAAGpB,UAAU,CAACC,OAAX,CAAmBe,YAAY,CAACjB,KAAb,CAAmBsB,QAAtC,CAApB,CARF,CAQuE;;YACrEJ,OAAO,CAACL,GAAR,CAAYM,YAAZ;YACAD,OAAO,CAACL,GAAR,CAAYQ,aAAZ,EAA2BjB,GAAG,CAACC,KAAJ,CAAUkB,YAArC,EAVF,CAUsD;;YACpD,OAAOL,OAAP;QAdJ;;QAgBA,MAjBe,CAiBR;MACR;;IACD,KAAK,OAAL;IACA,KAAK,QAAL;MACE,IAAIM,QAAQ,GACV5B,KADoE,CAEnEI,KAFmE,CAE7DyB,KAFT;MAGA,IAAIC,YAAY,GAAGzB,UAAU,CAAC0B,UAAX,CAAsBH,QAAtB,EAAgC5B,KAAK,CAACE,IAAN,CAAW8B,MAA3C,CAAnB;MACA,OAAO3B,UAAU,CAACC,OAAX,CAAmBwB,YAAnB,EAAiCtB,GAAG,CAACC,KAAJ,CAAUC,SAA3C,CAAP;EAnEJ;AAqED;;AAvEDuB","names":["encodeBasic","input","bytes","type","typeClass","value","Conversion","toBytes","asBN","Evm","Utils","WORD_SIZE","numericAsBN","Uint8Array","asBoolean","kind","asHex","padded","set","asAddress","address","visibility","coercedInput","encoded","addressBytes","contract","selectorBytes","selector","ADDRESS_SIZE","bigValue","asBig","shiftedValue","shiftBigUp","places","exports"],"sourceRoot":"","sources":["../../../../lib/basic/encode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}