{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:memory:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeMemory(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (Format.Types.isReferenceType(dataType)) {\n    if ((0, allocate_1.isSkippedInMemoryStructs)(dataType)) {\n      //special case; these types are always empty in memory\n      return decodeMemorySkippedType(dataType);\n    } else {\n      return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);\n    }\n  } else {\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n  }\n}\n\nexports.decodeMemory = decodeMemory;\n\nfunction decodeMemorySkippedType(dataType) {\n  switch (dataType.typeClass) {\n    case \"mapping\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n\n    case \"array\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n    //other cases should not arise!\n  }\n}\n\nfunction* decodeMemoryReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    state\n  } = info;\n  const memoryVisited = options.memoryVisited || [];\n  debug(\"pointer %o\", pointer);\n  let rawValue;\n\n  try {\n    rawValue = yield* (0, read_1.default)(pointer, state);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error);\n  }\n\n  let startPositionAsBN = Conversion.toBN(rawValue);\n  let startPosition;\n\n  try {\n    startPosition = startPositionAsBN.toNumber();\n  } catch (_a) {\n    return {\n      //again with the TS failures...\n      type: dataType,\n      kind: \"error\",\n      error: {\n        kind: \"OverlargePointersNotImplementedError\",\n        pointerAsBN: startPositionAsBN\n      }\n    };\n  } //startPosition may get modified later, so let's save the current\n  //value for circularity detection purposes\n\n\n  const objectPosition = startPosition;\n  let rawLength;\n  let lengthAsBN;\n  let length;\n  let seenPreviously;\n\n  switch (dataType.typeClass) {\n    case \"bytes\":\n    case \"string\":\n      //initial word contains length\n      try {\n        rawLength = yield* (0, read_1.default)({\n          location: \"memory\",\n          start: startPosition,\n          length: Evm.Utils.WORD_SIZE\n        }, state);\n      } catch (error) {\n        return (0, errors_1.handleDecodingError)(dataType, error);\n      }\n\n      lengthAsBN = Conversion.toBN(rawLength);\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_b) {\n        return {\n          //again with the TS failures...\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      }\n\n      let childPointer = {\n        location: \"memory\",\n        start: startPosition + Evm.Utils.WORD_SIZE,\n        length\n      };\n      return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);\n\n    case \"array\":\n      {\n        //first: circularity check!\n        seenPreviously = memoryVisited.indexOf(objectPosition);\n\n        if (seenPreviously !== -1) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          };\n        } //otherwise, decode as normal\n\n\n        if (dataType.kind === \"dynamic\") {\n          //initial word contains array length\n          try {\n            rawLength = yield* (0, read_1.default)({\n              location: \"memory\",\n              start: startPosition,\n              length: Evm.Utils.WORD_SIZE\n            }, state);\n          } catch (error) {\n            return (0, errors_1.handleDecodingError)(dataType, error);\n          }\n\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n        } else {\n          lengthAsBN = dataType.length;\n        }\n\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_c) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n\n        let memoryNowVisited = [objectPosition, ...memoryVisited];\n        let baseType = dataType.baseType;\n        let decodedChildren = [];\n\n        for (let index = 0; index < length; index++) {\n          decodedChildren.push(yield* decodeMemory(baseType, {\n            location: \"memory\",\n            start: startPosition + index * Evm.Utils.WORD_SIZE,\n            length: Evm.Utils.WORD_SIZE\n          }, info, {\n            memoryVisited: memoryNowVisited\n          }));\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      }\n\n    case \"struct\":\n      {\n        //first: circularity check!\n        seenPreviously = memoryVisited.indexOf(objectPosition);\n\n        if (seenPreviously !== -1) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          };\n        } //otherwise, decode as normal\n\n\n        const {\n          allocations: {\n            memory: allocations\n          }\n        } = info;\n        const typeId = dataType.id;\n        const structAllocation = allocations[typeId];\n\n        if (!structAllocation) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          };\n        }\n\n        debug(\"structAllocation %O\", structAllocation);\n        let memoryNowVisited = [objectPosition, ...memoryVisited];\n        let decodedMembers = [];\n\n        for (let index = 0; index < structAllocation.members.length; index++) {\n          const memberAllocation = structAllocation.members[index];\n          const memberPointer = memberAllocation.pointer;\n          const childPointer = {\n            location: \"memory\",\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length //always equals WORD_SIZE or 0\n\n          };\n          let memberName = memberAllocation.name;\n          let memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n          decodedMembers.push({\n            name: memberName,\n            value: yield* decodeMemory(memberType, childPointer, info, {\n              memoryVisited: memoryNowVisited\n            })\n          });\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedMembers\n        };\n      }\n  }\n}\n\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;","map":{"version":3,"mappings":"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","names":["debug","decodeMemory","dataType","pointer","info","options","Format","Types","isReferenceType","decodeMemorySkippedType","decodeMemoryReferenceByAddress","Basic","Decode","decodeBasic","exports","typeClass","type","kind","value","state","memoryVisited","rawValue","error","startPositionAsBN","Conversion","toBN","startPosition","toNumber","pointerAsBN","objectPosition","rawLength","lengthAsBN","length","seenPreviously","location","start","Evm","Utils","WORD_SIZE","childPointer","Bytes","decodeBytes","indexOf","reference","memoryNowVisited","baseType","decodedChildren","index","push","allocations","memory","typeId","id","structAllocation","decodedMembers","members","memberAllocation","memberPointer","memberName","name","memberType","specifyLocation"],"sourceRoot":"","sources":["../../../../lib/memory/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}