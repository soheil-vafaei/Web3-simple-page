{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:abi-data:allocate\");\nexports.Utils = __importStar(require(\"./utils\"));\n\nconst Import = __importStar(require(\"../import\"));\n\nconst AbiDataUtils = __importStar(require(\"../utils\"));\n\nconst web3_utils_1 = __importDefault(require(\"web3-utils\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst Common = __importStar(require(\"../../common\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Ast = __importStar(require(\"../../ast\"));\n\nconst import_1 = require(\"../../contexts/import\");\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst partition_1 = __importDefault(require(\"lodash/partition\"));\n\nexports.FallbackOutputAllocation = {\n  kind: \"returnmessage\",\n  selector: new Uint8Array(),\n  allocationMode: \"full\"\n};\n\nfunction getAbiAllocations(userDefinedTypes) {\n  let allocations = {};\n\n  for (const dataType of Object.values(userDefinedTypes)) {\n    if (dataType.typeClass === \"struct\") {\n      try {\n        allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n      } catch (_) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n        //note: a better way of handling this would probably be to *mark* it\n        //as failed rather than throwing an exception as that would lead to less\n        //recomputation, but this is simpler and I don't think the recomputation\n        //should really be a problem\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getAbiAllocations = getAbiAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n} //note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\n\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {\n  let start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let dynamic = false; //note that we will mutate the start argument also!\n  //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n\n  let memberAllocations = [];\n\n  for (const member of members) {\n    let length;\n    let dynamicMember;\n    ({\n      size: length,\n      dynamic: dynamicMember,\n      allocations\n    } = abiSizeAndAllocate(member.type, userDefinedTypes, allocations)); //vomit on illegal types in calldata -- note the short-circuit!\n\n    if (length === undefined) {\n      allocations[parentId] = null;\n      return allocations;\n    }\n\n    let pointer = {\n      location: \"abi\",\n      start,\n      length\n    };\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer\n    });\n    start += length;\n    dynamic = dynamic || dynamicMember;\n  }\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    length: dynamic ? Evm.Utils.WORD_SIZE : start,\n    dynamic\n  };\n  return allocations;\n} //first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\n\n\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n  switch (dataType.typeClass) {\n    case \"bool\":\n    case \"address\":\n    case \"contract\":\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n    case \"enum\":\n    case \"userDefinedValueType\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: false,\n        allocations: existingAllocations\n      };\n\n    case \"string\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: true,\n        allocations: existingAllocations\n      };\n\n    case \"bytes\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: dataType.kind === \"dynamic\",\n        allocations: existingAllocations\n      };\n\n    case \"mapping\":\n      return {\n        allocations: existingAllocations\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            size: Evm.Utils.WORD_SIZE,\n            dynamic: false,\n            allocations: existingAllocations\n          };\n\n        case \"internal\":\n          return {\n            allocations: existingAllocations\n          };\n      }\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: Evm.Utils.WORD_SIZE,\n              dynamic: true,\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            if (dataType.length.isZero()) {\n              //arrays of length 0 are static regardless of base type\n              return {\n                size: 0,\n                dynamic: false,\n                allocations: existingAllocations\n              };\n            }\n\n            const {\n              size: baseSize,\n              dynamic,\n              allocations\n            } = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n            return {\n              //WARNING!  The use of toNumber() here may throw an exception!\n              //I'm judging this OK since if you have arrays that large we have bigger problems :P\n              size: dataType.length.toNumber() * baseSize,\n              dynamic,\n              allocations\n            };\n        }\n      }\n\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id];\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[storedType.id];\n        } //having found our allocation, if it's not null, we can just look up its size and dynamicity\n\n\n        if (allocation !== null) {\n          return {\n            size: allocation.length,\n            dynamic: allocation.dynamic,\n            allocations\n          };\n        } //if it is null, this type doesn't go in the abi\n        else {\n          return {\n            allocations\n          };\n        }\n      }\n\n    case \"tuple\":\n      {\n        //Warning! Yucky wasteful recomputation here!\n        let size = 0;\n        let dynamic = false; //note that we don't just invoke allocateStruct here!\n        //why not? because it has no ID to store the result in!\n        //and we can't use a fake like -1 because there might be a recursive call to it,\n        //and then the results would overwrite each other\n        //I mean, we could do some hashing thing or something, but I think it's easier to just\n        //copy the logic in this one case (sorry)\n\n        for (let member of dataType.memberTypes) {\n          let {\n            size: memberSize,\n            dynamic: memberDynamic\n          } = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations);\n          size += memberSize;\n          dynamic = dynamic || memberDynamic;\n        }\n\n        return {\n          size,\n          dynamic,\n          allocations: existingAllocations\n        };\n      }\n  }\n} //assumes you've already done allocation! don't use if you haven't!\n\n/**\n * @protected\n */\n\n\nfunction abiSizeInfo(dataType, allocations) {\n  let {\n    size,\n    dynamic\n  } = abiSizeAndAllocate(dataType, null, allocations); //the above line should work fine... as long as allocation is already done!\n  //the middle argument, userDefinedTypes, is only needed during allocation\n  //again, this function is only for use if allocation is done, so it's safe to pass null here\n\n  return {\n    size,\n    dynamic\n  };\n}\n\nexports.abiSizeInfo = abiSizeInfo; //allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\n\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n  //first: determine the corresponding function node\n  //(simultaneously: determine the offset)\n  let node = undefined;\n  let inputParametersFull;\n  let outputParametersFull;\n  let inputParametersAbi;\n  let outputParametersAbi;\n  let offset; //refers to INPUT offset; output offset is always 0\n\n  debug(\"allocating calldata and returndata\");\n\n  switch (abiEntry.type) {\n    case \"constructor\":\n      if (!constructorContext) {\n        return undefined;\n      }\n\n      let rawLength = constructorContext.binary.length;\n      offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n      //for a constructor, we only want to search the particular contract\n\n      if (contractNode) {\n        node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a function node, but then it will\n        //return false (well, unless it's a getter node!)\n        abiEntry, functionNode, referenceDeclarations));\n      } //if we can't find it, we'll handle this below\n\n\n      break;\n\n    case \"function\":\n      offset = Evm.Utils.SELECTOR_SIZE; //search through base contracts, from most derived (left) to most base (right)\n\n      if (contractNode) {\n        const linearizedBaseContracts = contractNode.linearizedBaseContracts;\n        debug(\"linearized: %O\", linearizedBaseContracts);\n        node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!\n\n        debug(\"found node: %o\", Boolean(node));\n      }\n\n      break;\n  } //now: get the parameters (both full-mode & ABI)\n\n\n  if (node) {\n    switch (node.nodeType) {\n      case \"FunctionDefinition\":\n        //normal case\n        inputParametersFull = node.parameters.parameters;\n        outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n\n        break;\n\n      case \"VariableDeclaration\":\n        //getter case\n        ({\n          inputs: inputParametersFull,\n          outputs: outputParametersFull\n        } = Ast.Utils.getterParameters(node, referenceDeclarations));\n        break;\n    }\n  } else {\n    inputParametersFull = undefined;\n    outputParametersFull = undefined;\n  }\n\n  inputParametersAbi = abiEntry.inputs;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputParametersAbi = abiEntry.outputs;\n      break;\n\n    case \"constructor\":\n      //we just leave this empty for constructors\n      outputParametersAbi = [];\n      break;\n  } //now: do the allocation!\n\n\n  let {\n    allocation: abiAllocationInput,\n    mode: inputMode\n  } = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset);\n  let {\n    allocation: abiAllocationOutput,\n    mode: outputMode\n  } = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler //note no offset\n  );\n  debug(\"modes: %s in, %s out\", inputMode, outputMode); //finally: transform the allocation appropriately\n\n  let inputArgumentsAllocation = abiAllocationInput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"calldata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let outputArgumentsAllocation = abiAllocationOutput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let inputsAllocation = {\n    abi: abiEntry,\n    offset,\n    arguments: inputArgumentsAllocation,\n    allocationMode: inputMode\n  };\n  let outputsAllocation;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputsAllocation = {\n        selector: new Uint8Array(),\n        arguments: outputArgumentsAllocation,\n        allocationMode: outputMode,\n        kind: \"return\"\n      };\n      break;\n\n    case \"constructor\":\n      outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n      break;\n  }\n\n  return {\n    input: inputsAllocation,\n    output: outputsAllocation\n  }; //TS chokes on this for some reason\n} //note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\n\n\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n\n  let parameterTypes;\n  let abiAllocation;\n\n  if (allocationMode === \"full\") {\n    let id = \"-1\"; //fake ID that doesn't matter\n\n    parameterTypes = fullModeParameters.map(parameter => ({\n      name: parameter.name,\n      type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n\n    }));\n    debug(\"parameterTypes: %O\", parameterTypes); //now: perform the allocation!\n\n    try {\n      abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    } catch (_a) {\n      //if something goes wrong, switch to ABI mdoe\n      debug(\"falling back to ABI due to exception!\");\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    //this is the ABI case.  we end up here EITHER\n    //if node doesn't exist, OR if something went wrong\n    //during allocation\n    let id = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiParameters.map(parameter => ({\n      name: parameter.name,\n      type: Import.abiParameterToType(parameter)\n    }));\n    abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n  }\n\n  return {\n    allocation: abiAllocation,\n    mode: allocationMode\n  };\n} //allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n\n\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let parameterTypes;\n  let nodeId;\n  let id; //first: determine the corresponding event node\n  //search through base contracts, from most derived (right) to most base (left)\n\n  let node = undefined;\n  let definedIn = undefined;\n  let allocationMode = \"full\"; //degrade to abi as needed\n\n  debug(\"allocating ABI: %O\", abiEntry);\n\n  if (contractNode) {\n    //first: check same contract for the event\n    node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be an event node, but then it will\n    //return false\n    abiEntry, eventNode, referenceDeclarations)); //if we found the node, great!  If not...\n\n    if (!node) {\n      debug(\"didn't find node in base contract...\"); //let's search for the node among the base contracts.\n      //but if we find it...\n      //[note: the following code is overcomplicated; it was used\n      //when we were trying to get the actual node, it's overcomplicated\n      //now that we're just determining its presence.  oh well]\n\n      let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n      linearizedBaseContractsMinusSelf.shift(); //remove self\n\n      debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n      node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a event node, but then it will return false\n      abiEntry, eventNode, referenceDeclarations) //don't pass deriveContractNode here, we're not checking the contract itself\n      ).node; //may be undefined! that's OK!\n\n      if (node) {\n        //...if we find the node in an ancestor, we\n        //deliberately *don't* allocate!  instead such cases\n        //will be handled during a later combination step\n        debug(\"bailing out for later handling!\");\n        debug(\"ABI: %O\", abiEntry);\n        return undefined;\n      }\n    }\n  } //otherwise, leave node undefined\n\n\n  if (node) {\n    debug(\"found node\"); //if we found the node, let's also turn it into a type\n\n    definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler); //can skip reference declarations argument here\n    //...and set the ID\n\n    id = (0, import_1.makeTypeId)(node.id, compilationId);\n  } else {\n    //if no node, have to fall back into ABI mode\n    debug(\"falling back to ABI because no node\");\n    allocationMode = \"abi\";\n  } //now: construct the list of parameter types, attaching indexedness info\n  //and overall position (for later reconstruction)\n\n\n  let indexed;\n  let nonIndexed;\n  let abiAllocation; //the untransformed allocation for the non-indexed parameters\n\n  if (allocationMode === \"full\") {\n    nodeId = node.id.toString();\n    let parameters = node.parameters.parameters;\n    parameterTypes = parameters.map(definition => ({\n      //note: if node is defined, compiler had better be defined, too!\n      type: Ast.Import.definitionToType(definition, compilationId, compiler),\n      name: definition.name,\n      indexed: definition.indexed\n    })); //now: split the list of parameters into indexed and non-indexed\n\n    [indexed, nonIndexed] = (0, partition_1.default)(parameterTypes, parameter => parameter.indexed);\n\n    try {\n      //now: perform the allocation for the non-indexed parameters!\n      abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    } catch (_a) {\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    nodeId = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiEntry.inputs.map(abiParameter => ({\n      type: Import.abiParameterToType(abiParameter),\n      name: abiParameter.name,\n      indexed: abiParameter.indexed\n    })); //now: split the list of parameters into indexed and non-indexed\n\n    [indexed, nonIndexed] = (0, partition_1.default)(parameterTypes, parameter => parameter.indexed); //now: perform the allocation for the non-indexed parameters!\n\n    abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n  } //now: transform the result appropriately\n\n\n  const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"eventdata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  })); //now: allocate the indexed parameters\n\n  const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n\n  const indexedArgumentsAllocation = indexed.map((_ref, position) => {\n    let {\n      type,\n      name\n    } = _ref;\n    return {\n      type,\n      name,\n      pointer: {\n        location: \"eventtopic\",\n        topic: startingTopic + position\n      }\n    };\n  }); //finally: weave these back together\n\n  let argumentsAllocation = [];\n\n  for (let parameter of parameterTypes) {\n    let arrayToGrabFrom = parameter.indexed ? indexedArgumentsAllocation : nonIndexedArgumentsAllocation;\n    argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  } //...and return\n\n\n  return {\n    abi: abiEntry,\n    contextHash: undefined,\n    definedIn,\n    id,\n    arguments: argumentsAllocation,\n    allocationMode,\n    anonymous: abiEntry.anonymous\n  };\n}\n\nfunction allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  //first: if we got passed just a node & no abi entry,\n  let id = undefined;\n  let definedIn = undefined;\n  let parametersFull = undefined;\n  const parametersAbi = abiEntry.inputs;\n\n  if (errorNode) {\n    //first, set parametersFull\n    parametersFull = errorNode.parameters.parameters; //now, set id\n\n    id = (0, import_1.makeTypeId)(errorNode.id, compilationId); //now, set definedIn\n\n    let contractNode = null;\n\n    for (const node of Object.values(referenceDeclarations)) {\n      if (node.nodeType === \"ContractDefinition\") {\n        if (node.nodes.some(subNode => subNode.id === errorNode.id)) {\n          contractNode = node;\n          break;\n        }\n      } //if we didn't find it, then contractNode is null\n      //(and thus so will be definedIn)\n\n    }\n\n    if (contractNode === null) {\n      definedIn = null;\n    } else {\n      definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler);\n    }\n  } //otherwise, leave parametersFull, id, and definedIn undefined\n\n\n  const {\n    allocation: abiAllocation,\n    mode: allocationMode\n  } = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector\n  ); //finally: transform the allocation appropriately\n\n  const argumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  const selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));\n  return {\n    kind: \"revert\",\n    selector,\n    abi: abiEntry,\n    id,\n    definedIn,\n    arguments: argumentsAllocation,\n    allocationMode\n  };\n}\n\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let allocations = {\n    constructorAllocation: undefined,\n    //(if it doesn't then it will remain as default)\n    functionAllocations: {}\n  };\n\n  if (!abi) {\n    //if no ABI, can't do much!\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    return allocations;\n  }\n\n  for (let abiEntry of abi) {\n    if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) || AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n      //the first of these conditions is a hack workaround for a Solidity bug.\n      //the second of these is because... seriously? we're not handling these\n      //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n      //thankfully)\n      continue;\n    }\n\n    switch (abiEntry.type) {\n      case \"constructor\":\n        allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n        break;\n\n      case \"function\":\n        allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        break;\n\n      default:\n        //skip over fallback, error, and event\n        break;\n    }\n  }\n\n  if (!allocations.constructorAllocation) {\n    //set a default constructor allocation if we haven't allocated one yet\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n  }\n\n  return allocations;\n}\n\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n  if (!constructorContext) {\n    return undefined;\n  }\n\n  const rawLength = constructorContext.binary.length;\n  const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n\n  const input = {\n    offset,\n    abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n    arguments: [],\n    allocationMode: \"full\"\n  };\n  const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n\n  return {\n    input,\n    output\n  };\n} //note: context should be deployed context!\n\n\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n  if (!context) {\n    //just return a default abi mode result\n    return {\n      selector: new Uint8Array(),\n      allocationMode: \"abi\",\n      kind: \"bytecode\",\n      delegatecallGuard: false\n    };\n  }\n\n  const {\n    immutableReferences,\n    compilationId,\n    compiler,\n    contractKind,\n    binary\n  } = context;\n  let immutables;\n\n  if (allocationMode === \"full\" && immutableReferences) {\n    if (contractNode) {\n      debug(\"allocating immutables\");\n      immutables = [];\n\n      for (const [id, references] of Object.entries(immutableReferences)) {\n        if (references.length === 0) {\n          continue; //don't allocate immutables that don't exist\n        }\n\n        const astId = parseInt(id); //get the corresponding variable node; potentially fail\n\n        const {\n          node: definition,\n          contract: definedIn\n        } = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode);\n\n        if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n          debug(\"didn't find definition for %d!\", astId);\n          allocationMode = \"abi\";\n          immutables = undefined;\n          break;\n        }\n\n        const definedInClass = Ast.Import.definitionToStoredType(definedIn, compilationId, compiler); //can skip reference declarations argument here\n\n        const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n        immutables.push({\n          name: definition.name,\n          definedIn: definedInClass,\n          type: dataType,\n          pointer: {\n            location: \"returndata\",\n            start: references[0].start,\n            length: references[0].length\n          }\n        });\n      }\n    } else if (Object.entries(immutableReferences).length > 0) {\n      //if there are immutables, but no contract mode, go to abi mode\n      debug(\"immutables but no node!\");\n      allocationMode = \"abi\";\n    }\n  } else {\n    debug(\"no immutables\");\n  } //now, is there a delegatecall guard?\n\n\n  let delegatecallGuard = false;\n\n  if (contractKind === \"library\") {\n    //note: I am relying on this being present!\n    //(also this part is a bit HACKy)\n    const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n    const delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n\n    if (binary.startsWith(delegateCallGuardString)) {\n      delegatecallGuard = true;\n    }\n  }\n\n  return {\n    selector: new Uint8Array(),\n    allocationMode,\n    kind: \"bytecode\",\n    immutables,\n    delegatecallGuard\n  };\n}\n\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allocations = {\n    constructorAllocations: {},\n    functionAllocations: {}\n  };\n\n  for (let contract of contracts) {\n    const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n\n    if (contract.constructorContext) {\n      allocations.constructorAllocations[contract.constructorContext.context] = contractAllocations.constructorAllocation;\n    }\n\n    if (contract.deployedContext) {\n      allocations.functionAllocations[contract.deployedContext.context] = contractAllocations.functionAllocations; //set this up under both constructor *and* deployed! this is to handle\n      //constructor returndata decoding\n\n      allocations.constructorAllocations[contract.deployedContext.context] = contractAllocations.constructorAllocation;\n    }\n  }\n\n  return allocations;\n}\n\nexports.getCalldataAllocations = getCalldataAllocations;\n\nfunction getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let useAst = Boolean(contractNode && contractNode.usedErrors);\n\n  if (useAst) {\n    const errorNodes = contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]);\n    let abis;\n\n    try {\n      abis = errorNodes.map(errorNode => Ast.Utils.definitionToAbi(errorNode, referenceDeclarations));\n    } catch (_a) {\n      useAst = false;\n    }\n\n    if (useAst) {\n      //i.e. if the above operation succeeded\n      return contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]).map((errorNode, index) => allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n    }\n  }\n\n  if (!useAst && abi) {\n    //deliberately *not* an else!\n    return abi.filter(abiEntry => abiEntry.type === \"error\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n    .map(abiEntry => allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n  } //otherwise just return nothing\n\n\n  return [];\n}\n\nfunction getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allContexts = [].concat(...contracts.map(_ref2 => {\n    let {\n      deployedContext,\n      constructorContext\n    } = _ref2;\n    return [deployedContext, constructorContext];\n  })).filter(x => x) //filter out nonexistent contexts\n  .map(context => context.context);\n  allContexts.push(\"\"); //HACK: add fictional empty-string context to represent no-context\n  //holds allocations for a given context\n\n  let selfAllocations = {}; //holds allocations for *other* contexts\n\n  let additionalAllocations = {}; //now: process the allocations for each contract. we'll add each contract's\n  //allocations to *its* entries in allocations, and to every *other* entry\n  //in additionalAllocations.\n\n  for (const contract of contracts) {\n    const contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n    const contexts = [//contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n    const otherContexts = allContexts.filter( //contexts for all other contracts\n    contextHash => !contexts.includes(contextHash)); //add them to selfAllocations\n\n    for (const contextHash of contexts) {\n      selfAllocations[contextHash] = contractAllocations;\n    } //add them to additionalAllocations\n\n\n    for (const contextHash of otherContexts) {\n      if (additionalAllocations[contextHash] === undefined) {\n        additionalAllocations[contextHash] = [];\n      }\n\n      additionalAllocations[contextHash] = additionalAllocations[contextHash].concat(contractAllocations);\n    }\n  }\n\n  let allocations = Object.assign({}, ...allContexts.map(contextHash => ({\n    [contextHash]: {}\n  }))); //now: perform coalescense!\n\n  for (const contract of contracts) {\n    //we're setting up contexts again, sorry >_>\n    const contexts = [//contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n\n    for (const contextHash of contexts) {\n      allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);\n      debug(\"allocations: %O\", allocations[contextHash]);\n    }\n  } //...also coalesce the fake \"\" context\n\n\n  allocations[\"\"] = coalesceReturndataAllocations([], additionalAllocations[\"\"] || []);\n  debug(\"error allocations: %O\", allocations);\n  return allocations;\n}\n\nexports.getReturndataAllocations = getReturndataAllocations;\n\nfunction coalesceReturndataAllocations(selfAllocations, additionalAllocations) {\n  let bySelector = {}; //start with the additional allocations; we want to process\n  //the self allocations last, due to special handling of no-ID allocations there\n\n  for (const allocation of additionalAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = web3_utils_1.default.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n\n    if (bySelector[selector]) {\n      //note: at this point, for any given signature, there should only be a\n      //no-ID allocation for that signature if it's the only one\n      if (allocation.id !== undefined) {\n        //delete anything with that signature but w/o an ID, or with this same ID\n        bySelector[selector] = bySelector[selector].filter(_ref3 => {\n          let {\n            abi,\n            id\n          } = _ref3;\n          return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n        }); //add this allocation\n\n        bySelector[selector].push(allocation);\n      } else if (!bySelector[selector].some(_ref4 => {\n        let {\n          abi\n        } = _ref4;\n        return AbiDataUtils.abiSignature(abi) === signature;\n      })) {\n        //only add ID-less ones if there isn't anything of that signature already\n        bySelector[selector].push(allocation);\n      }\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  } //now we're going to perform a modified version of this procedure for the self allocations:\n  //1. we're going to add to the front, not the back\n  //2. we can add an ID-less one even if there are already ones with IDs there\n  //(sorry for the copypaste)\n\n\n  for (const allocation of selfAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = web3_utils_1.default.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n\n    if (bySelector[selector]) {\n      //delete anything with that signature but w/o an ID, or with this same ID\n      //(if this alloc has no ID, this will only delete ID-less ones :) )\n      bySelector[selector] = bySelector[selector].filter(_ref5 => {\n        let {\n          abi,\n          id\n        } = _ref5;\n        return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n      }); //add this allocation to front, not back!\n\n      bySelector[selector].unshift(allocation);\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  }\n\n  return bySelector;\n}\n\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  if (!abi) {\n    //can't do much if no ABI!\n    return [];\n  }\n\n  return abi.filter(abiEntry => abiEntry.type === \"event\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n  .map(abiEntry => ({\n    selector: AbiDataUtils.abiSelector(abiEntry),\n    anonymous: abiEntry.anonymous,\n    topics: AbiDataUtils.topicsCount(abiEntry),\n    allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n  })); //note we do *not* filter out undefined allocations; we need these as placeholders\n} //WARNING: this function is full of hacks... sorry\n\n\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allowConstructorEvents = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  //first: do allocations for individual contracts\n  let individualAllocations = {};\n  let groupedAllocations = {};\n  let contextSwapMap = {}; //maps deployed to constructor & vice versa\n\n  let allocations = {};\n\n  for (const {\n    abi,\n    deployedContext,\n    constructorContext,\n    contractNode,\n    compilationId,\n    compiler\n  } of contracts) {\n    if (!deployedContext && !constructorContext && !contractNode) {\n      //we'll need *one* of these at least\n      continue;\n    }\n\n    const contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n    const key = makeContractKey(deployedContext || constructorContext, contractNode ? contractNode.id : undefined, compilationId);\n\n    if (individualAllocations[key] === undefined) {\n      individualAllocations[key] = {};\n    }\n\n    for (const allocationTemporary of contractAllocations) {\n      //we'll use selector *even for anonymous* here, because it's just\n      //for determining what overrides what at this point\n      individualAllocations[key][allocationTemporary.selector] = {\n        context: deployedContext || constructorContext,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      };\n    } //also: set up the swap map\n\n\n    if (deployedContext && constructorContext) {\n      contextSwapMap[deployedContext.context] = constructorContext.context;\n      contextSwapMap[constructorContext.context] = deployedContext.context;\n    }\n  } //now: put things together for inheritance\n  //note how we always put things in order from most derived to most base\n\n\n  for (let contextOrId in individualAllocations) {\n    groupedAllocations[contextOrId] = {};\n\n    for (let selector in individualAllocations[contextOrId]) {\n      let {\n        context,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      } = individualAllocations[contextOrId][selector];\n      debug(\"allocationTemporary: %O\", allocationTemporary);\n      let allocationsTemporary = allocationTemporary.allocation ? [allocationTemporary] : []; //filter out undefined allocations\n      //first, copy from individual allocations\n\n      groupedAllocations[contextOrId][selector] = {\n        context,\n        contractNode,\n        allocationsTemporary\n      }; //if no contract node, that's all.  if there is...\n\n      if (contractNode) {\n        //...we have to do inheritance processing\n        debug(\"contract Id: %d\", contractNode.id);\n        debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n        let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n        linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n\n        for (let baseId of linearizedBaseContractsMinusSelf) {\n          debug(\"checking baseId: %d\", baseId);\n          let baseNode = referenceDeclarations[compilationId][baseId];\n\n          if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n            debug(\"failed to find node for baseId: %d\", baseId);\n            break; //not a continue!\n            //if we can't find the base node, it's better to stop the loop,\n            //rather than continue to potentially erroneous things\n          } //note: we're not actually going to *use* the baseNode here.\n          //we're just checking for whether we can *find* it\n          //why? because if we couldn't find it, that means that events defined in\n          //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n\n\n          let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId && contractAllocationInfo.contractNode && contractAllocationInfo.contractNode.id === baseId);\n\n          if (!baseContractInfo) {\n            //similar to above... this failure case can happen when there are\n            //two contracts with the same name and you attempt to use the\n            //artifacts; say you have contracts A, B, and B', where A inherits\n            //from B, and B and B' have the same name, and B' is the one that\n            //gets the artifact; B will end up in reference declarations and so\n            //get found above, but it won't appear in contracts, causing the\n            //problem here.  Unfortunately I don't know any great way to handle this,\n            //so, uh, we treat it as a failure same as above.\n            debug(\"failed to find contract info for baseId: %d\", baseId);\n            break;\n          }\n\n          let baseContext = baseContractInfo.deployedContext || baseContractInfo.constructorContext;\n          let baseKey = makeContractKey(baseContext, baseId, compilationId);\n\n          if (individualAllocations[baseKey][selector] !== undefined) {\n            let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n            debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n\n            if (baseAllocation.allocation) {\n              //don't push undefined!\n              groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n            }\n          }\n        }\n      }\n    }\n  } //finally: transform into final form & return,\n  //filtering out things w/o a context\n\n\n  for (let contractKey in groupedAllocations) {\n    if (!hasContext(contractKey)) {\n      continue; //(this filters out ones that had no context and therefore were\n      //given by ID; we needed these at the previous stage but from\n      //here on they're irrelevant)\n    }\n\n    let contextHash = contextHashForKey(contractKey);\n\n    for (let selector in groupedAllocations[contextHash]) {\n      let {\n        allocationsTemporary,\n        context\n      } = groupedAllocations[contextHash][selector];\n\n      for (let {\n        anonymous,\n        topics,\n        allocation\n      } of allocationsTemporary) {\n        let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n\n        if (contractKind !== \"library\") {\n          contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n        }\n\n        allocation = Object.assign(Object.assign({}, allocation), {\n          contextHash\n        }); //the allocation's context hash at this point depends on where it was defined, but\n        //that's not what we want going in the final allocation table!\n\n        if (allocations[topics] === undefined) {\n          allocations[topics] = {\n            bySelector: {},\n            anonymous: {\n              contract: {},\n              library: {}\n            }\n          };\n        }\n\n        if (!anonymous) {\n          if (allocations[topics].bySelector[selector] === undefined) {\n            allocations[topics].bySelector[selector] = {\n              contract: {},\n              library: {}\n            };\n          } //push the allocation (non-anonymous case)\n\n\n          if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {\n            allocations[topics].bySelector[selector][contractKind][contextHash] = [];\n          }\n\n          allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation); //...and push it in the swapped context too if that exists\n          //HACK: don't do this for libraries! library events are already\n          //considered always in play, so including them *twice* would cause\n          //problems... fortunately library constructors don't emit events!\n\n          if (allowConstructorEvents && contextHash in contextSwapMap && contractKind !== \"library\") {\n            const swappedHash = contextSwapMap[contextHash];\n\n            if (allocations[topics].bySelector[selector][contractKind][swappedHash] === undefined) {\n              allocations[topics].bySelector[selector][contractKind][swappedHash] = [];\n            }\n\n            allocations[topics].bySelector[selector][contractKind][swappedHash].push(allocation);\n          }\n        } else {\n          //push the allocation (anonymous case)\n          if (allocations[topics].anonymous[contractKind][contextHash] === undefined) {\n            allocations[topics].anonymous[contractKind][contextHash] = [];\n          }\n\n          allocations[topics].anonymous[contractKind][contextHash].push(allocation); //...and push it in the swapped context too if that exists\n          //(and it's not a library, see above)\n\n          if (allowConstructorEvents && contextHash in contextSwapMap && contractKind !== \"library\") {\n            const swappedHash = contextSwapMap[contextHash];\n\n            if (allocations[topics].anonymous[contractKind][swappedHash] === undefined) {\n              allocations[topics].anonymous[contractKind][swappedHash] = [];\n            }\n\n            allocations[topics].anonymous[contractKind][swappedHash].push(allocation);\n          }\n        }\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getEventAllocations = getEventAllocations; //if derivedContractNode is passed, we check that before referenceDeclarations\n\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n  const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {\n    if (foundNodeAndContract !== undefined) {\n      return foundNodeAndContract; //once we've found something, we don't need to keep looking\n    }\n\n    debug(\"searching contract %d\", baseContractId);\n    let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n    : referenceDeclarations[baseContractId];\n\n    if (baseContractNode === undefined || baseContractNode.nodeType !== \"ContractDefinition\") {\n      debug(\"bad contract node!\");\n      return null; //return null rather than undefined so that this will propagate through\n      //(i.e. by returning null here we give up the search)\n      //(we don't want to continue due to possibility of grabbing the wrong override)\n    }\n\n    const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n\n    if (node) {\n      debug(\"found node: %o\", node);\n      return {\n        node,\n        contract: baseContractNode\n      };\n    } else {\n      return undefined;\n    }\n  }, undefined //start with no node found\n  );\n  return searchResult || {\n    node: undefined,\n    contract: undefined\n  };\n}\n\nfunction makeContractKey(context, id, compilationId) {\n  return context ? context.context : id + \":\" + compilationId; //HACK!\n}\n\nfunction hasContext(key) {\n  return key.startsWith(\"0x\"); //HACK!\n}\n\nfunction contextHashForKey(key) {\n  return hasContext(key) ? key //HACK!\n  : undefined;\n}","map":{"version":3,"mappings":"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","names":["debug","exports","kind","selector","Uint8Array","allocationMode","getAbiAllocations","userDefinedTypes","allocations","dataType","Object","values","typeClass","allocateStruct","_","existingAllocations","allocateMembers","id","memberTypes","parentId","members","start","dynamic","memberAllocations","member","length","dynamicMember","size","abiSizeAndAllocate","type","undefined","pointer","location","push","name","Evm","Utils","WORD_SIZE","visibility","isZero","baseSize","baseType","toNumber","allocation","storedType","Common","UnknownUserDefinedTypeError","Format","Types","typeString","memberSize","memberDynamic","abiSizeInfo","allocateCalldataAndReturndata","abiEntry","contractNode","referenceDeclarations","abiAllocations","compilationId","compiler","constructorContext","deployedContext","node","inputParametersFull","outputParametersFull","inputParametersAbi","outputParametersAbi","offset","rawLength","binary","nodes","find","functionNode","AbiDataUtils","definitionMatchesAbi","SELECTOR_SIZE","linearizedBaseContracts","findNodeAndContract","Boolean","nodeType","parameters","returnParameters","inputs","outputs","Ast","getterParameters","abiAllocationInput","mode","inputMode","allocateDataArguments","abiAllocationOutput","outputMode","inputArgumentsAllocation","map","outputArgumentsAllocation","inputsAllocation","abi","arguments","outputsAllocation","constructorOutputAllocation","input","output","fullModeParameters","abiParameters","parameterTypes","abiAllocation","parameter","Import","definitionToType","abiParameterToType","allocateEvent","nodeId","definedIn","eventNode","linearizedBaseContractsMinusSelf","slice","shift","definitionToStoredType","indexed","nonIndexed","toString","definition","abiParameter","nonIndexedArgumentsAllocation","startingTopic","anonymous","indexedArgumentsAllocation","position","topic","argumentsAllocation","arrayToGrabFrom","contextHash","allocateError","errorNode","parametersFull","parametersAbi","some","subNode","Conversion","toBytes","abiSelector","getCalldataAllocationsForContract","constructorAllocation","functionAllocations","defaultConstructorAllocation","abiEntryIsObviouslyIllTyped","abiEntryHasStorageParameters","DEFAULT_CONSTRUCTOR_ABI","context","delegatecallGuard","immutableReferences","contractKind","immutables","references","entries","astId","parseInt","contract","definedInClass","pushAddressInstruction","ADDRESS_SIZE","delegateCallGuardString","repeat","startsWith","getCalldataAllocations","contracts","constructorAllocations","contractAllocations","getReturndataAllocationsForContract","useAst","usedErrors","errorNodes","errorNodeId","abis","definitionToAbi","index","filter","getReturndataAllocations","allContexts","concat","x","selfAllocations","additionalAllocations","contexts","otherContexts","includes","assign","coalesceReturndataAllocations","bySelector","signature","abiSignature","web3_utils_1","soliditySha3","value","unshift","getEventAllocationsForContract","topics","topicsCount","getEventAllocations","allowConstructorEvents","individualAllocations","groupedAllocations","contextSwapMap","key","makeContractKey","allocationTemporary","contextOrId","allocationsTemporary","baseId","baseNode","baseContractInfo","contractAllocationInfo","baseContext","baseKey","baseAllocation","contractKey","hasContext","contextHashForKey","library","swappedHash","condition","derivedContractNode","searchResult","reduce","foundNodeAndContract","baseContractId","baseContractNode"],"sourceRoot":"","sources":["../../../../lib/abi-data/allocate/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}