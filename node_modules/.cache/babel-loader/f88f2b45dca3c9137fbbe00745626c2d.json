{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.equalSlots = exports.slotAddress = exports.storageLengthToBytes = exports.isWordsLength = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:storage:utils\");\n\nconst Evm = __importStar(require(\"../evm\"));\n\nconst MappingKey = __importStar(require(\"../mapping-key\"));\n\nfunction isWordsLength(size) {\n  return size.words !== undefined;\n}\n\nexports.isWordsLength = isWordsLength;\n\nfunction storageLengthToBytes(size) {\n  if (isWordsLength(size)) {\n    debug(\"size.words %d\", size.words);\n    return size.words * Evm.Utils.WORD_SIZE;\n  } else {\n    return size.bytes;\n  }\n}\n\nexports.storageLengthToBytes = storageLengthToBytes;\n/**\n * convert a slot to a word corresponding to actual storage address\n *\n * if `slot` is an array, return hash of array values.\n * if `slot` array is nested, recurse on sub-arrays\n *\n * @param slot - number or possibly-nested array of numbers\n */\n\nfunction slotAddress(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    return Evm.Utils.keccak256(MappingKey.Encode.mappingKeyAsHex(slot.key), slotAddress(slot.path)).add(slot.offset);\n  } else if (slot.path !== undefined) {\n    const pathAddress = slotAddress(slot.path);\n    const path = slot.hashPath ? Evm.Utils.keccak256(pathAddress) : pathAddress;\n    return path.add(slot.offset);\n  } else {\n    return slot.offset;\n  }\n}\n\nexports.slotAddress = slotAddress; //note: this function compares slots mostly by structure,\n//rather than by their numerical value\n\nfunction equalSlots(slot1, slot2) {\n  if (!slot1 || !slot2) {\n    return !slot1 && !slot2; //if either is undefined, it's true only if both are\n  }\n\n  if (!slot1.offset.eq(slot2.offset)) {\n    return false;\n  }\n\n  if (slot1.hashPath !== slot2.hashPath) {\n    return false;\n  }\n\n  if (!equalSlots(slot1.path, slot2.path)) {\n    return false;\n  } //to compare keys, we'll just compare their hex encodings\n  //(yes, that leaves some wiggle room, as it could consider different\n  //*types* of keys to be equal, but if keys are the only difference then\n  //that should determine those types, so it shouldn't be a problem)\n\n\n  if (!slot1.key || !slot2.key) {\n    //first, though, they likely don't *have* keys\n    return !slot1.key && !slot2.key;\n  } //if they do have keys, though...\n\n\n  return Evm.Utils.equalData(MappingKey.Encode.encodeMappingKey(slot1.key), MappingKey.Encode.encodeMappingKey(slot2.key));\n}\n\nexports.equalSlots = equalSlots;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA,MAAMA,KAAK,GAAG,qBAAY,qBAAZ,CAAd;;AAEA;;AACA;;AAIA,SAAgBC,aAAhB,CAA8BC,IAA9B,EAAiD;EAC/C,OAA2BA,IAAK,CAACC,KAAN,KAAgBC,SAA3C;AACD;;AAFDC;;AAIA,SAAgBC,oBAAhB,CAAqCJ,IAArC,EAAwD;EACtD,IAAID,aAAa,CAACC,IAAD,CAAjB,EAAyB;IACvBF,KAAK,CAAC,eAAD,EAAkBE,IAAI,CAACC,KAAvB,CAAL;IACA,OAAOD,IAAI,CAACC,KAAL,GAAaI,GAAG,CAACC,KAAJ,CAAUC,SAA9B;EACD,CAHD,MAGO;IACL,OAAOP,IAAI,CAACQ,KAAZ;EACD;AACF;;AAPDL;AASA;;;;;;;;;AAQA,SAAgBM,WAAhB,CAA4BC,IAA5B,EAAsC;EACpC,IAAIA,IAAI,CAACC,GAAL,KAAaT,SAAb,IAA0BQ,IAAI,CAACE,IAAL,KAAcV,SAA5C,EAAuD;IACrD;IACA,OAAOG,GAAG,CAACC,KAAJ,CAAUO,SAAV,CACLC,UAAU,CAACC,MAAX,CAAkBC,eAAlB,CAAkCN,IAAI,CAACC,GAAvC,CADK,EAELF,WAAW,CAACC,IAAI,CAACE,IAAN,CAFN,EAGLK,GAHK,CAGDP,IAAI,CAACQ,MAHJ,CAAP;EAID,CAND,MAMO,IAAIR,IAAI,CAACE,IAAL,KAAcV,SAAlB,EAA6B;IAClC,MAAMiB,WAAW,GAAGV,WAAW,CAACC,IAAI,CAACE,IAAN,CAA/B;IACA,MAAMA,IAAI,GAAOF,IAAI,CAACU,QAAL,GACbf,GAAG,CAACC,KAAJ,CAAUO,SAAV,CAAoBM,WAApB,CADa,GAEbA,WAFJ;IAGA,OAAOP,IAAI,CAACK,GAAL,CAASP,IAAI,CAACQ,MAAd,CAAP;EACD,CANM,MAMA;IACL,OAAOR,IAAI,CAACQ,MAAZ;EACD;AACF;;AAhBDf,kC,CAkBA;AACA;;AACA,SAAgBkB,UAAhB,CACEC,KADF,EAEEC,KAFF,EAEyB;EAEvB,IAAI,CAACD,KAAD,IAAU,CAACC,KAAf,EAAsB;IACpB,OAAO,CAACD,KAAD,IAAU,CAACC,KAAlB,CADoB,CACK;EAC1B;;EACD,IAAI,CAACD,KAAK,CAACJ,MAAN,CAAaM,EAAb,CAAgBD,KAAK,CAACL,MAAtB,CAAL,EAAoC;IAClC,OAAO,KAAP;EACD;;EACD,IAAII,KAAK,CAACF,QAAN,KAAmBG,KAAK,CAACH,QAA7B,EAAuC;IACrC,OAAO,KAAP;EACD;;EACD,IAAI,CAACC,UAAU,CAACC,KAAK,CAACV,IAAP,EAAaW,KAAK,CAACX,IAAnB,CAAf,EAAyC;IACvC,OAAO,KAAP;EACD,CAbsB,CAcvB;EACA;EACA;EACA;;;EACA,IAAI,CAACU,KAAK,CAACX,GAAP,IAAc,CAACY,KAAK,CAACZ,GAAzB,EAA8B;IAC5B;IACA,OAAO,CAACW,KAAK,CAACX,GAAP,IAAc,CAACY,KAAK,CAACZ,GAA5B;EACD,CArBsB,CAsBvB;;;EACA,OAAON,GAAG,CAACC,KAAJ,CAAUmB,SAAV,CACLX,UAAU,CAACC,MAAX,CAAkBW,gBAAlB,CAAmCJ,KAAK,CAACX,GAAzC,CADK,EAELG,UAAU,CAACC,MAAX,CAAkBW,gBAAlB,CAAmCH,KAAK,CAACZ,GAAzC,CAFK,CAAP;AAID;;AA7BDR","names":["debug","isWordsLength","size","words","undefined","exports","storageLengthToBytes","Evm","Utils","WORD_SIZE","bytes","slotAddress","slot","key","path","keccak256","MappingKey","Encode","mappingKeyAsHex","add","offset","pathAddress","hashPath","equalSlots","slot1","slot2","eq","equalData","encodeMappingKey"],"sourceRoot":"","sources":["../../../lib/storage/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}