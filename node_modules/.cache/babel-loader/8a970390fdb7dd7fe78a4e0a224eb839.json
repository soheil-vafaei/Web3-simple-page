{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.stringToBytes = exports.toBytes = exports.toHexString = exports.toBig = exports.toBigInt = exports.toSignedBN = exports.isBig = exports.toBN = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:conversion\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst big_js_1 = __importDefault(require(\"big.js\"));\n\nconst utf8_1 = __importDefault(require(\"utf8\"));\n/**\n * @param bytes - undefined | string | number | BN | Uint8Array | Big\n * @return {BN}\n */\n\n\nfunction toBN(bytes) {\n  if (bytes === undefined) {\n    return undefined;\n  } else if (typeof bytes === \"string\") {\n    return new bn_js_1.default(bytes, 16);\n  } else if (typeof bytes === \"bigint\") {\n    return new bn_js_1.default(bytes.toString(16), 16);\n  } else if (typeof bytes == \"number\" || bn_js_1.default.isBN(bytes)) {\n    return new bn_js_1.default(bytes);\n  } else if (isBig(bytes)) {\n    return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!\n    //note: going through string may seem silly but it's actually not terrible here,\n    //since BN is binary-based and Big is decimal-based\n    //[toFixed is like toString except it guarantees scientific notation is not used]\n  } else if (typeof bytes.reduce === \"function\") {\n    return bytes.reduce((num, byte) => num.shln(8).addn(byte), new bn_js_1.default(0));\n  }\n}\n\nexports.toBN = toBN; //Big doesnt provide this function, so we'll make one ourselves\n//HACK\n\nfunction isBig(input) {\n  return typeof input === \"object\" && input !== null && (input.s === 1 || input.s === -1) && typeof input.e === \"number\" && Array.isArray(input.c) && //we want to be sure this is *not* a BigNumber instead,\n  //but we can't use isBigNumber here because we don't want\n  //to import that library here, so, HACK, we'll check that\n  //it lacks a particular BigNumber method that would be meaningless\n  //for Bigs\n  !input.isFinite; //(BigNumbers have this method because it supports Infinity and NaN,\n  //but Big doesn't, so this method doesn't exist, because it would\n  //be pointless)\n}\n\nexports.isBig = isBig;\n/**\n * @param bytes - Uint8Array\n * @return {BN}\n */\n\nfunction toSignedBN(bytes) {\n  if (bytes[0] < 0x80) {\n    // if first bit is 0\n    return toBN(bytes);\n  } else {\n    return toBN(bytes.map(b => 0xff - b)).addn(1).neg();\n  }\n}\n\nexports.toSignedBN = toSignedBN;\n\nfunction toBigInt(value) {\n  //BN is binary-based, so we convert by means of a hex string in order\n  //to avoid having to do a binary-decimal conversion and back :P\n  return !value.isNeg() ? BigInt(\"0x\" + value.toString(16)) : -BigInt(\"0x\" + value.neg().toString(16)); //can't directly make negative BigInt from hex string\n}\n\nexports.toBigInt = toBigInt;\n\nfunction toBig(value) {\n  //note: going through string may seem silly but it's actually not terrible here,\n  //since BN (& number) is binary-based and Big is decimal-based\n  return new big_js_1.default(value.toString());\n}\n\nexports.toBig = toBig;\n/**\n * @param bytes - Uint8Array | BN | bigint\n * @param padLength - number - minimum desired byte length (left-pad with zeroes)\n * @param padRight - boolean - causes padding to occur on right instead of left\n * @return {string}\n */\n\nfunction toHexString(bytes) {\n  let padLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let padRight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (bn_js_1.default.isBN(bytes) || typeof bytes === \"bigint\" || typeof bytes === \"number\" || isBig(bytes)) {\n    bytes = toBytes(bytes);\n  }\n\n  const pad = s => `${\"00\".slice(0, 2 - s.length)}${s}`; //                                          0  1  2  3  4\n  //                                 0  1  2  3  4  5  6  7\n  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )\n  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )\n  //                                `--.---'\n  //                                     offset 3\n\n\n  if (bytes.length < padLength) {\n    let prior = bytes;\n    bytes = new Uint8Array(padLength);\n\n    if (padRight) {\n      //unusual case: pad on right\n      bytes.set(prior);\n    } else {\n      //usual case\n      bytes.set(prior, padLength - prior.length);\n    }\n  }\n\n  debug(\"bytes: %o\", bytes);\n  let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, \"\");\n  return `0x${string}`;\n}\n\nexports.toHexString = toHexString;\n\nfunction toBytes(data) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  //note that length is a minimum output length\n  //strings will be 0-padded on left\n  //numbers/BNs will be sign-padded on left\n  //NOTE: if a number/BN is passed in that is too big for the given length,\n  //you will get an error!\n  //(note that strings passed in should be hex strings; this is not for converting\n  //generic strings to hex)\n  if (typeof data === \"bigint\") {\n    data = data.toString(16);\n  }\n\n  if (typeof data === \"string\") {\n    let hex = data; //renaming for clarity\n\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n\n    if (hex === \"\") {\n      //this special case is necessary because the match below will return null,\n      //not an empty array, when given an empty string\n      return new Uint8Array(0);\n    }\n\n    if (hex.length % 2 == 1) {\n      hex = `0${hex}`;\n    }\n\n    let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n\n    if (bytes.length < length) {\n      let prior = bytes;\n      bytes = new Uint8Array(length);\n      bytes.set(prior, length - prior.length);\n    }\n\n    return bytes;\n  } else {\n    // BN/Big/number case\n    if (typeof data === \"number\") {\n      data = new bn_js_1.default(data);\n    } else if (isBig(data)) {\n      //note: going through string may seem silly but it's actually not terrible here,\n      //since BN is binary-based and Big is decimal-based\n      data = new bn_js_1.default(data.toFixed()); //[toFixed is like toString except it guarantees scientific notation is not used]\n    } //note that the argument for toTwos is given in bits\n\n\n    return data.toTwos(length * 8).toArrayLike(Uint8Array, \"be\", length); //big-endian\n  }\n}\n\nexports.toBytes = toBytes;\n\nfunction stringToBytes(input) {\n  input = utf8_1.default.encode(input);\n  let bytes = new Uint8Array(input.length);\n\n  for (let i = 0; i < input.length; i++) {\n    bytes[i] = input.charCodeAt(i);\n  }\n\n  return bytes; //NOTE: this will throw an error if the string contained malformed UTF-16!\n  //but, well, it shouldn't contain that...\n}\n\nexports.stringToBytes = stringToBytes; //computes value * 10**decimalPlaces\n\nfunction shiftBigUp(value, decimalPlaces) {\n  let newValue = new big_js_1.default(value);\n  newValue.e += decimalPlaces;\n  return newValue;\n}\n\nexports.shiftBigUp = shiftBigUp; //computes value * 10**-decimalPlaces\n\nfunction shiftBigDown(value, decimalPlaces) {\n  let newValue = new big_js_1.default(value);\n  newValue.e -= decimalPlaces;\n  return newValue;\n}\n\nexports.shiftBigDown = shiftBigDown;\n\nfunction countDecimalPlaces(value) {\n  return Math.max(0, value.c.length - value.e - 1);\n}\n\nexports.countDecimalPlaces = countDecimalPlaces; //converts out of range booleans to true; something of a HACK\n//NOTE: does NOT do this recursively inside structs, arrays, etc!\n//I mean, those aren't elementary and therefore aren't in the domain\n//anyway, but still\n\nfunction cleanBool(result) {\n  switch (result.kind) {\n    case \"value\":\n      return result;\n\n    case \"error\":\n      switch (result.error.kind) {\n        case \"BoolOutOfRangeError\":\n          //return true\n          return {\n            type: result.type,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n\n        default:\n          return result;\n      }\n\n  }\n}\n\nexports.cleanBool = cleanBool;","map":{"version":3,"mappings":"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","names":["debug","toBN","bytes","undefined","bn_js_1","toString","isBN","isBig","toFixed","reduce","num","byte","shln","addn","exports","input","s","e","Array","isArray","c","isFinite","toSignedBN","map","b","neg","toBigInt","value","isNeg","BigInt","toBig","big_js_1","toHexString","padLength","padRight","toBytes","pad","slice","length","prior","Uint8Array","set","string","str","data","hex","startsWith","match","parseInt","toTwos","toArrayLike","stringToBytes","utf8_1","encode","i","charCodeAt","shiftBigUp","decimalPlaces","newValue","shiftBigDown","countDecimalPlaces","Math","max","cleanBool","result","kind","error","type","asBoolean"],"sourceRoot":"","sources":["../../lib/conversion.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}