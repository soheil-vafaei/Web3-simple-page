{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeLiteral = exports.decodeStack = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:stack:decode\");\n\nconst AbiData = __importStar(require(\"../../abi-data\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Memory = __importStar(require(\"../../memory\"));\n\nconst Storage = __importStar(require(\"../../storage\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeStack(dataType, pointer, info) {\n  let rawValue;\n\n  try {\n    rawValue = yield* (0, read_1.default)(pointer, info.state);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error);\n  }\n\n  const literalPointer = {\n    location: \"stackliteral\",\n    literal: rawValue\n  };\n  return yield* decodeLiteral(dataType, literalPointer, info);\n}\n\nexports.decodeStack = decodeStack;\n\nfunction* decodeLiteral(dataType, pointer, info) {\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer);\n\n  if (Format.Types.isReferenceType(dataType)) {\n    switch (dataType.location) {\n      case \"memory\":\n        //first: do we have a memory pointer? if so we can just dispatch to\n        //decodeMemoryReference\n        return yield* Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info);\n\n      case \"storage\":\n        //next: do we have a storage pointer (which may be a mapping)? if so, we can\n        //we dispatch to decodeStorageByAddress\n        return yield* Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info);\n\n      case \"calldata\":\n        //next: do we have a calldata pointer?\n        //if it's a lookup type, it'll need special handling\n        if (dataType.typeClass === \"bytes\" || dataType.typeClass === \"string\" || dataType.typeClass === \"array\" && dataType.kind === \"dynamic\") {\n          const lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));\n          const locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, {\n            location: \"stackliteral\",\n            literal: locationOnly\n          }, info, {\n            abiPointerBase: 0,\n            lengthOverride: lengthAsBN\n          });\n        } else {\n          //multivalue case -- this case is straightforward\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {\n            abiPointerBase: 0 //let's be explicit\n\n          });\n        }\n\n    }\n  } //next: do we have an external function?  these work differently on the stack\n  //than elsewhere, so we can't just pass it on to decodeBasic.\n\n\n  if (dataType.typeClass === \"function\" && dataType.visibility === \"external\") {\n    let address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n    let selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);\n\n    if (!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) || !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE)) {\n      return {\n        type: dataType,\n        kind: \"error\",\n        error: {\n          kind: \"FunctionExternalStackPaddingError\",\n          rawAddress: Conversion.toHexString(address),\n          rawSelector: Conversion.toHexString(selectorWord)\n        }\n      };\n    }\n\n    let selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: yield* Basic.Decode.decodeExternalFunction(address, selector, info)\n    };\n  } //finally, if none of the above hold, we can just dispatch to decodeBasic.\n  //however, note that because we're on the stack, we use the permissive padding\n  //option so that errors won't result due to values with bad padding\n  //(of numeric or bytesN type, anyway)\n\n\n  return yield* Basic.Decode.decodeBasic(dataType, pointer, info, {\n    paddingMode: \"permissive\"\n  });\n}\n\nexports.decodeLiteral = decodeLiteral;","map":{"version":3,"mappings":"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","names":["debug","decodeStack","dataType","pointer","info","rawValue","state","error","literalPointer","location","literal","decodeLiteral","exports","Format","Types","isReferenceType","Memory","Decode","decodeMemoryReferenceByAddress","Storage","decodeStorageReferenceByAddress","typeClass","kind","lengthAsBN","Conversion","toBN","slice","Evm","Utils","WORD_SIZE","locationOnly","AbiData","decodeAbiReferenceByAddress","abiPointerBase","lengthOverride","visibility","address","selectorWord","Basic","checkPaddingLeft","ADDRESS_SIZE","SELECTOR_SIZE","type","rawAddress","toHexString","rawSelector","selector","value","decodeExternalFunction","decodeBasic","paddingMode"],"sourceRoot":"","sources":["../../../../lib/stack/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}