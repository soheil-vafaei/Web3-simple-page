{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectAllocationInfo = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:abi-data:allocate:utils\");\n\nconst Compilations = __importStar(require(\"../../compilations\"));\n\nconst compile_common_1 = require(\"@truffle/compile-common\");\n\nconst Contexts = __importStar(require(\"../../contexts\"));\n\nconst Abi = __importStar(require(\"@truffle/abi-utils\"));\n\nfunction collectAllocationInfo(compilations) {\n  let contexts = {};\n  let deployedContexts = {};\n  let contractsAndContexts = [];\n\n  for (const compilation of compilations) {\n    for (const contract of compilation.contracts) {\n      const node = Compilations.Utils.getContractNode(contract, compilation);\n      let deployedContext = undefined;\n      let constructorContext = undefined;\n      const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);\n      const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode);\n\n      if (deployedBytecode && deployedBytecode !== \"0x\") {\n        deployedContext = Contexts.Utils.makeContext(contract, node, compilation);\n        contexts[deployedContext.context] = deployedContext; //note that we don't set up deployedContexts until after normalization!\n      }\n\n      if (bytecode && bytecode !== \"0x\") {\n        constructorContext = Contexts.Utils.makeContext(contract, node, compilation, true);\n        contexts[constructorContext.context] = constructorContext;\n      }\n\n      contractsAndContexts.push({\n        contract,\n        node,\n        deployedContext,\n        constructorContext,\n        compilationId: compilation.id\n      });\n    }\n  }\n\n  debug(\"known contexts: %o\", Object.keys(contexts));\n  contexts = Contexts.Utils.normalizeContexts(contexts);\n  deployedContexts = Object.assign({}, ...Object.values(contexts).map(context => !context.isConstructor ? {\n    [context.context]: context\n  } : {}));\n\n  for (const contractAndContexts of contractsAndContexts) {\n    //change everything to normalized version\n    if (contractAndContexts.deployedContext) {\n      contractAndContexts.deployedContext = contexts[contractAndContexts.deployedContext.context]; //get normalized version\n    }\n\n    if (contractAndContexts.constructorContext) {\n      contractAndContexts.constructorContext = contexts[contractAndContexts.constructorContext.context]; //get normalized version\n    }\n  }\n\n  const allocationInfo = contractsAndContexts.map(_ref => {\n    let {\n      contract: {\n        abi,\n        compiler,\n        immutableReferences\n      },\n      compilationId,\n      node,\n      deployedContext,\n      constructorContext\n    } = _ref;\n    return {\n      abi: Abi.normalize(abi),\n      compilationId,\n      compiler,\n      contractNode: node,\n      deployedContext,\n      constructorContext,\n      immutableReferences\n    };\n  });\n  return {\n    contexts,\n    deployedContexts,\n    contractsAndContexts,\n    allocationInfo\n  };\n}\n\nexports.collectAllocationInfo = collectAllocationInfo;","map":{"version":3,"mappings":"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","names":["debug","collectAllocationInfo","compilations","contexts","deployedContexts","contractsAndContexts","compilation","contract","contracts","node","Compilations","Utils","getContractNode","deployedContext","undefined","constructorContext","deployedBytecode","compile_common_1","NewToLegacy","forBytecode","bytecode","Contexts","makeContext","context","push","compilationId","id","Object","keys","normalizeContexts","assign","values","map","isConstructor","contractAndContexts","allocationInfo","abi","compiler","immutableReferences","Abi","normalize","contractNode","exports"],"sourceRoot":"","sources":["../../../../lib/abi-data/allocate/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}