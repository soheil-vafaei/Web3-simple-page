{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar externals_1 = require(\"./externals\");\n\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n\nvar internal_1 = require(\"./internal\");\n\nvar constants_1 = require(\"./constants\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar hash_1 = require(\"./hash\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar types_1 = require(\"./types\");\n\nvar Account =\n/** @class */\nfunction () {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  function Account(nonce, balance, stateRoot, codeHash) {\n    if (nonce === void 0) {\n      nonce = new externals_1.BN(0);\n    }\n\n    if (balance === void 0) {\n      balance = new externals_1.BN(0);\n    }\n\n    if (stateRoot === void 0) {\n      stateRoot = constants_1.KECCAK256_RLP;\n    }\n\n    if (codeHash === void 0) {\n      codeHash = constants_1.KECCAK256_NULL;\n    }\n\n    this.nonce = nonce;\n    this.balance = balance;\n    this.stateRoot = stateRoot;\n    this.codeHash = codeHash;\n\n    this._validate();\n  }\n\n  Account.fromAccountData = function (accountData) {\n    var nonce = accountData.nonce,\n        balance = accountData.balance,\n        stateRoot = accountData.stateRoot,\n        codeHash = accountData.codeHash;\n    return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n  };\n\n  Account.fromRlpSerializedAccount = function (serialized) {\n    var values = externals_1.rlp.decode(serialized);\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n\n    return this.fromValuesArray(values);\n  };\n\n  Account.fromValuesArray = function (values) {\n    var _a = __read(values, 4),\n        nonce = _a[0],\n        balance = _a[1],\n        stateRoot = _a[2],\n        codeHash = _a[3];\n\n    return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n  };\n\n  Account.prototype._validate = function () {\n    if (this.nonce.lt(new externals_1.BN(0))) {\n      throw new Error('nonce must be greater than zero');\n    }\n\n    if (this.balance.lt(new externals_1.BN(0))) {\n      throw new Error('balance must be greater than zero');\n    }\n\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32');\n    }\n\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  };\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n\n\n  Account.prototype.raw = function () {\n    return [(0, types_1.bnToUnpaddedBuffer)(this.nonce), (0, types_1.bnToUnpaddedBuffer)(this.balance), this.stateRoot, this.codeHash];\n  };\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n\n\n  Account.prototype.serialize = function () {\n    return externals_1.rlp.encode(this.raw());\n  };\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n\n\n  Account.prototype.isContract = function () {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n\n\n  Account.prototype.isEmpty = function () {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n\n  return Account;\n}();\n\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\nvar isValidAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\n\nvar toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  (0, helpers_1.assertIsHexString)(hexAddress);\n  var address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n  var prefix = '';\n\n  if (eip1191ChainId) {\n    var chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n    prefix = chainId.toString() + '0x';\n  }\n\n  var hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\nvar isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\n\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\nvar generateAddress = function (from, nonce) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(nonce);\n  var nonceBN = new externals_1.BN(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return (0, hash_1.rlphash)([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return (0, hash_1.rlphash)([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\nvar generateAddress2 = function (from, salt, initCode) {\n  (0, helpers_1.assertIsBuffer)(from);\n  (0, helpers_1.assertIsBuffer)(salt);\n  (0, helpers_1.assertIsBuffer)(initCode);\n  (0, assert_1.default)(from.length === 20);\n  (0, assert_1.default)(salt.length === 32);\n  var address = (0, hash_1.keccak256)(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, (0, hash_1.keccak256)(initCode)]));\n  return address.slice(-20);\n};\n\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\nvar isValidPrivate = function (privateKey) {\n  return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\n\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\nvar isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  (0, helpers_1.assertIsBuffer)(publicKey);\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\n\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\nvar pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  (0, helpers_1.assertIsBuffer)(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n  }\n\n  (0, assert_1.default)(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return (0, hash_1.keccak)(pubKey).slice(-20);\n};\n\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nvar privateToPublic = function (privateKey) {\n  (0, helpers_1.assertIsBuffer)(privateKey); // skip the type flag and use the X, Y points\n\n  return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\n\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nvar privateToAddress = function (privateKey) {\n  return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\n\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */\n\nvar importPublic = function (publicKey) {\n  (0, helpers_1.assertIsBuffer)(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n  }\n\n  return publicKey;\n};\n\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */\n\nvar zeroAddress = function () {\n  var addressLength = 20;\n  var addr = (0, bytes_1.zeros)(addressLength);\n  return (0, bytes_1.bufferToHex)(addr);\n};\n\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */\n\nvar isZeroAddress = function (hexAddress) {\n  try {\n    (0, helpers_1.assertIsString)(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  var zeroAddr = (0, exports.zeroAddress)();\n  return zeroAddr === hexAddress;\n};\n\nexports.isZeroAddress = isZeroAddress;","map":{"version":3,"mappings":"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","names":["nonce","balance","stateRoot","codeHash","externals_1","constants_1","_validate","Account","accountData","undefined","serialized","values","decode","Array","isArray","Error","fromValuesArray","lt","length","encode","raw","equals","isZero","exports","isValidAddress","hexAddress","e","test","toChecksumAddress","eip1191ChainId","address","toLowerCase","prefix","chainId","types_1","BN","toString","hash","ret","i","parseInt","toUpperCase","isValidChecksumAddress","generateAddress","from","nonceBN","slice","Buffer","toArray","generateAddress2","salt","initCode","concat","isValidPrivate","privateKey","isValidPublic","publicKey","sanitize","pubToAddress","pubKey","privateToPublic","privateToAddress","importPublic","zeroAddress","addressLength","addr","isZeroAddress","zeroAddr"],"sourceRoot":"","sources":["../src/account.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}