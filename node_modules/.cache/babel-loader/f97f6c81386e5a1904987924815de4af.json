{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nativizeAccessList = exports.unsafeNativize = exports.unsafeNativizeVariables = exports.ResultInspector = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:format:utils:inspect\");\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst Format = __importStar(require(\"../common\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst EvmUtils = __importStar(require(\"../../evm/utils\"));\n\nconst Exception = __importStar(require(\"./exception\")); //HACK?\n\n\nfunction cleanStylize(options) {\n  const clonedOptions = Object.assign({}, options);\n  delete clonedOptions.stylize;\n  return clonedOptions;\n}\n/**\n * This class is meant to be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * function.  Given a [[Format.Values.Result]] `value`, one can use\n * `new ResultInspector(value)` to create a ResultInspector for that value,\n * which can be used with util.inspect() to create a human-readable string\n * representing the value.\n *\n * @example\n * Suppose `value` is a Result.  In Node, the following would print to the\n * console a human-readable representation of `value`, with colors enabled,\n * no maximum depth, and no maximum array length, and lines (usually) no\n * longer than 80 characters:\n * ```javascript\n * console.log(\n *   util.inspect(\n *     new ResultInspector(value),\n *     {\n *       colors: true,\n *       depth: null,\n *       maxArrayLength: null,\n *       breakLength: 80\n *     }\n *   )\n * );\n * ```\n * Of course, there are many other ways to use util.inspect; see Node's\n * documentation, linked above, for more.\n */\n\n\nclass ResultInspector {\n  constructor(result) {\n    this.result = result;\n  }\n  /**\n   * @dev non-standard alternative interface name used by browser-util-inspect\n   *      package\n   */\n\n\n  inspect(depth, options) {\n    return this[util_1.default.inspect.custom].bind(this)(depth, options);\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.result.kind) {\n      case \"value\":\n        switch (this.result.type.typeClass) {\n          case \"uint\":\n          case \"int\":\n            return options.stylize(this.result.value.asBN.toString(), \"number\");\n\n          case \"fixed\":\n          case \"ufixed\":\n            //note: because this is just for display, we don't bother adjusting the magic values Big.NE or Big.PE;\n            //we'll trust those to their defaults\n            return options.stylize(this.result.value.asBig.toString(), \"number\");\n\n          case \"bool\":\n            return util_1.default.inspect(this.result.value.asBoolean, options);\n\n          case \"bytes\":\n            let hex = this.result.value.asHex;\n\n            switch (this.result.type.kind) {\n              case \"static\":\n                return options.stylize(hex, \"number\");\n\n              case \"dynamic\":\n                return options.stylize(`hex'${hex.slice(2)}'`, \"string\");\n            }\n\n          case \"address\":\n            return options.stylize(this.result.value.asAddress, \"number\");\n\n          case \"string\":\n            {\n              let coercedResult = this.result;\n\n              switch (coercedResult.value.kind) {\n                case \"valid\":\n                  return util_1.default.inspect(coercedResult.value.asString, options);\n\n                case \"malformed\":\n                  //note: this will turn malformed utf-8 into replacement characters (U+FFFD)\n                  //note we need to cut off the 0x prefix\n                  return util_1.default.inspect(Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString());\n              }\n            }\n\n          case \"array\":\n            {\n              let coercedResult = this.result;\n\n              if (coercedResult.reference !== undefined) {\n                return formatCircular(coercedResult.reference, options);\n              }\n\n              return util_1.default.inspect(coercedResult.value.map(element => new ResultInspector(element)), options);\n            }\n\n          case \"mapping\":\n            return util_1.default.inspect(new Map(this.result.value.map(_ref => {\n              let {\n                key,\n                value\n              } = _ref;\n              return [new ResultInspector(key), new ResultInspector(value)];\n            })), options);\n\n          case \"struct\":\n            {\n              let coercedResult = this.result;\n\n              if (coercedResult.reference !== undefined) {\n                return formatCircular(coercedResult.reference, options);\n              }\n\n              return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(_ref2 => {\n                let {\n                  name,\n                  value\n                } = _ref2;\n                return {\n                  [name]: new ResultInspector(value)\n                };\n              })), options);\n            }\n\n          case \"userDefinedValueType\":\n            {\n              const typeName = Format.Types.typeStringWithoutLocation(this.result.type);\n              const coercedResult = this.result;\n              const inspectOfUnderlying = util_1.default.inspect(new ResultInspector(coercedResult.value), options);\n              return `${typeName}.wrap(${inspectOfUnderlying})`; //note only the underlying part is stylized\n            }\n\n          case \"tuple\":\n            {\n              let coercedResult = this.result; //if everything is named, do same as with struct.\n              //if not, just do an array.\n              //(good behavior in the mixed case is hard, unfortunately)\n\n              if (coercedResult.value.every(_ref3 => {\n                let {\n                  name\n                } = _ref3;\n                return name;\n              })) {\n                return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(_ref4 => {\n                  let {\n                    name,\n                    value\n                  } = _ref4;\n                  return {\n                    [name]: new ResultInspector(value)\n                  };\n                })), options);\n              } else {\n                return util_1.default.inspect(coercedResult.value.map(_ref5 => {\n                  let {\n                    value\n                  } = _ref5;\n                  return new ResultInspector(value);\n                }), options);\n              }\n            }\n\n          case \"type\":\n            {\n              switch (this.result.type.type.typeClass) {\n                case \"contract\":\n                  //same as struct case but w/o circularity check\n                  return util_1.default.inspect(Object.assign({}, ...this.result.value.map(_ref6 => {\n                    let {\n                      name,\n                      value\n                    } = _ref6;\n                    return {\n                      [name]: new ResultInspector(value)\n                    };\n                  })), options);\n\n                case \"enum\":\n                  {\n                    return enumTypeName(this.result.type.type);\n                  }\n              }\n            }\n\n          case \"magic\":\n            return util_1.default.inspect(Object.assign({}, ...Object.entries(this.result.value).map(_ref7 => {\n              let [key, value] = _ref7;\n              return {\n                [key]: new ResultInspector(value)\n              };\n            })), options);\n\n          case \"enum\":\n            {\n              return enumFullName(this.result); //not stylized\n            }\n\n          case \"contract\":\n            {\n              return util_1.default.inspect(new ContractInfoInspector(this.result.value), options);\n            }\n\n          case \"function\":\n            switch (this.result.type.visibility) {\n              case \"external\":\n                {\n                  let coercedResult = this.result;\n                  let contractString = util_1.default.inspect(new ContractInfoInspector(coercedResult.value.contract), Object.assign(Object.assign({}, cleanStylize(options)), {\n                    colors: false\n                  }));\n                  let firstLine;\n\n                  switch (coercedResult.value.kind) {\n                    case \"known\":\n                      firstLine = `[Function: ${coercedResult.value.abi.name} of`;\n                      break;\n\n                    case \"invalid\":\n                    case \"unknown\":\n                      firstLine = `[Function: Unknown selector ${coercedResult.value.selector} of`;\n                      break;\n                  }\n\n                  let secondLine = `${contractString}]`;\n                  let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \"; //now, put it together\n\n                  return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                }\n\n              case \"internal\":\n                {\n                  let coercedResult = this.result;\n\n                  switch (coercedResult.value.kind) {\n                    case \"function\":\n                      if (coercedResult.value.definedIn) {\n                        return options.stylize(`[Function: ${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}]`, \"special\");\n                      } else {\n                        return options.stylize(`[Function: ${coercedResult.value.name}]`, \"special\");\n                      }\n\n                    case \"exception\":\n                      return coercedResult.value.deployedProgramCounter === 0 ? options.stylize(`[Function: <zero>]`, \"special\") : options.stylize(`[Function: <uninitialized>]`, \"special\");\n\n                    case \"unknown\":\n                      let firstLine = `[Function: decoding not supported (raw info:`;\n                      let secondLine = `deployed PC=${coercedResult.value.deployedProgramCounter}, constructor PC=${coercedResult.value.constructorProgramCounter})]`;\n                      let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \"; //now, put it together\n\n                      return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                  }\n                }\n            }\n\n        }\n\n      case \"error\":\n        {\n          debug(\"this.result: %O\", this.result);\n          let errorResult = this.result; //the hell?? why couldn't it make this inference??\n\n          switch (errorResult.error.kind) {\n            case \"WrappedError\":\n              return util_1.default.inspect(new ResultInspector(errorResult.error.error), options);\n\n            case \"UintPaddingError\":\n              return `Uint has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"IntPaddingError\":\n              return `Int has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"UintPaddingError\":\n              return `Ufixed has (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"FixedPaddingError\":\n              return `Fixed has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"BoolOutOfRangeError\":\n              return `Invalid boolean (numeric value ${errorResult.error.rawAsBN.toString()})`;\n\n            case \"BoolPaddingError\":\n              return `Boolean has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"BytesPaddingError\":\n              return `Bytestring has extra trailing bytes (padding error) (raw value ${errorResult.error.raw})`;\n\n            case \"AddressPaddingError\":\n              return `Address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"EnumOutOfRangeError\":\n              return `Invalid ${enumTypeName(errorResult.error.type)} (numeric value ${errorResult.error.rawAsBN.toString()})`;\n\n            case \"EnumPaddingError\":\n              return `Enum ${enumTypeName(errorResult.error.type)} has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"EnumNotFoundDecodingError\":\n              return `Unknown enum type ${enumTypeName(errorResult.error.type)} of id ${errorResult.error.type.id} (numeric value ${errorResult.error.rawAsBN.toString()})`;\n\n            case \"ContractPaddingError\":\n              return `Contract address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"FunctionExternalNonStackPaddingError\":\n              return `External function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"FunctionExternalStackPaddingError\":\n              return `External function address or selector has extra leading bytes (padding error) (raw address ${errorResult.error.rawAddress}, raw selector ${errorResult.error.rawSelector})`;\n\n            case \"FunctionInternalPaddingError\":\n              return `Internal function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"NoSuchInternalFunctionError\":\n              return `Invalid function (Deployed PC=${errorResult.error.deployedProgramCounter}, constructor PC=${errorResult.error.constructorProgramCounter}) of contract ${errorResult.error.context.typeName}`;\n\n            case \"DeployedFunctionInConstructorError\":\n              return `Deployed-style function (PC=${errorResult.error.deployedProgramCounter}) in constructor`;\n\n            case \"MalformedInternalFunctionError\":\n              return `Malformed internal function w/constructor PC only (value: ${errorResult.error.constructorProgramCounter})`;\n\n            case \"IndexedReferenceTypeError\":\n              //for this one we'll bother with some line-wrapping\n              let firstLine = `Cannot decode indexed parameter of reference type ${errorResult.error.type.typeClass}`;\n              let secondLine = `(raw value ${errorResult.error.raw})`;\n              let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \";\n              return firstLine + breakingSpace + secondLine;\n\n            case \"OverlongArraysAndStringsNotImplementedError\":\n              return `Array or string is too long (length ${errorResult.error.lengthAsBN.toString()}); decoding is not supported`;\n\n            case \"OverlargePointersNotImplementedError\":\n              return `Pointer is too large (value ${errorResult.error.pointerAsBN.toString()}); decoding is not supported`;\n\n            case \"UserDefinedTypeNotFoundError\":\n            case \"UnsupportedConstantError\":\n            case \"UnusedImmutableError\":\n            case \"ReadErrorStack\":\n            case \"ReadErrorStorage\":\n            case \"ReadErrorBytes\":\n              return Exception.message(errorResult.error);\n            //yay, these five are already defined!\n\n            case \"StorageNotSuppliedError\":\n            case \"CodeNotSuppliedError\":\n              //this latter one is not used at present\n              //these ones have a message, but we're going to special-case it\n              return options.stylize(\"?\", \"undefined\");\n          }\n        }\n    }\n  }\n\n}\n\nexports.ResultInspector = ResultInspector; //these get their own class to deal with a minor complication\n\nclass ContractInfoInspector {\n  constructor(value) {\n    this.value = value;\n  }\n  /**\n   * @dev non-standard alternative interface name used by browser-util-inspect\n   *      package\n   */\n\n\n  inspect(depth, options) {\n    return this[util_1.default.inspect.custom].bind(this)(depth, options);\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.value.kind) {\n      case \"known\":\n        return options.stylize(this.value.address, \"number\") + ` (${this.value.class.typeName})`;\n\n      case \"unknown\":\n        return options.stylize(this.value.address, \"number\") + \" of unknown class\";\n    }\n  }\n\n}\n\nfunction enumTypeName(enumType) {\n  return (enumType.kind === \"local\" ? enumType.definingContractName + \".\" : \"\") + enumType.typeName;\n} //this function will be used in the future for displaying circular\n//structures\n\n\nfunction formatCircular(loopLength, options) {\n  return options.stylize(`[Circular (=up ${loopLength})]`, \"special\");\n}\n\nfunction enumFullName(value) {\n  switch (value.type.kind) {\n    case \"local\":\n      return `${value.type.definingContractName}.${value.type.typeName}.${value.value.name}`;\n\n    case \"global\":\n      return `${value.type.typeName}.${value.value.name}`;\n  }\n}\n/**\n * WARNING! Do NOT use this function in real code unless you\n * absolutely have to!  Using it in controlled tests is fine,\n * but do NOT use it in real code if you have any better option!\n * See [[unsafeNativize]] for why!\n */\n\n\nfunction unsafeNativizeVariables(variables) {\n  return Object.assign({}, ...Object.entries(variables).map(_ref8 => {\n    let [name, value] = _ref8;\n\n    try {\n      return {\n        [name]: unsafeNativize(value)\n      };\n    } catch (_) {\n      return undefined; //I guess??\n    }\n  }));\n}\n\nexports.unsafeNativizeVariables = unsafeNativizeVariables; //HACK! Avoid using!\n\n/**\n * WARNING! Do NOT use this function in real code unless you absolutely have\n * to!  Using it in controlled tests is fine, but do NOT use it in real code if\n * you have any better option!\n *\n * This function is a giant hack.  It will throw exceptions on numbers that\n * don't fit in a Javascript number.  It loses various information.  It was\n * only ever written to support our hacked-together watch expression system,\n * and later repurposed to make testing easier.\n *\n * If you are not doing something as horrible as evaluating user-inputted\n * Javascript expressions meant to operate upon Solidity variables, then you\n * probably have a better option than using this in real code!\n *\n * (For instance, if you just want to nicely print individual values, without\n * attempting to first operate on them via Javascript expressions, we have the\n * [[ResultInspector]] class, which can be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * to do exactly that.)\n *\n * Remember, the decoder output format was made to be machine-readable.  It\n * shouldn't be too hard for you to process.  If it comes to it, copy-paste\n * this code and dehackify it for your use case, which hopefully is more\n * manageable than the one that caused us to write this.\n */\n\nfunction unsafeNativize(result) {\n  return unsafeNativizeWithTable(result, []);\n}\n\nexports.unsafeNativize = unsafeNativize;\n\nfunction unsafeNativizeWithTable(result, seenSoFar) {\n  if (result.kind === \"error\") {\n    debug(\"ErrorResult: %O\", result);\n\n    switch (result.error.kind) {\n      case \"BoolOutOfRangeError\":\n        return true;\n\n      default:\n        return undefined;\n    }\n  } //NOTE: for simplicity, only arrays & structs will call unsafeNativizeWithTable;\n  //other containers will just call unsafeNativize because they can get away with it\n  //(only things that can *be* circular need unsafeNativizeWithTable, not things that\n  //can merely *contain* circularities)\n\n\n  switch (result.type.typeClass) {\n    case \"uint\":\n    case \"int\":\n      return result.value.asBN.toNumber();\n    //WARNING\n\n    case \"bool\":\n      return result.value.asBoolean;\n\n    case \"bytes\":\n      return result.value.asHex;\n\n    case \"address\":\n      return result.value.asAddress;\n\n    case \"string\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.value.kind) {\n          case \"valid\":\n            return coercedResult.value.asString;\n\n          case \"malformed\":\n            // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n            // note we need to cut off the 0x prefix\n            return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n        }\n      }\n\n    case \"fixed\":\n    case \"ufixed\":\n      //HACK: Big doesn't have a toNumber() method, so we convert to string and then parse with Number\n      //NOTE: we don't bother setting the magic variables Big.NE or Big.PE first, as the choice of\n      //notation shouldn't affect the result (can you believe I have to write this? @_@)\n      return Number(result.value.asBig.toString());\n    //WARNING\n\n    case \"array\":\n      {\n        let coercedResult = result;\n\n        if (coercedResult.reference === undefined) {\n          //we need to do some pointer stuff here, so let's first create our new\n          //object we'll be pointing to\n          //[we don't want to alter the original accidentally so let's clone a bit]\n          let output = [...coercedResult.value]; //now, we can't use a map here, or we'll screw things up!\n          //we want to *mutate* output, not replace it with a new object\n\n          for (let index = 0; index < output.length; index++) {\n            output[index] = unsafeNativizeWithTable(output[index], [output, ...seenSoFar]);\n          }\n\n          return output;\n        } else {\n          return seenSoFar[coercedResult.reference - 1];\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        return unsafeNativize(result.value);\n      }\n\n    case \"mapping\":\n      return Object.assign({}, ...result.value.map(_ref9 => {\n        let {\n          key,\n          value\n        } = _ref9;\n        return {\n          [unsafeNativize(key).toString()]: unsafeNativize(value)\n        };\n      }));\n\n    case \"struct\":\n      {\n        let coercedResult = result;\n\n        if (coercedResult.reference === undefined) {\n          //we need to do some pointer stuff here, so let's first create our new\n          //object we'll be pointing to\n          let output = Object.assign({}, ...result.value.map(_ref10 => {\n            let {\n              name,\n              value\n            } = _ref10;\n            return {\n              [name]: value //we *don't* nativize yet!\n\n            };\n          })); //now, we can't use a map here, or we'll screw things up!\n          //we want to *mutate* output, not replace it with a new object\n\n          for (let name in output) {\n            output[name] = unsafeNativizeWithTable(output[name], [output, ...seenSoFar]);\n          }\n\n          return output;\n        } else {\n          return seenSoFar[coercedResult.reference - 1];\n        }\n      }\n\n    case \"type\":\n      switch (result.type.type.typeClass) {\n        case \"contract\":\n          return Object.assign({}, ...result.value.map(_ref11 => {\n            let {\n              name,\n              value\n            } = _ref11;\n            return {\n              [name]: unsafeNativize(value)\n            };\n          }));\n\n        case \"enum\":\n          return Object.assign({}, ...result.value.map(enumValue => ({\n            [enumValue.value.name]: unsafeNativize(enumValue)\n          })));\n      }\n\n    case \"tuple\":\n      return result.value.map(_ref12 => {\n        let {\n          value\n        } = _ref12;\n        return unsafeNativize(value);\n      });\n\n    case \"magic\":\n      return Object.assign({}, ...Object.entries(result.value).map(_ref13 => {\n        let [key, value] = _ref13;\n        return {\n          [key]: unsafeNativize(value)\n        };\n      }));\n\n    case \"enum\":\n      return enumFullName(result);\n\n    case \"contract\":\n      return result.value.address;\n    //we no longer include additional info\n\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"known\":\n                return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).${coercedResult.value.abi.name}`;\n\n              case \"invalid\":\n                return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).call(${coercedResult.value.selector}...)`;\n\n              case \"unknown\":\n                return `${coercedResult.value.contract.address}.call(${coercedResult.value.selector}...)`;\n            }\n          }\n\n        case \"internal\":\n          {\n            let coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"function\":\n                if (coercedResult.value.definedIn) {\n                  return `${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}`;\n                } else {\n                  return coercedResult.value.name;\n                }\n\n              case \"exception\":\n                return coercedResult.value.deployedProgramCounter === 0 ? `<zero>` : `<uninitialized>`;\n\n              case \"unknown\":\n                return `<decoding not supported>`;\n            }\n          }\n      }\n\n  }\n}\n/**\n * Turns a wrapped access list into a usable form.\n * Will fail if the input is not a wrapped access list!\n * Note that the storage keys must be given as uint256, not bytes32.\n * Primarily meant for internal use.\n */\n\n\nfunction nativizeAccessList(wrappedAccessList //this should really be a more specific type\n) {\n  return wrappedAccessList.value.map(wrappedAccessListForAddress => {\n    //HACK: we're just going to coerce all over the place here\n    const addressStorageKeysPair = wrappedAccessListForAddress.value;\n    const wrappedAddress = addressStorageKeysPair[0].value;\n    const wrappedStorageKeys = addressStorageKeysPair[1].value;\n    const wrappedStorageKeysArray = wrappedStorageKeys.value;\n    return {\n      address: wrappedAddress.value.asAddress,\n      storageKeys: wrappedStorageKeysArray.map(wrappedStorageKey => Conversion.toHexString(wrappedStorageKey.value.asBN, EvmUtils.WORD_SIZE))\n    };\n  });\n}\n\nexports.nativizeAccessList = nativizeAccessList;","map":{"version":3,"mappings":"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","names":["debug","cleanStylize","options","clonedOptions","stylize","ResultInspector","constructor","result","inspect","depth","util_1","custom","bind","kind","type","typeClass","value","asBN","toString","asBig","asBoolean","hex","asHex","slice","asAddress","coercedResult","asString","Buffer","from","reference","undefined","formatCircular","map","element","Map","key","Object","assign","name","typeName","Format","Types","typeStringWithoutLocation","inspectOfUnderlying","every","enumTypeName","entries","enumFullName","ContractInfoInspector","visibility","contractString","contract","colors","firstLine","abi","selector","secondLine","breakingSpace","length","breakLength","definedIn","deployedProgramCounter","constructorProgramCounter","errorResult","error","paddingType","raw","rawAsBN","id","rawAddress","rawSelector","context","lengthAsBN","pointerAsBN","Exception","message","exports","address","class","enumType","definingContractName","loopLength","unsafeNativizeVariables","variables","unsafeNativize","_","unsafeNativizeWithTable","seenSoFar","toNumber","Number","output","index","enumValue","nativizeAccessList","wrappedAccessList","wrappedAccessListForAddress","addressStorageKeysPair","wrappedAddress","wrappedStorageKeys","wrappedStorageKeysArray","storageKeys","wrappedStorageKey","Conversion","toHexString","EvmUtils","WORD_SIZE"],"sourceRoot":"","sources":["../../../../lib/format/utils/inspect.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}