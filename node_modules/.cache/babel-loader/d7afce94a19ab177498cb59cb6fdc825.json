{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeTupleAbiWithSelector = exports.encodeTupleAbi = exports.encodeAbi = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:abi-data:encode\");\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst sum_1 = __importDefault(require(\"lodash/sum\")); //UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n\n/**\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeAbi(input, allocations) {\n  //errors can't be encoded\n  if (input.kind === \"error\") {\n    return undefined;\n  }\n\n  let bytes; //TypeScript can at least infer in the rest of this that we're looking\n  //at a value, not an error!  But that's hardly enough...\n\n  switch (input.type.typeClass) {\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n      //none of these can go in the ABI\n      return undefined;\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return Basic.Encode.encodeBasic(input);\n\n        case \"dynamic\":\n          bytes = Bytes.Encode.encodeBytes(input);\n          return padAndPrependLength(bytes);\n      }\n\n    case \"string\":\n      bytes = Bytes.Encode.encodeBytes(input);\n      return padAndPrependLength(bytes);\n\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          case \"internal\":\n            return undefined;\n          //internal functions can't go in the ABI!\n          //Yes, technically we could defer to encodeBasic here, but,\n          //c'mon, that's not how the function's supposed to be used\n\n          case \"external\":\n            return Basic.Encode.encodeBasic(input);\n        }\n      }\n    //now for the serious cases\n\n    case \"array\":\n      {\n        let coercedInput = input;\n\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        let staticEncoding = encodeTupleAbi(coercedInput.value, allocations);\n\n        switch (input.type.kind) {\n          case \"static\":\n            return staticEncoding;\n\n          case \"dynamic\":\n            let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length\n\n            encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand\n\n            let lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);\n            encoded.set(lengthBytes); //and now we set the length\n\n            return encoded;\n        }\n      }\n\n    case \"struct\":\n      {\n        let coercedInput = input;\n\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        return encodeTupleAbi(coercedInput.value.map(_ref => {\n          let {\n            value\n          } = _ref;\n          return value;\n        }), allocations);\n      }\n\n    case \"tuple\":\n      //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n      //(That may not be apparent from this one line, but it's true)\n      //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder\n      //However it may be worth revisiting this in the future if performance turns out to be a problem\n      return encodeTupleAbi(input.value.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      }), allocations);\n\n    default:\n      return Basic.Encode.encodeBasic(input);\n  }\n}\n\nexports.encodeAbi = encodeAbi;\n/**\n * @Category Encoding (low-level)\n */\n\nfunction padAndPrependLength(bytes) {\n  let length = bytes.length;\n  let paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);\n  let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);\n  encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand\n\n  let lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);\n  encoded.set(lengthBytes); //and now we set the length\n\n  return encoded;\n}\n/**\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeTupleAbi(tuple, allocations) {\n  let elementEncodings = tuple.map(element => encodeAbi(element, allocations));\n\n  if (elementEncodings.some(element => element === undefined)) {\n    return undefined;\n  }\n\n  let elementSizeInfo = tuple.map(element => (0, allocate_1.abiSizeInfo)(element.type, allocations)); //heads and tails here are as discussed in the ABI docs;\n  //for a static type the head is the encoding and the tail is empty,\n  //for a dynamic type the head is the pointer and the tail is the encoding\n\n  let heads = [];\n  let tails = []; //but first, we need to figure out where the first tail will start,\n  //by adding up the sizes of all the heads (we can easily do this in\n  //advance via elementSizeInfo, without needing to know the particular\n  //values of the heads)\n\n  let startOfNextTail = (0, sum_1.default)(elementSizeInfo.map(elementInfo => elementInfo.size));\n\n  for (let i = 0; i < tuple.length; i++) {\n    let head;\n    let tail;\n\n    if (!elementSizeInfo[i].dynamic) {\n      //static case\n      head = elementEncodings[i];\n      tail = new Uint8Array(); //empty array\n    } else {\n      //dynamic case\n      head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);\n      tail = elementEncodings[i];\n    }\n\n    heads.push(head);\n    tails.push(tail);\n    startOfNextTail += tail.length;\n  } //finally, we need to concatenate everything together!\n  //since we're dealing with Uint8Arrays, we have to do this manually\n\n\n  let totalSize = startOfNextTail;\n  let encoded = new Uint8Array(totalSize);\n  let position = 0;\n\n  for (let head of heads) {\n    encoded.set(head, position);\n    position += head.length;\n  }\n\n  for (let tail of tails) {\n    encoded.set(tail, position);\n    position += tail.length;\n  }\n\n  return encoded;\n}\n\nexports.encodeTupleAbi = encodeTupleAbi;\n/**\n * @Category Encoding (low-level)\n */\n\nfunction encodeTupleAbiWithSelector(tuple, selector, allocations) {\n  const encodedTuple = encodeTupleAbi(tuple, allocations);\n\n  if (!encodedTuple) {\n    return undefined;\n  }\n\n  const encoded = new Uint8Array(selector.length + encodedTuple.length);\n  encoded.set(selector);\n  encoded.set(encodedTuple, selector.length);\n  return encoded;\n}\n\nexports.encodeTupleAbiWithSelector = encodeTupleAbiWithSelector;","map":{"version":3,"mappings":"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","names":["debug","encodeAbi","input","allocations","kind","undefined","bytes","type","typeClass","Basic","Encode","encodeBasic","Bytes","encodeBytes","padAndPrependLength","visibility","coercedInput","reference","staticEncoding","encodeTupleAbi","value","encoded","Uint8Array","Evm","Utils","WORD_SIZE","length","set","lengthBytes","Conversion","toBytes","map","exports","paddedLength","Math","ceil","tuple","elementEncodings","element","some","elementSizeInfo","heads","tails","startOfNextTail","elementInfo","size","i","head","tail","dynamic","push","totalSize","position","encodeTupleAbiWithSelector","selector","encodedTuple"],"sourceRoot":"","sources":["../../../../lib/abi-data/encode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}