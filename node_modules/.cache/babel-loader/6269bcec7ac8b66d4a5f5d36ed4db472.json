{"ast":null,"code":"\"use strict\";\n/**\n * Contains the types for type objects, and some\n * functions for working with them.\n *\n * @category Main Format\n *\n * @packageDocumentation\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = exports.forgetCompilations = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:format:types\");\n\nfunction forgetCompilations(typesByCompilation) {\n  return Object.assign({}, ...Object.values(typesByCompilation).map(_ref => {\n    let {\n      types\n    } = _ref;\n    return types;\n  }));\n}\n\nexports.forgetCompilations = forgetCompilations;\n\nfunction isUserDefinedType(anyType) {\n  const userDefinedTypes = [\"contract\", \"enum\", \"struct\", \"userDefinedValueType\"];\n  return userDefinedTypes.includes(anyType.typeClass);\n}\n\nfunction isReferenceType(anyType) {\n  const alwaysReferenceTypes = [\"array\", \"mapping\", \"struct\", \"string\"];\n\n  if (alwaysReferenceTypes.includes(anyType.typeClass)) {\n    return true;\n  } else if (anyType.typeClass === \"bytes\") {\n    return anyType.kind === \"dynamic\";\n  } else {\n    return false;\n  }\n}\n\nexports.isReferenceType = isReferenceType; //one could define a counterpart function that stripped all unnecessary information\n//from the type object, but at the moment I see no need for that\n\nfunction fullType(basicType, userDefinedTypes) {\n  if (!isUserDefinedType(basicType)) {\n    return basicType;\n  }\n\n  let id = basicType.id;\n  let storedType = userDefinedTypes[id];\n\n  if (!storedType) {\n    return basicType;\n  }\n\n  let returnType = Object.assign(Object.assign({}, basicType), storedType);\n\n  if (isReferenceType(basicType) && basicType.location !== undefined) {\n    returnType = specifyLocation(returnType, basicType.location);\n  }\n\n  return returnType;\n}\n\nexports.fullType = fullType; //the location argument here always forces, so passing undefined *will* force undefined\n\nfunction specifyLocation(dataType, location) {\n  if (isReferenceType(dataType)) {\n    switch (dataType.typeClass) {\n      case \"string\":\n      case \"bytes\":\n        return Object.assign(Object.assign({}, dataType), {\n          location\n        });\n\n      case \"array\":\n        return Object.assign(Object.assign({}, dataType), {\n          location,\n          baseType: specifyLocation(dataType.baseType, location)\n        });\n\n      case \"mapping\":\n        let newLocation = location === \"storage\" ? \"storage\" : undefined;\n        return Object.assign(Object.assign({}, dataType), {\n          location: newLocation,\n          valueType: specifyLocation(dataType.valueType, newLocation)\n        });\n\n      case \"struct\":\n        let returnType = Object.assign(Object.assign({}, dataType), {\n          location\n        });\n\n        if (returnType.memberTypes) {\n          returnType.memberTypes = returnType.memberTypes.map(_ref2 => {\n            let {\n              name: memberName,\n              type: memberType\n            } = _ref2;\n            return {\n              name: memberName,\n              type: specifyLocation(memberType, location)\n            };\n          });\n        }\n\n        return returnType;\n    }\n  } else {\n    return dataType;\n  }\n}\n\nexports.specifyLocation = specifyLocation; //NOTE: the following two functions might not be exactly right for weird internal stuff,\n//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things\n//are pointers or not??  we don't track that so we can't recreate that)\n//But what can you do.\n\nfunction typeString(dataType) {\n  let baseString = typeStringWithoutLocation(dataType);\n\n  if (isReferenceType(dataType) && dataType.location) {\n    return baseString + \" \" + dataType.location;\n  } else {\n    return baseString;\n  }\n}\n\nexports.typeString = typeString;\n\nfunction typeStringWithoutLocation(dataType) {\n  switch (dataType.typeClass) {\n    case \"uint\":\n      return dataType.typeHint || `uint${dataType.bits}`;\n\n    case \"int\":\n      return dataType.typeHint || `int${dataType.bits}`;\n\n    case \"bool\":\n      return dataType.typeHint || \"bool\";\n\n    case \"bytes\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return \"bytes\";\n\n        case \"static\":\n          return `bytes${dataType.length}`;\n      }\n\n    case \"address\":\n      switch (dataType.kind) {\n        case \"general\":\n          return dataType.typeHint || \"address\";\n        //I guess?\n\n        case \"specific\":\n          return dataType.payable ? \"address payable\" : \"address\";\n      }\n\n    case \"string\":\n      return dataType.typeHint || \"string\";\n\n    case \"fixed\":\n      return dataType.typeHint || `fixed${dataType.bits}x${dataType.places}`;\n\n    case \"ufixed\":\n      return dataType.typeHint || `ufixed${dataType.bits}x${dataType.places}`;\n\n    case \"array\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return `${typeStringWithoutLocation(dataType.baseType)}[]`;\n\n        case \"static\":\n          return `${typeStringWithoutLocation(dataType.baseType)}[${dataType.length}]`;\n      }\n\n    case \"mapping\":\n      return `mapping(${typeStringWithoutLocation(dataType.keyType)} => ${typeStringWithoutLocation(dataType.valueType)})`;\n\n    case \"struct\":\n    case \"enum\":\n      //combining these cases for simplicity\n      switch (dataType.kind) {\n        case \"local\":\n          return `${dataType.typeClass} ${dataType.definingContractName}.${dataType.typeName}`;\n\n        case \"global\":\n          return `${dataType.typeClass} ${dataType.typeName}`;\n      }\n\n      break;\n    //to satisfy TS :P\n\n    case \"userDefinedValueType\":\n      //differs from struct & enum in that typeClass is omitted\n      switch (dataType.kind) {\n        case \"local\":\n          return `${dataType.definingContractName}.${dataType.typeName}`;\n\n        case \"global\":\n          return `${dataType.typeName}`;\n      }\n\n      break;\n    //to satisfy TS :P\n\n    case \"tuple\":\n      return dataType.typeHint || \"tuple(\" + dataType.memberTypes.map(memberType => typeString(memberType.type)).join(\",\") + \")\";\n    //note that we do include location and do not put spaces\n\n    case \"contract\":\n      return dataType.contractKind + \" \" + dataType.typeName;\n\n    case \"magic\":\n      //no, this is not transposed!\n      const variableNames = {\n        message: \"msg\",\n        transaction: \"tx\",\n        block: \"block\"\n      };\n      return variableNames[dataType.variable];\n\n    case \"type\":\n      return `type(${typeString(dataType.type)})`;\n\n    case \"function\":\n      let visibilityString;\n\n      switch (dataType.visibility) {\n        case \"external\":\n          if (dataType.kind === \"general\") {\n            if (dataType.typeHint) {\n              return dataType.typeHint;\n            } else {\n              return \"function external\"; //I guess???\n            }\n          }\n\n          visibilityString = \" external\"; //note the deliberate space!\n\n          break;\n\n        case \"internal\":\n          visibilityString = \"\";\n          break;\n      }\n\n      let mutabilityString = dataType.mutability === \"nonpayable\" ? \"\" : \" \" + dataType.mutability; //again, note the deliberate space\n\n      let inputList = dataType.inputParameterTypes.map(typeString).join(\",\"); //note that we do include location, and do not put spaces\n\n      let outputList = dataType.outputParameterTypes.map(typeString).join(\",\");\n      let inputString = `function(${inputList})`;\n      let outputString = outputList === \"\" ? \"\" : ` returns (${outputList})`; //again, note the deliberate space\n\n      return inputString + mutabilityString + visibilityString + outputString;\n\n    case \"options\":\n      //note: not a real Solidity type! just for error messaging!\n      return \"options\";\n  }\n}\n\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n\nfunction isContractDefinedType(anyType) {\n  const contractDefinedTypes = [\"enum\", \"struct\", \"userDefinedValueType\"];\n  return contractDefinedTypes.includes(anyType.typeClass) && anyType.kind === \"local\";\n}\n\nexports.isContractDefinedType = isContractDefinedType;","map":{"version":3,"mappings":"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","names":["debug","forgetCompilations","typesByCompilation","Object","assign","values","map","types","exports","isUserDefinedType","anyType","userDefinedTypes","includes","typeClass","isReferenceType","alwaysReferenceTypes","kind","fullType","basicType","id","storedType","returnType","location","undefined","specifyLocation","dataType","baseType","newLocation","valueType","memberTypes","name","memberName","type","memberType","typeString","baseString","typeStringWithoutLocation","typeHint","bits","length","payable","places","keyType","definingContractName","typeName","join","contractKind","variableNames","message","transaction","block","variable","visibilityString","visibility","mutabilityString","mutability","inputList","inputParameterTypes","outputList","outputParameterTypes","inputString","outputString","isContractDefinedType","contractDefinedTypes"],"sourceRoot":"","sources":["../../../lib/format/types.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}