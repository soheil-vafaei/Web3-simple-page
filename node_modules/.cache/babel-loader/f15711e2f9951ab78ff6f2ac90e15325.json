{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrap = exports.udvtCases = exports.txOptionsCases = exports.tupleCases = exports.arrayCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:wrap\");\n\nconst Format = __importStar(require(\"../format\"));\n\nconst errors_1 = require(\"./errors\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst integer_1 = require(\"./integer\");\n\nconst decimal_1 = require(\"./decimal\");\n\nconst bool_1 = require(\"./bool\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst address_1 = require(\"./address\");\n\nconst string_1 = require(\"./string\");\n\nconst function_1 = require(\"./function\"); //this file contains the main wrap function, as well as the cases\n//for arrays, tuples, udvts, and tx options.  all other types get their\n//own file.\n\n\nconst arrayCasesBasic = [arrayFromArray, arrayFromCodecArrayValue, arrayFromJson, arrayFailureCase];\nexports.arrayCases = [arrayFromTypeValueInput, ...arrayCasesBasic];\nconst tupleCasesBasic = [tupleFromArray, tupleFromCodecTupleLikeValue, tupleFromObject, tupleFromJson, tupleFailureCase];\nexports.tupleCases = [tupleFromTypeValueInput, ...tupleCasesBasic];\nconst txOptionsCasesBasic = [optionsFromCodecOptionsValue, optionsFromObject, optionsFailureCase];\nexports.txOptionsCases = [optionsFromTypeValueInput, ...txOptionsCasesBasic];\nexports.udvtCases = [//no separate case for udvtFromUdvtValue,\n//since underlying already handles this\nudvtFromUnderlying];\n\nfunction* wrap(dataType, input, wrapOptions) {\n  if (!wrapOptions.name) {\n    wrapOptions = Object.assign(Object.assign({}, wrapOptions), {\n      name: \"<input>\"\n    });\n  }\n\n  switch (dataType.typeClass) {\n    case \"uint\":\n    case \"int\":\n    case \"enum\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, integer_1.integerCases);\n\n    case \"fixed\":\n    case \"ufixed\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, decimal_1.decimalCases);\n\n    case \"bool\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bool_1.boolCases);\n\n    case \"bytes\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bytes_1.bytesCases);\n\n    case \"address\":\n    case \"contract\":\n      //these are treated the same\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, address_1.addressCases);\n\n    case \"string\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, string_1.stringCases);\n\n    case \"function\":\n      //special check: weed out internal functions\n      if (dataType.visibility === \"internal\") {\n        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity\n        `Wrapping/encoding for internal function pointers is not supported`);\n      } //otherwise, go ahead\n\n\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, function_1.functionExternalCases);\n\n    case \"array\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.arrayCases);\n\n    case \"struct\":\n    case \"tuple\":\n      //these are treated the same as well\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.tupleCases);\n\n    case \"userDefinedValueType\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.udvtCases);\n\n    case \"options\":\n      return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.txOptionsCases);\n\n    default:\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity\n      `Wrapping/encoding for type ${Format.Types.typeStringWithoutLocation(dataType)} is not supported`);\n  }\n}\n\nexports.wrap = wrap; //array cases\n\nfunction* arrayFromArray(dataType, input, wrapOptions) {\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n\n  if (dataType.kind === \"static\" && !dataType.length.eqn(input.length)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(dataType.length, input.length));\n  } //can't do yield in a map, so manual loop here\n\n\n  let value = [];\n\n  for (let index = 0; index < input.length; index++) {\n    value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), {\n      name: `${wrapOptions.name}[${index}]`,\n      specificityFloor: 5 //errors in components are quite specific!\n\n    })));\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* arrayFromCodecArrayValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  } //we won't bother with detailed typechecking as much of it is handled\n  //either in the call to arrayFromArray or in the wrapping of the\n  //individual elements; we will check dynamic vs static though as that\n  //isn't handled elsewhere\n\n\n  if (!wrapOptions.loose && input.type.kind === dataType.kind) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  } //note that we do *not* just copy over input.value, but rather we\n  //defer to arrayFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n\n\n  const value = input.value;\n  return yield* arrayFromArray(dataType, value, wrapOptions);\n}\n\nfunction* arrayFromJson(dataType, input, wrapOptions) {\n  if (!wrapOptions.allowJson) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n  }\n\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  let parsedInput;\n\n  try {\n    parsedInput = JSON.parse(input);\n  } catch (error) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n  }\n\n  return yield* arrayFromArray(dataType, parsedInput, wrapOptions);\n}\n\nfunction* arrayFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"array\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //don't turn on loose here, only do that for non-container types!\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, arrayCasesBasic);\n}\n\nfunction* arrayFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, type/value pair or wrapped array\");\n} //tuple/struct cases;\n//note even with loose turned off, we won't distinguish\n//between tuples and structs\n\n\nfunction* tupleFromArray(dataType, input, wrapOptions) {\n  //first: obtain the types of the members\n  if (!Array.isArray(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not an array\");\n  }\n\n  debug(\"input is array\");\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n\n  if (memberTypes.length !== input.length) {\n    debug(\"input is wrong-length array\");\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(memberTypes.length, input.length));\n  } //can't do yield in a map, so manual loop here\n\n\n  let value = [];\n\n  for (let index = 0; index < input.length; index++) {\n    const memberName = memberTypes[index].name;\n    debug(\"wrapping %s\", memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), {\n        name: memberName ? wrapOptions.name.match(/^<.*>$/) //hack?\n        ? memberName : `${wrapOptions.name}.${memberName}` : `${wrapOptions.name}[${index}]`,\n        specificityFloor: 5\n      }))\n    });\n  } //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* tupleFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n\n  if (!wrapOptions.loose && Utils.isTypeValueInput(input)) {\n    //let's exclude these unless loose is turned on\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a type/value pair\");\n  }\n\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  }\n\n  const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);\n\n  if (memberTypes.some(_ref => {\n    let {\n      name\n    } = _ref;\n    return !name;\n  })) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, \"Plain object input is allowed only when all elements of tuple are named\");\n  }\n\n  let unusedKeys = new Set(Object.keys(input));\n  let value = [];\n\n  for (let index = 0; index < memberTypes.length; index++) {\n    //note we had better process these in order!\n    const memberName = memberTypes[index].name;\n\n    if (!(memberName in input)) {\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Missing key from tuple or struct: ${memberName}`);\n    }\n\n    unusedKeys.delete(memberName);\n    value.push({\n      name: memberName,\n      value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${memberName}`,\n        specificityFloor: 4 //not sure this warrants a 5\n\n      }))\n    });\n  }\n\n  if (!wrapOptions.loose) {\n    if (unusedKeys.size > 0) {\n      //choose one arbitrarily\n      const exampleKey = unusedKeys.values().next().value;\n      throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Unknown key ${exampleKey} included`);\n    }\n  } //we need to coerce here because TS doesn't know that if it's a struct\n  //then everything has a name\n\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* tupleFromJson(dataType, input, wrapOptions) {\n  if (!wrapOptions.allowJson) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"JSON input must be explicitly enabled\");\n  }\n\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  let parsedInput;\n\n  try {\n    parsedInput = JSON.parse(input);\n  } catch (error) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);\n  }\n\n  debug(\"input is JSON\");\n  debug(\"parses to: %O\", parsedInput);\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, parsedInput, wrapOptions, [tupleFromObject, tupleFromArray]);\n}\n\nfunction* tupleFromCodecTupleLikeValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"tuple\" && input.type.typeClass !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  } //not going to do much typechecking here as it'll be handled in the call\n  //to tupleFromArray\n  //Typescript complains if I try to say it can be either struct or\n  //tuple, so, uh, let's just tell it it's a tuple <shrug>\n\n\n  const coercedInput = input; //HACK!\n  //note that we do *not* just copy over input.value, but rather we\n  //defer to tupleFromArray; this is because there might be some elements\n  //where the type is not the same but is compatible\n\n  return yield* tupleFromArray(dataType, coercedInput.value.map(_ref2 => {\n    let {\n      value\n    } = _ref2;\n    return value;\n  }), wrapOptions);\n}\n\nfunction* tupleFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"tuple\" && input.type !== \"struct\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //don't turn on loose here, only do that for non-container types!\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, tupleCasesBasic);\n}\n\nfunction* tupleFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Input was not an array, plain object, type/value pair or wrapped tuple or struct\");\n}\n\nfunction memberTypesForType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    case \"tuple\":\n      return dataType.memberTypes;\n      break;\n\n    case \"struct\":\n      debug(\"wrapping for struct %s\", dataType.typeName);\n      return Format.Types.fullType(dataType, userDefinedTypes).memberTypes;\n  }\n} //udvt cases\n\n\nfunction* udvtFromUnderlying(dataType, input, wrapOptions) {\n  const {\n    underlyingType\n  } = Format.Types.fullType(dataType, wrapOptions.userDefinedTypes);\n  const value = yield* wrap(underlyingType, input, wrapOptions);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: value\n  };\n} //tx options cases\n\n\nfunction* optionsFromObject(dataType, input, wrapOptions) {\n  if (!Utils.isPlainObject(input)) {\n    //just checks that it's an object & not null\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a non-null object\");\n  }\n\n  debug(\"options input is object: %O\", input);\n  debug(\"wrapOptions: %O\", wrapOptions);\n\n  if (!wrapOptions.loose && Utils.isWrappedResult(input)) {\n    //similarly here\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was a wrapped result\");\n  } //now... the main case\n\n\n  let value = {};\n  const uintKeys = [\"gas\", \"gasPrice\", \"value\", \"nonce\", \"maxFeePerGas\", \"maxPriorityFeePerGas\"];\n  const uint8Keys = [\"type\"];\n  const addressKeys = [\"from\", \"to\"];\n  const bytesKeys = [\"data\"];\n  const boolKeys = [\"overwrite\"];\n  const accessListKeys = [\"accessList\"];\n  const specialKeys = [\"privateFor\"];\n  const allKeys = [...uintKeys, ...uint8Keys, ...addressKeys, ...bytesKeys, ...boolKeys, ...accessListKeys, ...specialKeys];\n  const badKey = Object.keys(input).find(key => !allKeys.includes(key));\n  const goodKey = Object.keys(input).find(key => allKeys.includes(key));\n\n  if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {\n    //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK\n    //to preserve existing behavior of Truffle Contract (perhaps we can\n    //change this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included unknown option ${badKey}`);\n  }\n\n  if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {\n    //similarly, if oldOptionsBehavior is on, we require at least\n    //one *legit* key (again, HACK to preserve existing behavior,\n    //maybe remove this in Truffle 6)\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included no recognized options`);\n  } //otherwise, if all keys are transaction options, let's process them...\n  //part 1: uint options\n\n\n  for (const key of uintKeys) {\n    //note we check input[key] !== undefined, rather than key in input,\n    //because if one of them is undefined we want to just allow that but ignore it\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"uint\",\n        bits: 256\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      value[key] = wrappedOption.value.asBN;\n    }\n  } //part 2: uint8 options (just type for now)\n\n\n  for (const key of uint8Keys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"uint\",\n        bits: 8\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), integer_1.integerCases);\n      const asBN = wrappedOption.value.asBN; //since this is just type right now, we're going to reject illegal types\n\n      if (asBN.gten(0xc0)) {\n        //not making a constant for this, this is its only use here\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.type`, 4, \"Transaction types must be less than 0xc0\");\n      } //for compatibility, we give type as a hex string rather than\n      //leaving it as a BN.  Since it's unsigned we don't have to\n      //worry about negatives.\n\n\n      value[key] = Conversion.toHexString(asBN);\n    }\n  } //part 3: address options\n\n\n  for (const key of addressKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"address\",\n        kind: \"general\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), address_1.addressCases);\n      value[key] = wrappedOption.value.asAddress;\n    }\n  } //part 4: bytestring options\n\n\n  for (const key of bytesKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"bytes\",\n        kind: \"dynamic\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bytes_1.bytesCases);\n      value[key] = wrappedOption.value.asHex;\n    }\n  } //part 5: boolean options\n\n\n  for (const key of boolKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"bool\"\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), bool_1.boolCases);\n      value[key] = wrappedOption.value.asBoolean;\n    }\n  } //part 6: the access list\n\n\n  for (const key of accessListKeys) {\n    if (input[key] !== undefined) {\n      const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({\n        typeClass: \"array\",\n        kind: \"dynamic\",\n        baseType: {\n          typeClass: \"tuple\",\n          memberTypes: [{\n            name: \"address\",\n            type: {\n              typeClass: \"address\",\n              kind: \"general\"\n            }\n          }, {\n            name: \"storageKeys\",\n            type: {\n              typeClass: \"array\",\n              kind: \"dynamic\",\n              baseType: {\n                //we use uint256 rather than bytes32 to allow\n                //abbreviating and left-padding\n                typeClass: \"uint\",\n                bits: 256\n              }\n            }\n          }]\n        }\n      }, input[key], Object.assign(Object.assign({}, wrapOptions), {\n        name: `${wrapOptions.name}.${key}`\n      }), exports.arrayCases);\n      value[key] = Format.Utils.Inspect.nativizeAccessList(wrappedOption);\n    }\n  } //part 7: the special case of privateFor\n\n\n  if (input.privateFor !== undefined) {\n    //this doesn't correspond to any of our usual types, so we have to handle it specially\n    if (!Array.isArray(input.privateFor)) {\n      throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, \"Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes\");\n    }\n\n    value.privateFor = input.privateFor.map((publicKey, index) => {\n      if (Utils.isBoxedString(publicKey)) {\n        publicKey = publicKey.valueOf();\n      }\n\n      if (typeof publicKey !== \"string\") {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not a string`);\n      }\n\n      if (!Utils.isBase64(publicKey)) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not base64-encoded`);\n      }\n\n      const length = Utils.base64Length(publicKey);\n\n      if (length !== 32) {\n        throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);\n      }\n\n      return publicKey;\n    });\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* optionsFromCodecOptionsValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  }\n\n  const value = input.value; //unlike in the array or tuple cases, here should not have\n  //to worry about compatible-but-not-identical types, so it's\n  //safe to just copy value over\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value\n  };\n}\n\nfunction* optionsFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"options\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //because options, unlike other containers, has specific types, we *will* turn on loose\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), txOptionsCasesBasic);\n}\n\nfunction* optionsFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, \"Transaction options input was not a plain object, type/value pair or wrapped options object\");\n}","map":{"version":3,"mappings":"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","names":["debug","arrayCasesBasic","arrayFromArray","arrayFromCodecArrayValue","arrayFromJson","arrayFailureCase","exports","arrayFromTypeValueInput","tupleCasesBasic","tupleFromArray","tupleFromCodecTupleLikeValue","tupleFromObject","tupleFromJson","tupleFailureCase","tupleFromTypeValueInput","txOptionsCasesBasic","optionsFromCodecOptionsValue","optionsFromObject","optionsFailureCase","optionsFromTypeValueInput","udvtFromUnderlying","wrap","dataType","input","wrapOptions","name","typeClass","integer_1","decimal_1","bool_1","bytes_1","address_1","string_1","visibility","errors_1","function_1","Format","Types","typeStringWithoutLocation","Array","isArray","kind","length","eqn","Messages","wrongArrayLengthMessage","value","index","push","baseType","Object","specificityFloor","type","Utils","isWrappedResult","wrappedTypeMessage","errorResultMessage","loose","allowJson","parsedInput","JSON","parse","error","message","isTypeValueInput","specifiedTypeMessage","memberTypes","memberTypesForType","userDefinedTypes","memberName","match","isPlainObject","some","unusedKeys","Set","keys","delete","size","exampleKey","values","next","coercedInput","map","typeName","fullType","underlyingType","uintKeys","uint8Keys","addressKeys","bytesKeys","boolKeys","accessListKeys","specialKeys","allKeys","badKey","find","key","includes","goodKey","undefined","oldOptionsBehavior","wrappedOption","bits","asBN","gten","Conversion","toHexString","asAddress","asHex","asBoolean","Inspect","nativizeAccessList","privateFor","publicKey","isBoxedString","valueOf","isBase64","base64Length"],"sourceRoot":"","sources":["../../../lib/wrap/wrap.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}