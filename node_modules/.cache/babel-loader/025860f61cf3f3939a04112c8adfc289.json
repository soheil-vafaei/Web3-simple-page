{"ast":null,"code":"import { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\n\nexport class Node {\n  constructor() {\n    /** Parent of the node */\n    this.parent = null;\n    /** Previous sibling */\n\n    this.prev = null;\n    /** Next sibling */\n\n    this.next = null;\n    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n\n    this.startIndex = null;\n    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n\n    this.endIndex = null;\n  } // Read-write aliases for properties\n\n  /**\n   * Same as {@link parent}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get parentNode() {\n    return this.parent;\n  }\n\n  set parentNode(parent) {\n    this.parent = parent;\n  }\n  /**\n   * Same as {@link prev}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get previousSibling() {\n    return this.prev;\n  }\n\n  set previousSibling(prev) {\n    this.prev = prev;\n  }\n  /**\n   * Same as {@link next}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get nextSibling() {\n    return this.next;\n  }\n\n  set nextSibling(next) {\n    this.next = next;\n  }\n  /**\n   * Clone this node, and optionally its children.\n   *\n   * @param recursive Clone child nodes as well.\n   * @returns A clone of the node.\n   */\n\n\n  cloneNode() {\n    let recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return cloneNode(this, recursive);\n  }\n\n}\n/**\n * A node that contains some data.\n */\n\nexport class DataNode extends Node {\n  /**\n   * @param data The content of the data node\n   */\n  constructor(data) {\n    super();\n    this.data = data;\n  }\n  /**\n   * Same as {@link data}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get nodeValue() {\n    return this.data;\n  }\n\n  set nodeValue(data) {\n    this.data = data;\n  }\n\n}\n/**\n * Text within the document.\n */\n\nexport class Text extends DataNode {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Text;\n  }\n\n  get nodeType() {\n    return 3;\n  }\n\n}\n/**\n * Comments within the document.\n */\n\nexport class Comment extends DataNode {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Comment;\n  }\n\n  get nodeType() {\n    return 8;\n  }\n\n}\n/**\n * Processing instructions, including doc types.\n */\n\nexport class ProcessingInstruction extends DataNode {\n  constructor(name, data) {\n    super(data);\n    this.name = name;\n    this.type = ElementType.Directive;\n  }\n\n  get nodeType() {\n    return 1;\n  }\n\n}\n/**\n * A `Node` that can have children.\n */\n\nexport class NodeWithChildren extends Node {\n  /**\n   * @param children Children of the node. Only certain node types can have children.\n   */\n  constructor(children) {\n    super();\n    this.children = children;\n  } // Aliases\n\n  /** First child of the node. */\n\n\n  get firstChild() {\n    var _a;\n\n    return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n  }\n  /** Last child of the node. */\n\n\n  get lastChild() {\n    return this.children.length > 0 ? this.children[this.children.length - 1] : null;\n  }\n  /**\n   * Same as {@link children}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get childNodes() {\n    return this.children;\n  }\n\n  set childNodes(children) {\n    this.children = children;\n  }\n\n}\nexport class CDATA extends NodeWithChildren {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.CDATA;\n  }\n\n  get nodeType() {\n    return 4;\n  }\n\n}\n/**\n * The root node of the document.\n */\n\nexport class Document extends NodeWithChildren {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Root;\n  }\n\n  get nodeType() {\n    return 9;\n  }\n\n}\n/**\n * An element within the DOM.\n */\n\nexport class Element extends NodeWithChildren {\n  /**\n   * @param name Name of the tag, eg. `div`, `span`.\n   * @param attribs Object mapping attribute names to attribute values.\n   * @param children Children of the node.\n   */\n  constructor(name, attribs) {\n    let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : name === \"script\" ? ElementType.Script : name === \"style\" ? ElementType.Style : ElementType.Tag;\n    super(children);\n    this.name = name;\n    this.attribs = attribs;\n    this.type = type;\n  }\n\n  get nodeType() {\n    return 1;\n  } // DOM Level 1 aliases\n\n  /**\n   * Same as {@link name}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n\n\n  get tagName() {\n    return this.name;\n  }\n\n  set tagName(name) {\n    this.name = name;\n  }\n\n  get attributes() {\n    return Object.keys(this.attribs).map(name => {\n      var _a, _b;\n\n      return {\n        name,\n        value: this.attribs[name],\n        namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n        prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name]\n      };\n    });\n  }\n\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\n\nexport function isTag(node) {\n  return isTagRaw(node);\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\n\nexport function isCDATA(node) {\n  return node.type === ElementType.CDATA;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\n\nexport function isText(node) {\n  return node.type === ElementType.Text;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\n\nexport function isComment(node) {\n  return node.type === ElementType.Comment;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\n\nexport function isDirective(node) {\n  return node.type === ElementType.Directive;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\n\nexport function isDocument(node) {\n  return node.type === ElementType.Root;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\n\nexport function hasChildren(node) {\n  return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\n\nexport function cloneNode(node) {\n  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let result;\n\n  if (isText(node)) {\n    result = new Text(node.data);\n  } else if (isComment(node)) {\n    result = new Comment(node.data);\n  } else if (isTag(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new Element(node.name, { ...node.attribs\n    }, children);\n    children.forEach(child => child.parent = clone);\n\n    if (node.namespace != null) {\n      clone.namespace = node.namespace;\n    }\n\n    if (node[\"x-attribsNamespace\"]) {\n      clone[\"x-attribsNamespace\"] = { ...node[\"x-attribsNamespace\"]\n      };\n    }\n\n    if (node[\"x-attribsPrefix\"]) {\n      clone[\"x-attribsPrefix\"] = { ...node[\"x-attribsPrefix\"]\n      };\n    }\n\n    result = clone;\n  } else if (isCDATA(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new CDATA(children);\n    children.forEach(child => child.parent = clone);\n    result = clone;\n  } else if (isDocument(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new Document(children);\n    children.forEach(child => child.parent = clone);\n\n    if (node[\"x-mode\"]) {\n      clone[\"x-mode\"] = node[\"x-mode\"];\n    }\n\n    result = clone;\n  } else if (isDirective(node)) {\n    const instruction = new ProcessingInstruction(node.name, node.data);\n\n    if (node[\"x-name\"] != null) {\n      instruction[\"x-name\"] = node[\"x-name\"];\n      instruction[\"x-publicId\"] = node[\"x-publicId\"];\n      instruction[\"x-systemId\"] = node[\"x-systemId\"];\n    }\n\n    result = instruction;\n  } else {\n    throw new Error(`Not implemented yet: ${node.type}`);\n  }\n\n  result.startIndex = node.startIndex;\n  result.endIndex = node.endIndex;\n\n  if (node.sourceCodeLocation != null) {\n    result.sourceCodeLocation = node.sourceCodeLocation;\n  }\n\n  return result;\n}\n\nfunction cloneChildren(childs) {\n  const children = childs.map(child => cloneNode(child, true));\n\n  for (let i = 1; i < children.length; i++) {\n    children[i].prev = children[i - 1];\n    children[i - 1].next = children[i];\n  }\n\n  return children;\n}","map":{"version":3,"names":["ElementType","isTag","isTagRaw","Node","constructor","parent","prev","next","startIndex","endIndex","parentNode","previousSibling","nextSibling","cloneNode","recursive","DataNode","data","nodeValue","Text","arguments","type","nodeType","Comment","ProcessingInstruction","name","Directive","NodeWithChildren","children","firstChild","_a","lastChild","length","childNodes","CDATA","Document","Root","Element","attribs","Script","Style","Tag","tagName","attributes","Object","keys","map","_b","value","namespace","prefix","node","isCDATA","isText","isComment","isDirective","isDocument","hasChildren","prototype","hasOwnProperty","call","result","cloneChildren","clone","forEach","child","instruction","Error","sourceCodeLocation","childs","i"],"sources":["/Users/soheilvafaei/Documents/project/web/resume/ex7/node_modules/parse5-htmlparser2-tree-adapter/node_modules/domhandler/lib/esm/node.js"],"sourcesContent":["import { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nexport class Node {\n    constructor() {\n        /** Parent of the node */\n        this.parent = null;\n        /** Previous sibling */\n        this.prev = null;\n        /** Next sibling */\n        this.next = null;\n        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n        this.startIndex = null;\n        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n        this.endIndex = null;\n    }\n    // Read-write aliases for properties\n    /**\n     * Same as {@link parent}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get parentNode() {\n        return this.parent;\n    }\n    set parentNode(parent) {\n        this.parent = parent;\n    }\n    /**\n     * Same as {@link prev}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get previousSibling() {\n        return this.prev;\n    }\n    set previousSibling(prev) {\n        this.prev = prev;\n    }\n    /**\n     * Same as {@link next}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get nextSibling() {\n        return this.next;\n    }\n    set nextSibling(next) {\n        this.next = next;\n    }\n    /**\n     * Clone this node, and optionally its children.\n     *\n     * @param recursive Clone child nodes as well.\n     * @returns A clone of the node.\n     */\n    cloneNode(recursive = false) {\n        return cloneNode(this, recursive);\n    }\n}\n/**\n * A node that contains some data.\n */\nexport class DataNode extends Node {\n    /**\n     * @param data The content of the data node\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n    }\n    /**\n     * Same as {@link data}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get nodeValue() {\n        return this.data;\n    }\n    set nodeValue(data) {\n        this.data = data;\n    }\n}\n/**\n * Text within the document.\n */\nexport class Text extends DataNode {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Text;\n    }\n    get nodeType() {\n        return 3;\n    }\n}\n/**\n * Comments within the document.\n */\nexport class Comment extends DataNode {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Comment;\n    }\n    get nodeType() {\n        return 8;\n    }\n}\n/**\n * Processing instructions, including doc types.\n */\nexport class ProcessingInstruction extends DataNode {\n    constructor(name, data) {\n        super(data);\n        this.name = name;\n        this.type = ElementType.Directive;\n    }\n    get nodeType() {\n        return 1;\n    }\n}\n/**\n * A `Node` that can have children.\n */\nexport class NodeWithChildren extends Node {\n    /**\n     * @param children Children of the node. Only certain node types can have children.\n     */\n    constructor(children) {\n        super();\n        this.children = children;\n    }\n    // Aliases\n    /** First child of the node. */\n    get firstChild() {\n        var _a;\n        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /** Last child of the node. */\n    get lastChild() {\n        return this.children.length > 0\n            ? this.children[this.children.length - 1]\n            : null;\n    }\n    /**\n     * Same as {@link children}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get childNodes() {\n        return this.children;\n    }\n    set childNodes(children) {\n        this.children = children;\n    }\n}\nexport class CDATA extends NodeWithChildren {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.CDATA;\n    }\n    get nodeType() {\n        return 4;\n    }\n}\n/**\n * The root node of the document.\n */\nexport class Document extends NodeWithChildren {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Root;\n    }\n    get nodeType() {\n        return 9;\n    }\n}\n/**\n * An element within the DOM.\n */\nexport class Element extends NodeWithChildren {\n    /**\n     * @param name Name of the tag, eg. `div`, `span`.\n     * @param attribs Object mapping attribute names to attribute values.\n     * @param children Children of the node.\n     */\n    constructor(name, attribs, children = [], type = name === \"script\"\n        ? ElementType.Script\n        : name === \"style\"\n            ? ElementType.Style\n            : ElementType.Tag) {\n        super(children);\n        this.name = name;\n        this.attribs = attribs;\n        this.type = type;\n    }\n    get nodeType() {\n        return 1;\n    }\n    // DOM Level 1 aliases\n    /**\n     * Same as {@link name}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get tagName() {\n        return this.name;\n    }\n    set tagName(name) {\n        this.name = name;\n    }\n    get attributes() {\n        return Object.keys(this.attribs).map((name) => {\n            var _a, _b;\n            return ({\n                name,\n                value: this.attribs[name],\n                namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n                prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name],\n            });\n        });\n    }\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\nexport function isTag(node) {\n    return isTagRaw(node);\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\nexport function isCDATA(node) {\n    return node.type === ElementType.CDATA;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\nexport function isText(node) {\n    return node.type === ElementType.Text;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\nexport function isComment(node) {\n    return node.type === ElementType.Comment;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDirective(node) {\n    return node.type === ElementType.Directive;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDocument(node) {\n    return node.type === ElementType.Root;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\nexport function hasChildren(node) {\n    return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nexport function cloneNode(node, recursive = false) {\n    let result;\n    if (isText(node)) {\n        result = new Text(node.data);\n    }\n    else if (isComment(node)) {\n        result = new Comment(node.data);\n    }\n    else if (isTag(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new Element(node.name, { ...node.attribs }, children);\n        children.forEach((child) => (child.parent = clone));\n        if (node.namespace != null) {\n            clone.namespace = node.namespace;\n        }\n        if (node[\"x-attribsNamespace\"]) {\n            clone[\"x-attribsNamespace\"] = { ...node[\"x-attribsNamespace\"] };\n        }\n        if (node[\"x-attribsPrefix\"]) {\n            clone[\"x-attribsPrefix\"] = { ...node[\"x-attribsPrefix\"] };\n        }\n        result = clone;\n    }\n    else if (isCDATA(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new CDATA(children);\n        children.forEach((child) => (child.parent = clone));\n        result = clone;\n    }\n    else if (isDocument(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new Document(children);\n        children.forEach((child) => (child.parent = clone));\n        if (node[\"x-mode\"]) {\n            clone[\"x-mode\"] = node[\"x-mode\"];\n        }\n        result = clone;\n    }\n    else if (isDirective(node)) {\n        const instruction = new ProcessingInstruction(node.name, node.data);\n        if (node[\"x-name\"] != null) {\n            instruction[\"x-name\"] = node[\"x-name\"];\n            instruction[\"x-publicId\"] = node[\"x-publicId\"];\n            instruction[\"x-systemId\"] = node[\"x-systemId\"];\n        }\n        result = instruction;\n    }\n    else {\n        throw new Error(`Not implemented yet: ${node.type}`);\n    }\n    result.startIndex = node.startIndex;\n    result.endIndex = node.endIndex;\n    if (node.sourceCodeLocation != null) {\n        result.sourceCodeLocation = node.sourceCodeLocation;\n    }\n    return result;\n}\nfunction cloneChildren(childs) {\n    const children = childs.map((child) => cloneNode(child, true));\n    for (let i = 1; i < children.length; i++) {\n        children[i].prev = children[i - 1];\n        children[i - 1].next = children[i];\n    }\n    return children;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}