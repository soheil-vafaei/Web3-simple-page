{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeContext = exports.normalizeContexts = exports.matchContext = exports.findContext = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:contexts:utils\");\n\nconst Evm = __importStar(require(\"../evm\"));\n\nconst Conversion = __importStar(require(\"../conversion\"));\n\nconst escapeRegExp_1 = __importDefault(require(\"lodash/escapeRegExp\"));\n\nconst cbor = __importStar(require(\"cbor\"));\n\nconst compile_common_1 = require(\"@truffle/compile-common\");\n\nconst Abi = __importStar(require(\"@truffle/abi-utils\"));\n\nconst AbiDataUtils = __importStar(require(\"../abi-data/utils\"));\n\nfunction findContext(contexts, binary) {\n  const matchingContexts = Object.values(contexts).filter(context => matchContext(context, binary)); //rather than just pick an arbitrary matching context, we're going\n  //to pick one that isn't a descendant of any of the others.\n  //(if there are multiple of *those*, then yeah it's arbitrary.)\n\n  const context = matchingContexts.find(descendant => !matchingContexts.some(ancestor => descendant.compilationId === ancestor.compilationId && descendant.linearizedBaseContracts && ancestor.contractId !== undefined && descendant.linearizedBaseContracts.slice(1).includes(ancestor.contractId) //we do slice one because everything is an an ancestor of itself; we only\n  //care about *proper* ancestors\n  ));\n  return context || null;\n}\n\nexports.findContext = findContext;\n\nfunction matchContext(context, givenBinary) {\n  const {\n    binary,\n    compiler,\n    isConstructor\n  } = context;\n  const lengthDifference = givenBinary.length - binary.length; //first: if it's not a constructor, and it's not Vyper,\n  //they'd better be equal in length.\n  //if it is a constructor, or is Vyper,\n  //the given binary must be at least as long,\n  //and the difference must be a multiple of 32 bytes (64 hex digits)\n\n  const additionalAllowed = isConstructor || compiler != undefined && compiler.name === \"vyper\";\n\n  if (!additionalAllowed && lengthDifference !== 0 || lengthDifference < 0 || lengthDifference % (2 * Evm.Utils.WORD_SIZE) !== 0) {\n    return false;\n  }\n\n  for (let i = 0; i < binary.length; i++) {\n    //note: using strings like arrays is kind of dangerous in general in JS,\n    //but everything here is ASCII so it's fine\n    //note that we need to compare case-insensitive, since Solidity will\n    //put addresses in checksum case in the compiled source\n    //(we don't actually need that second toLowerCase(), but whatever)\n    if (binary[i] !== \".\" && binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.matchContext = matchContext;\n\nfunction normalizeContexts(contexts) {\n  //unfortunately, due to our current link references format, we can't\n  //really use the binary from the artifact directly -- neither for purposes\n  //of matching, nor for purposes of decoding internal functions.  So, we\n  //need to perform this normalization step on our contexts before using\n  //them.  Once we have truffle-db, this step should largely go away.\n  debug(\"normalizing contexts\"); //first, let's clone the input\n  //(let's do a 2-deep clone because we'll be altering binary & compiler)\n\n  let newContexts = Object.assign({}, ...Object.entries(contexts).map(_ref => {\n    let [contextHash, context] = _ref;\n    return {\n      [contextHash]: Object.assign({}, context)\n    };\n  }));\n  debug(\"contexts cloned\"); //next, we get all the library names and sort them descending by length.\n  //We're going to want to go in descending order of length so that we\n  //don't run into problems when one name is a substring of another.\n  //For simplicity, we'll exclude names of length <38, because we can\n  //handle these with our more general check for link references at the end\n\n  const fillerLength = 2 * Evm.Utils.ADDRESS_SIZE;\n  let names = Object.values(newContexts).filter(context => context.contractKind === \"library\").map(context => context.contractName).filter(name => name.length >= fillerLength - 3) //the -3 is for 2 leading underscores and 1 trailing\n  .sort((name1, name2) => name2.length - name1.length);\n  debug(\"names sorted\"); //now, we need to turn all these names into regular expressions, because,\n  //unfortunately, str.replace() will only replace all if you use a /g regexp;\n  //note that because names may contain '$', we need to escape them\n  //(also we prepend \"__\" because that's the placeholder format)\n\n  let regexps = names.map(name => new RegExp((0, escapeRegExp_1.default)(\"__\" + name), \"g\"));\n  debug(\"regexps prepared\"); //having done so, we can do the replace for these names!\n\n  const replacement = \".\".repeat(fillerLength);\n\n  for (let regexp of regexps) {\n    for (let context of Object.values(newContexts)) {\n      context.binary = context.binary.replace(regexp, replacement);\n    }\n  }\n\n  debug(\"long replacements complete\"); //now we can do a generic replace that will catch all names of length\n  //<40, while also catching the Solidity compiler's link reference format\n  //as well as Truffle's.  Hooray!\n\n  const genericRegexp = new RegExp(\"_.{\" + (fillerLength - 2) + \"}_\", \"g\"); //we're constructing the regexp /_.{38}_/g, but I didn't want to use a\n  //literal 38 :P\n\n  for (let context of Object.values(newContexts)) {\n    context.binary = context.binary.replace(genericRegexp, replacement);\n  }\n\n  debug(\"short replacements complete\"); //now we must handle the delegatecall guard -- libraries' deployedBytecode will include\n  //0s in place of their own address instead of a link reference at the\n  //beginning, so we need to account for that too\n\n  const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n  for (let context of Object.values(newContexts)) {\n    if (context.contractKind === \"library\" && !context.isConstructor) {\n      context.binary = context.binary.replace(\"0x\" + pushAddressInstruction + \"00\".repeat(Evm.Utils.ADDRESS_SIZE), \"0x\" + pushAddressInstruction + replacement);\n    }\n  }\n\n  debug(\"extra library replacements complete\"); //now let's handle immutable references\n  //(these are much nicer than link references due to not having to deal with the old format)\n\n  for (let context of Object.values(newContexts)) {\n    if (context.immutableReferences) {\n      for (let variable of Object.values(context.immutableReferences)) {\n        for (let {\n          start,\n          length\n        } of variable) {\n          //Goddammit TS\n          let lowerStringIndex = 2 + 2 * start;\n          let upperStringIndex = 2 + 2 * (start + length);\n          context.binary = context.binary.slice(0, lowerStringIndex) + \"..\".repeat(length) + context.binary.slice(upperStringIndex);\n        }\n      }\n    }\n  }\n\n  debug(\"immutables complete\"); //now: extract & decode all the cbor's.  we're going to use these for\n  //two different purposes, so let's just get them all upfront.\n\n  let cborInfos = {};\n  let decodedCbors = {}; //note: invalid cbor will be indicated in decodedCbors by the lack of an entry,\n  //*not* by undefined or null, since there exists cbor for those :P\n\n  for (const [contextHash, context] of Object.entries(newContexts)) {\n    const cborInfo = extractCborInfo(context.binary);\n    cborInfos[contextHash] = cborInfo;\n\n    if (cborInfo) {\n      try {\n        //note this *will* throw if there's data left over,\n        //which is what we want it to do\n        const decoded = cbor.decodeFirstSync(cborInfo.cbor);\n        decodedCbors[contextHash] = decoded;\n      } catch (_a) {//just don't add it\n      }\n    }\n  }\n\n  debug(\"intial cbor processing complete\"); //now: if a context lacks a compiler, but a version can be found in the\n  //cbor, add it.\n\n  for (let [contextHash, context] of Object.entries(newContexts)) {\n    if (!context.compiler && contextHash in decodedCbors) {\n      context.compiler = detectCompilerInfo(decodedCbors[contextHash]);\n    }\n  }\n\n  debug(\"versions complete\"); //one last step: where there's CBOR with a metadata hash, we'll allow the\n  //CBOR to vary, aside from the length (note: ideally here we would *only*\n  //dot-out the metadata hash part of the CBOR, but, well, it's not worth the\n  //trouble to detect that; doing that could potentially get pretty involved)\n  //note that if the code isn't Solidity, that's fine -- we just won't get\n  //valid CBOR and will not end up adding to our list of regular expressions\n\n  const externalCborInfos = Object.entries(cborInfos).filter(_ref2 => {\n    let [contextHash, _cborInfo] = _ref2;\n    return contextHash in decodedCbors && isObjectWithHash(decodedCbors[contextHash]);\n  }).map(_ref3 => {\n    let [_contextHash, cborInfo] = _ref3;\n    return cborInfo;\n  });\n  const cborRegexps = externalCborInfos.map(cborInfo => ({\n    input: new RegExp(cborInfo.cborSegment, \"g\"),\n    output: \"..\".repeat(cborInfo.cborLength) + cborInfo.cborLengthHex\n  })); //HACK: we will replace *every* occurrence of *every* external CBOR occurring\n  //in *every* context, in order to cover created contracts (including if there\n  //are multiple or recursive ones)\n\n  for (let context of Object.values(newContexts)) {\n    for (let {\n      input,\n      output\n    } of cborRegexps) {\n      context.binary = context.binary.replace(input, output);\n    }\n  }\n\n  debug(\"external wildcards complete\"); //finally, return this mess!\n\n  return newContexts;\n}\n\nexports.normalizeContexts = normalizeContexts; //returns cbor info if cbor section is found, null if it is not.\n//note that it does not account for Vyper 0.3.4's idiosyncratic format\n//and so will return null on that.  but that's OK, because Vyper 0.3.4's\n//CBOR section is always fixed, so there isn't a need to normalize it here\n\nfunction extractCborInfo(binary) {\n  debug(\"extracting cbor segement of %s\", binary);\n  const lastTwoBytes = binary.slice(2).slice(-2 * 2); //2 bytes * 2 for hex\n  //the slice(2) there may seem unnecessary; it's to handle the possibility that the contract\n  //has less than two bytes in its bytecode (that won't happen with Solidity, but let's be\n  //certain)\n\n  if (lastTwoBytes.length < 2 * 2) {\n    return null; //don't try to handle this case!\n  }\n\n  const cborLength = parseInt(lastTwoBytes, 16);\n  const cborEnd = binary.length - 2 * 2;\n  const cborStart = cborEnd - cborLength * 2; //sanity check\n\n  if (cborStart < 2) {\n    //\"0x\"\n    return null; //don't try to handle this case!\n  }\n\n  const cbor = binary.slice(cborStart, cborEnd);\n  return {\n    cborStart,\n    cborLength,\n    cborEnd,\n    cborLengthHex: lastTwoBytes,\n    cbor,\n    cborSegment: cbor + lastTwoBytes\n  };\n}\n\nfunction isObjectWithHash(decoded) {\n  if (typeof decoded !== \"object\" || decoded === null) {\n    return false;\n  } //cbor sometimes returns maps and sometimes objects,\n  //so let's make things consistent by converting to a map\n  //(actually, is this true? borc did this, I think cbor\n  //does too, but I haven't checked recently)\n\n\n  if (!(decoded instanceof Map)) {\n    decoded = new Map(Object.entries(decoded));\n  }\n\n  const hashKeys = [\"bzzr0\", \"bzzr1\", \"ipfs\"];\n  return hashKeys.some(key => decoded.has(key));\n} //returns undefined if no valid compiler info detected\n//(if it detects solc but no version, it will not return\n//a partial result, just undefined)\n\n\nfunction detectCompilerInfo(decoded) {\n  if (typeof decoded !== \"object\" || decoded === null) {\n    return undefined;\n  } //cbor sometimes returns maps and sometimes objects,\n  //so let's make things consistent by converting to a map\n  //(although see note above?)\n\n\n  if (!(decoded instanceof Map)) {\n    decoded = new Map(Object.entries(decoded));\n  }\n\n  if (!decoded.has(\"solc\")) {\n    //return undefined if the solc version field is not present\n    //(this occurs if version <0.5.9)\n    //currently no other language attaches cbor info, so, yeah\n    return undefined;\n  }\n\n  const rawVersion = decoded.get(\"solc\");\n\n  if (typeof rawVersion === \"string\") {\n    //for prerelease versions, the version is stored as a string.\n    return {\n      name: \"solc\",\n      version: rawVersion\n    };\n  } else if (rawVersion instanceof Uint8Array && rawVersion.length === 3) {\n    //for release versions, it's stored as a bytestring of length 3, with the\n    //bytes being major, minor, patch. so we just join them with \".\" to form\n    //a version string (although it's missing precise commit & etc).\n    return {\n      name: \"solc\",\n      version: rawVersion.join(\".\")\n    };\n  } else {\n    //return undefined on anything else\n    return undefined;\n  }\n}\n\nfunction makeContext(contract, node, compilation) {\n  let isConstructor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const abi = Abi.normalize(contract.abi);\n  const bytecode = isConstructor ? contract.bytecode : contract.deployedBytecode;\n  const binary = compile_common_1.Shims.NewToLegacy.forBytecode(bytecode);\n  const hash = Conversion.toHexString(Evm.Utils.keccak256({\n    type: \"string\",\n    value: binary\n  }));\n  debug(\"hash: %s\", hash);\n  const fallback = abi.find(abiEntry => abiEntry.type === \"fallback\") || null; //TS is failing at inference here\n\n  const receive = abi.find(abiEntry => abiEntry.type === \"receive\") || null; //and here\n\n  return {\n    context: hash,\n    contractName: contract.contractName,\n    binary,\n    contractId: node ? node.id : undefined,\n    linearizedBaseContracts: node ? node.linearizedBaseContracts : undefined,\n    contractKind: contractKind(contract, node),\n    immutableReferences: isConstructor ? undefined : contract.immutableReferences,\n    isConstructor,\n    abi: AbiDataUtils.computeSelectors(abi),\n    payable: AbiDataUtils.abiHasPayableFallback(abi),\n    fallbackAbi: {\n      fallback,\n      receive\n    },\n    compiler: compilation.compiler || contract.compiler,\n    compilationId: compilation.id\n  };\n}\n\nexports.makeContext = makeContext; //attempts to determine if the given contract is a library or not\n\nfunction contractKind(contract, node) {\n  //first: if we have a node, use its listed contract kind\n  if (node) {\n    return node.contractKind;\n  } //next: check the contract kind field on the contract object itself, if it exists.\n  //however this isn't implemented yet so we'll skip it.\n  //next: if we have no direct info on the contract kind, but we do\n  //have the deployed bytecode, we'll use a HACK:\n  //we'll assume it's an ordinary contract, UNLESS its deployed bytecode begins with\n  //PUSH20 followed by 20 0s, in which case we'll assume it's a library\n  //(note: this will fail to detect libraries from before Solidity 0.4.20)\n\n\n  if (contract.deployedBytecode) {\n    const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);\n    const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n    const libraryString = \"0x\" + pushAddressInstruction + \"00\".repeat(Evm.Utils.ADDRESS_SIZE);\n    return deployedBytecode.startsWith(libraryString) ? \"library\" : \"contract\";\n  } //finally, in the absence of anything to go on, we'll assume it's an ordinary contract\n\n\n  return \"contract\";\n}","map":{"version":3,"mappings":"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","names":["debug","findContext","contexts","binary","matchingContexts","Object","values","filter","context","matchContext","find","descendant","some","ancestor","compilationId","linearizedBaseContracts","contractId","undefined","slice","includes","exports","givenBinary","compiler","isConstructor","lengthDifference","length","additionalAllowed","name","Evm","Utils","WORD_SIZE","i","toLowerCase","normalizeContexts","newContexts","assign","entries","map","contextHash","fillerLength","ADDRESS_SIZE","names","contractKind","contractName","sort","name1","name2","regexps","RegExp","replacement","repeat","regexp","replace","genericRegexp","pushAddressInstruction","toString","immutableReferences","variable","start","lowerStringIndex","upperStringIndex","cborInfos","decodedCbors","cborInfo","extractCborInfo","decoded","cbor","decodeFirstSync","detectCompilerInfo","externalCborInfos","_cborInfo","isObjectWithHash","_contextHash","cborRegexps","input","cborSegment","output","cborLength","cborLengthHex","lastTwoBytes","parseInt","cborEnd","cborStart","Map","hashKeys","key","has","rawVersion","get","version","Uint8Array","join","makeContext","contract","node","compilation","abi","Abi","normalize","bytecode","deployedBytecode","compile_common_1","NewToLegacy","forBytecode","hash","Conversion","toHexString","keccak256","type","value","fallback","abiEntry","receive","id","AbiDataUtils","computeSelectors","payable","abiHasPayableFallback","fallbackAbi","libraryString","startsWith"],"sourceRoot":"","sources":["../../../lib/contexts/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}