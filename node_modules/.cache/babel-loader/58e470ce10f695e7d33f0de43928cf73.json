{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nvar constants_1 = require(\"../constants\");\n\nvar errors = __importStar(require(\"../errors\"));\n\nvar address_1 = require(\"./address\");\n\nvar bignumber_1 = require(\"./bignumber\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar utf8_1 = require(\"./utf8\");\n\nvar properties_1 = require(\"./properties\"); ///////////////////////////////\n\n\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexports.defaultCoerceFunc = function (type, value) {\n  var match = type.match(paramTypeNumber);\n\n  if (match && parseInt(match[2]) <= 48) {\n    return value.toNumber();\n  }\n\n  return value;\n}; ///////////////////////////////////\n// Parsing for Solidity Signatures\n\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint256' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int256' + type.substring(3);\n  }\n\n  return type;\n}\n\nfunction parseParam(param, allowIndexed) {\n  var originalParam = param;\n\n  function throwError(i) {\n    throw new Error('unexpected character \"' + originalParam[i] + '\" at position ' + i + ' in \"' + originalParam + '\"');\n  }\n\n  param = param.replace(/\\s/g, ' ');\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case '(':\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case ',':\n        delete node.state;\n\n        if (allowIndexed && node.name === 'indexed') {\n          node.indexed = true;\n          node.name = '';\n        }\n\n        node.type = verifyType(node.type);\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== '') {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== '') {\n            if (allowIndexed && node.name === 'indexed') {\n              node.indexed = true;\n              node.name = '';\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case ']':\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n\n  delete parent.state;\n\n  if (allowIndexed && node.name === 'indexed') {\n    node.indexed = true;\n    node.name = '';\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n} // @TODO: Better return type\n\n\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    name: '',\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n\n  if (!match) {\n    throw new Error('invalid event: ' + fragment);\n  }\n\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n\n      case '':\n        break;\n\n      default:\n        errors.info('unknown modifier: ' + modifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + abi.name + '\"');\n  }\n\n  return abi;\n}\n\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    gas: null,\n    inputs: [],\n    name: '',\n    outputs: [],\n    payable: false,\n    stateMutability: null,\n    type: 'function'\n  };\n  var comps = fragment.split('@');\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      throw new Error('invalid signature');\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      throw new Error('invalid signature gas');\n    }\n\n    abi.gas = bignumber_1.bigNumberify(comps[1]);\n    fragment = comps[0];\n  }\n\n  comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n\n  if (!left) {\n    throw new Error('invalid signature');\n  }\n\n  abi.name = left[1].trim();\n\n  if (!abi.name.match(regexIdentifier)) {\n    throw new Error('invalid identifier: \"' + left[1] + '\"');\n  }\n\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n\n      case 'payable':\n        abi.payable = true;\n        abi.stateMutability = 'payable';\n        break;\n\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n\n      case 'external':\n      case 'public':\n      case '':\n        break;\n\n      default:\n        errors.info('unknown modifier: ' + modifier);\n    }\n  }); // We have outputs\n\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n\n    if (right[1].trim() != '' || right[3].trim() != '') {\n      throw new Error('unexpected tokens');\n    }\n\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  if (abi.name === 'constructor') {\n    abi.type = \"constructor\";\n\n    if (abi.outputs.length) {\n      throw new Error('constructor may not have outputs');\n    }\n\n    delete abi.name;\n    delete abi.outputs;\n  }\n\n  return abi;\n}\n\nfunction parseParamType(type) {\n  return parseParam(type, true);\n}\n\nexports.parseParamType = parseParamType; // @TODO: Allow a second boolean to expose names\n\nfunction formatParamType(paramType) {\n  return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\n\nexports.formatParamType = formatParamType; // @TODO: Allow a second boolean to expose names and modifiers\n\nfunction formatSignature(fragment) {\n  return fragment.name + '(' + fragment.inputs.map(function (i) {\n    return formatParamType(i);\n  }).join(',') + ')';\n}\n\nexports.formatSignature = formatSignature;\n\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\s/g, ' ');\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw new Error('unknown signature');\n}\n\nexports.parseSignature = parseSignature;\n\nvar Coder =\n/** @class */\nfunction () {\n  function Coder(coerceFunc, name, type, localName, dynamic) {\n    this.coerceFunc = coerceFunc;\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  return Coder;\n}(); // Clones the functionality of an existing Coder, but without a localName\n\n\nvar CoderAnonymous =\n/** @class */\nfunction (_super) {\n  __extends(CoderAnonymous, _super);\n\n  function CoderAnonymous(coder) {\n    var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n\n    properties_1.defineReadOnly(_this, 'coder', coder);\n    return _this;\n  }\n\n  CoderAnonymous.prototype.encode = function (value) {\n    return this.coder.encode(value);\n  };\n\n  CoderAnonymous.prototype.decode = function (data, offset) {\n    return this.coder.decode(data, offset);\n  };\n\n  return CoderAnonymous;\n}(Coder);\n\nvar CoderNull =\n/** @class */\nfunction (_super) {\n  __extends(CoderNull, _super);\n\n  function CoderNull(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n  }\n\n  CoderNull.prototype.encode = function (value) {\n    return bytes_1.arrayify([]);\n  };\n\n  CoderNull.prototype.decode = function (data, offset) {\n    if (offset > data.length) {\n      throw new Error('invalid null');\n    }\n\n    return {\n      consumed: 0,\n      value: this.coerceFunc('null', undefined)\n    };\n  };\n\n  return CoderNull;\n}(Coder);\n\nvar CoderNumber =\n/** @class */\nfunction (_super) {\n  __extends(CoderNumber, _super);\n\n  function CoderNumber(coerceFunc, size, signed, localName) {\n    var _this = this;\n\n    var name = (signed ? 'int' : 'uint') + size * 8;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.size = size;\n    _this.signed = signed;\n    return _this;\n  }\n\n  CoderNumber.prototype.encode = function (value) {\n    try {\n      var v = bignumber_1.bigNumberify(value);\n\n      if (this.signed) {\n        var bounds = constants_1.MaxUint256.maskn(this.size * 8 - 1);\n\n        if (v.gt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n\n        bounds = bounds.add(constants_1.One).mul(constants_1.NegativeOne);\n\n        if (v.lt(bounds)) {\n          throw new Error('out-of-bounds');\n        }\n      } else if (v.lt(constants_1.Zero) || v.gt(constants_1.MaxUint256.maskn(this.size * 8))) {\n        throw new Error('out-of-bounds');\n      }\n\n      v = v.toTwos(this.size * 8).maskn(this.size * 8);\n\n      if (this.signed) {\n        v = v.fromTwos(this.size * 8).toTwos(256);\n      }\n\n      return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n    } catch (error) {\n      errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: value\n      });\n    }\n\n    return null;\n  };\n\n  CoderNumber.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    var junkLength = 32 - this.size;\n    var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n\n    if (this.signed) {\n      value = value.fromTwos(this.size * 8);\n    } else {\n      value = value.maskn(this.size * 8);\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, value)\n    };\n  };\n\n  return CoderNumber;\n}(Coder);\n\nvar uint256Coder = new CoderNumber(function (type, value) {\n  return value;\n}, 32, false, 'none');\n\nvar CoderBoolean =\n/** @class */\nfunction (_super) {\n  __extends(CoderBoolean, _super);\n\n  function CoderBoolean(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n  }\n\n  CoderBoolean.prototype.encode = function (value) {\n    return uint256Coder.encode(!!value ? 1 : 0);\n  };\n\n  CoderBoolean.prototype.decode = function (data, offset) {\n    try {\n      var result = uint256Coder.decode(data, offset);\n    } catch (error) {\n      if (error.reason === 'insufficient data for uint256 type') {\n        errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'boolean',\n          value: error.value\n        });\n      }\n\n      throw error;\n    }\n\n    return {\n      consumed: result.consumed,\n      value: this.coerceFunc('bool', !result.value.isZero())\n    };\n  };\n\n  return CoderBoolean;\n}(Coder);\n\nvar CoderFixedBytes =\n/** @class */\nfunction (_super) {\n  __extends(CoderFixedBytes, _super);\n\n  function CoderFixedBytes(coerceFunc, length, localName) {\n    var _this = this;\n\n    var name = 'bytes' + length;\n    _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderFixedBytes.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      var data = bytes_1.arrayify(value);\n\n      if (data.length !== this.length) {\n        throw new Error('incorrect data length');\n      }\n\n      result.set(data);\n    } catch (error) {\n      errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: error.value || value\n      });\n    }\n\n    return result;\n  };\n\n  CoderFixedBytes.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: this.name,\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n    };\n  };\n\n  return CoderFixedBytes;\n}(Coder);\n\nvar CoderAddress =\n/** @class */\nfunction (_super) {\n  __extends(CoderAddress, _super);\n\n  function CoderAddress(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n  }\n\n  CoderAddress.prototype.encode = function (value) {\n    var result = new Uint8Array(32);\n\n    try {\n      result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n    } catch (error) {\n      errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: value\n      });\n    }\n\n    return result;\n  };\n\n  CoderAddress.prototype.decode = function (data, offset) {\n    if (data.length < offset + 32) {\n      errors.throwError('insufficient data for address type', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'address',\n        value: bytes_1.hexlify(data.slice(offset, offset + 32))\n      });\n    }\n\n    return {\n      consumed: 32,\n      value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n    };\n  };\n\n  return CoderAddress;\n}(Coder);\n\nfunction _encodeDynamicBytes(value) {\n  var dataLength = 32 * Math.ceil(value.length / 32);\n  var padding = new Uint8Array(dataLength - value.length);\n  return bytes_1.concat([uint256Coder.encode(value.length), value, padding]);\n}\n\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 32) {\n    errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32))\n    });\n  }\n\n  var length = uint256Coder.decode(data, offset).value;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: length.toString()\n    });\n  }\n\n  if (data.length < offset + 32 + length) {\n    errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n      arg: localName,\n      coderType: 'dynamicBytes',\n      value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n    });\n  }\n\n  return {\n    consumed: 32 + 32 * Math.ceil(length / 32),\n    value: data.slice(offset + 32, offset + 32 + length)\n  };\n}\n\nvar CoderDynamicBytes =\n/** @class */\nfunction (_super) {\n  __extends(CoderDynamicBytes, _super);\n\n  function CoderDynamicBytes(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n  }\n\n  CoderDynamicBytes.prototype.encode = function (value) {\n    try {\n      return _encodeDynamicBytes(bytes_1.arrayify(value));\n    } catch (error) {\n      errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'bytes',\n        value: error.value\n      });\n    }\n\n    return null;\n  };\n\n  CoderDynamicBytes.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n\n    result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n    return result;\n  };\n\n  return CoderDynamicBytes;\n}(Coder);\n\nvar CoderString =\n/** @class */\nfunction (_super) {\n  __extends(CoderString, _super);\n\n  function CoderString(coerceFunc, localName) {\n    return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n  }\n\n  CoderString.prototype.encode = function (value) {\n    if (typeof value !== 'string') {\n      errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'string',\n        value: value\n      });\n    }\n\n    return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n  };\n\n  CoderString.prototype.decode = function (data, offset) {\n    var result = _decodeDynamicBytes(data, offset, this.localName);\n\n    result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n    return result;\n  };\n\n  return CoderString;\n}(Coder);\n\nfunction alignSize(size) {\n  return 32 * Math.ceil(size / 32);\n}\n\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {// do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues = [];\n    coders.forEach(function (coder) {\n      arrayValues.push(values[coder.localName]);\n    });\n    values = arrayValues;\n  } else {\n    errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  if (coders.length !== values.length) {\n    errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n      coderType: 'tuple',\n      value: values\n    });\n  }\n\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      staticSize += 32;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = new Uint8Array(staticSize + dynamicSize);\n  parts.forEach(function (part) {\n    if (part.dynamic) {\n      //uint256Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint256Coder.encode(dynamicOffset), offset);\n      offset += 32; //part.value.copy(data, dynamicOffset);  @TODO\n\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      //part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\n\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    if (coder.dynamic) {\n      var dynamicOffset = uint256Coder.decode(data, offset);\n      var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber()); // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n    }\n\n    if (result.value != undefined) {\n      value.push(result.value);\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  });\n  return {\n    value: value,\n    consumed: consumed\n  };\n}\n\nvar CoderArray =\n/** @class */\nfunction (_super) {\n  __extends(CoderArray, _super);\n\n  function CoderArray(coerceFunc, coder, length, localName) {\n    var _this = this;\n\n    var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n    var dynamic = length === -1 || coder.dynamic;\n    _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n    _this.coder = coder;\n    _this.length = length;\n    return _this;\n  }\n\n  CoderArray.prototype.encode = function (value) {\n    if (!Array.isArray(value)) {\n      errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n        arg: this.localName,\n        coderType: 'array',\n        value: value\n      });\n    }\n\n    var count = this.length;\n    var result = new Uint8Array(0);\n\n    if (count === -1) {\n      count = value.length;\n      result = uint256Coder.encode(count);\n    }\n\n    errors.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? \" \" + this.localName : \"\"));\n    var coders = [];\n\n    for (var i = 0; i < value.length; i++) {\n      coders.push(this.coder);\n    }\n\n    return bytes_1.concat([result, pack(coders, value)]);\n  };\n\n  CoderArray.prototype.decode = function (data, offset) {\n    // @TODO:\n    //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n    var consumed = 0;\n    var count = this.length;\n\n    if (count === -1) {\n      try {\n        var decodedLength = uint256Coder.decode(data, offset);\n      } catch (error) {\n        errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: error.value\n        });\n      }\n\n      try {\n        count = decodedLength.value.toNumber();\n      } catch (error) {\n        errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n          arg: this.localName,\n          coderType: 'array',\n          value: decodedLength.value.toString()\n        });\n      }\n\n      consumed += decodedLength.consumed;\n      offset += decodedLength.consumed;\n    }\n\n    var coders = [];\n\n    for (var i = 0; i < count; i++) {\n      coders.push(new CoderAnonymous(this.coder));\n    }\n\n    var result = unpack(coders, data, offset);\n    result.consumed += consumed;\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderArray;\n}(Coder);\n\nvar CoderTuple =\n/** @class */\nfunction (_super) {\n  __extends(CoderTuple, _super);\n\n  function CoderTuple(coerceFunc, coders, localName) {\n    var _this = this;\n\n    var dynamic = false;\n    var types = [];\n    coders.forEach(function (coder) {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n\n      types.push(coder.type);\n    });\n    var type = 'tuple(' + types.join(',') + ')';\n    _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n    _this.coders = coders;\n    return _this;\n  }\n\n  CoderTuple.prototype.encode = function (value) {\n    return pack(this.coders, value);\n  };\n\n  CoderTuple.prototype.decode = function (data, offset) {\n    var result = unpack(this.coders, data, offset);\n    result.value = this.coerceFunc(this.type, result.value);\n    return result;\n  };\n\n  return CoderTuple;\n}(Coder);\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\n\n\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = '';\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n\n        if (depth === -1) {\n          throw new Error('unbalanced parenthsis');\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n} // @TODO: Is there a way to return \"class\"?\n\n\nvar paramTypeSimple = {\n  address: CoderAddress,\n  bool: CoderBoolean,\n  string: CoderString,\n  bytes: CoderDynamicBytes\n};\n\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return new CoderTuple(coerceFunc, coders, localName);\n}\n\nfunction getParamCoder(coerceFunc, param) {\n  var coder = paramTypeSimple[param.type];\n\n  if (coder) {\n    return new coder(coerceFunc, param.name);\n  }\n\n  var match = param.type.match(paramTypeNumber);\n\n  if (match) {\n    var size = parseInt(match[2] || \"256\");\n\n    if (size === 0 || size > 256 || size % 8 !== 0) {\n      errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderNumber(coerceFunc, size / 8, match[1] === 'int', param.name);\n  }\n\n  var match = param.type.match(paramTypeBytes);\n\n  if (match) {\n    var size = parseInt(match[1]);\n\n    if (size === 0 || size > 32) {\n      errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n        arg: 'param',\n        value: param\n      });\n    }\n\n    return new CoderFixedBytes(coerceFunc, size, param.name);\n  }\n\n  var match = param.type.match(paramTypeArray);\n\n  if (match) {\n    var size = parseInt(match[2] || \"-1\");\n    param = properties_1.shallowCopy(param);\n    param.type = match[1];\n    param = properties_1.deepCopy(param);\n    return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components, param.name);\n  }\n\n  if (param.type === '') {\n    return new CoderNull(coerceFunc, param.name);\n  }\n\n  errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n    arg: 'type',\n    value: param.type\n  });\n  return null;\n}\n\nvar AbiCoder =\n/** @class */\nfunction () {\n  function AbiCoder(coerceFunc) {\n    errors.checkNew(this, AbiCoder);\n\n    if (!coerceFunc) {\n      coerceFunc = exports.defaultCoerceFunc;\n    }\n\n    properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n  }\n\n  AbiCoder.prototype.encode = function (types, values) {\n    if (types.length !== values.length) {\n      errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n\n    var coders = [];\n    types.forEach(function (type) {\n      // Convert types to type objects\n      //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n      //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n      var typeObject = null;\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = type;\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n  };\n\n  AbiCoder.prototype.decode = function (types, data) {\n    var coders = [];\n    types.forEach(function (type) {\n      // See encode for details\n      var typeObject = null;\n\n      if (typeof type === 'string') {\n        typeObject = parseParam(type);\n      } else {\n        typeObject = properties_1.deepCopy(type);\n      }\n\n      coders.push(getParamCoder(this.coerceFunc, typeObject));\n    }, this);\n    return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n  };\n\n  return AbiCoder;\n}();\n\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();","map":{"version":3,"names":["__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","__importStar","mod","__esModule","result","k","call","defineProperty","exports","value","constants_1","require","errors","address_1","bignumber_1","bytes_1","utf8_1","properties_1","paramTypeBytes","RegExp","paramTypeNumber","paramTypeArray","defaultCoerceFunc","type","match","parseInt","toNumber","regexParen","regexIdentifier","verifyType","substring","parseParam","param","allowIndexed","originalParam","throwError","i","Error","replace","parent","name","state","allowType","node","length","c","allowParams","components","indexed","child","allowName","allowArray","sibling","push","readArray","parseSignatureEvent","fragment","abi","anonymous","inputs","trim","splitNesting","forEach","split","modifier","info","parseSignatureFunction","constant","gas","outputs","payable","stateMutability","comps","bigNumberify","left","right","parseParamType","formatParamType","paramType","getParamCoder","formatSignature","map","join","parseSignature","Coder","coerceFunc","localName","dynamic","CoderAnonymous","_super","coder","_this","undefined","defineReadOnly","encode","decode","data","offset","CoderNull","arrayify","consumed","CoderNumber","size","signed","v","bounds","MaxUint256","maskn","gt","add","One","mul","NegativeOne","lt","Zero","toTwos","fromTwos","padZeros","error","INVALID_ARGUMENT","arg","coderType","hexlify","slice","junkLength","uint256Coder","CoderBoolean","reason","isZero","CoderFixedBytes","Uint8Array","set","CoderAddress","getAddress","_encodeDynamicBytes","dataLength","Math","ceil","padding","concat","_decodeDynamicBytes","toString","CoderDynamicBytes","CoderString","toUtf8Bytes","toUtf8String","alignSize","pack","coders","values","isArray","arrayValues","parts","index","staticSize","dynamicSize","part","dynamicOffset","unpack","baseOffset","CoderArray","count","checkArgumentCount","decodedLength","CoderTuple","types","accum","depth","paramTypeSimple","address","bool","string","bytes","getTupleParamCoder","component","shallowCopy","deepCopy","AbiCoder","checkNew","typeObject","defaultAbiCoder"],"sources":["/Users/soheilvafaei/Documents/project/web/resume/ex7/node_modules/ethers/utils/abi-coder.js"],"sourcesContent":["'use strict';\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nvar constants_1 = require(\"../constants\");\nvar errors = __importStar(require(\"../errors\"));\nvar address_1 = require(\"./address\");\nvar bignumber_1 = require(\"./bignumber\");\nvar bytes_1 = require(\"./bytes\");\nvar utf8_1 = require(\"./utf8\");\nvar properties_1 = require(\"./properties\");\n///////////////////////////////\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexports.defaultCoerceFunc = function (type, value) {\n    var match = type.match(paramTypeNumber);\n    if (match && parseInt(match[2]) <= 48) {\n        return value.toNumber();\n    }\n    return value;\n};\n///////////////////////////////////\n// Parsing for Solidity Signatures\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = 'uint256' + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = 'int256' + type.substring(3);\n    }\n    return type;\n}\nfunction parseParam(param, allowIndexed) {\n    var originalParam = param;\n    function throwError(i) {\n        throw new Error('unexpected character \"' + originalParam[i] + '\" at position ' + i + ' in \"' + originalParam + '\"');\n    }\n    param = param.replace(/\\s/g, ' ');\n    var parent = { type: '', name: '', state: { allowType: true } };\n    var node = parent;\n    for (var i = 0; i < param.length; i++) {\n        var c = param[i];\n        switch (c) {\n            case '(':\n                if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [{ type: '', name: '', parent: node, state: { allowType: true } }];\n                node = node.components[0];\n                break;\n            case ')':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case ',':\n                delete node.state;\n                if (allowIndexed && node.name === 'indexed') {\n                    node.indexed = true;\n                    node.name = '';\n                }\n                node.type = verifyType(node.type);\n                var sibling = { type: '', name: '', parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case ' ':\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== '') {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== '') {\n                        if (allowIndexed && node.name === 'indexed') {\n                            node.indexed = true;\n                            node.name = '';\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case '[':\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case ']':\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        throw new Error(\"unexpected eof\");\n    }\n    delete parent.state;\n    if (allowIndexed && node.name === 'indexed') {\n        node.indexed = true;\n        node.name = '';\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\n// @TODO: Better return type\nfunction parseSignatureEvent(fragment) {\n    var abi = {\n        anonymous: false,\n        inputs: [],\n        name: '',\n        type: 'event'\n    };\n    var match = fragment.match(regexParen);\n    if (!match) {\n        throw new Error('invalid event: ' + fragment);\n    }\n    abi.name = match[1].trim();\n    splitNesting(match[2]).forEach(function (param) {\n        param = parseParam(param, true);\n        param.indexed = !!param.indexed;\n        abi.inputs.push(param);\n    });\n    match[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'anonymous':\n                abi.anonymous = true;\n                break;\n            case '':\n                break;\n            default:\n                errors.info('unknown modifier: ' + modifier);\n        }\n    });\n    if (abi.name && !abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + abi.name + '\"');\n    }\n    return abi;\n}\nfunction parseSignatureFunction(fragment) {\n    var abi = {\n        constant: false,\n        gas: null,\n        inputs: [],\n        name: '',\n        outputs: [],\n        payable: false,\n        stateMutability: null,\n        type: 'function'\n    };\n    var comps = fragment.split('@');\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            throw new Error('invalid signature');\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            throw new Error('invalid signature gas');\n        }\n        abi.gas = bignumber_1.bigNumberify(comps[1]);\n        fragment = comps[0];\n    }\n    comps = fragment.split(' returns ');\n    var left = comps[0].match(regexParen);\n    if (!left) {\n        throw new Error('invalid signature');\n    }\n    abi.name = left[1].trim();\n    if (!abi.name.match(regexIdentifier)) {\n        throw new Error('invalid identifier: \"' + left[1] + '\"');\n    }\n    splitNesting(left[2]).forEach(function (param) {\n        abi.inputs.push(parseParam(param));\n    });\n    left[3].split(' ').forEach(function (modifier) {\n        switch (modifier) {\n            case 'constant':\n                abi.constant = true;\n                break;\n            case 'payable':\n                abi.payable = true;\n                abi.stateMutability = 'payable';\n                break;\n            case 'pure':\n                abi.constant = true;\n                abi.stateMutability = 'pure';\n                break;\n            case 'view':\n                abi.constant = true;\n                abi.stateMutability = 'view';\n                break;\n            case 'external':\n            case 'public':\n            case '':\n                break;\n            default:\n                errors.info('unknown modifier: ' + modifier);\n        }\n    });\n    // We have outputs\n    if (comps.length > 1) {\n        var right = comps[1].match(regexParen);\n        if (right[1].trim() != '' || right[3].trim() != '') {\n            throw new Error('unexpected tokens');\n        }\n        splitNesting(right[2]).forEach(function (param) {\n            abi.outputs.push(parseParam(param));\n        });\n    }\n    if (abi.name === 'constructor') {\n        abi.type = \"constructor\";\n        if (abi.outputs.length) {\n            throw new Error('constructor may not have outputs');\n        }\n        delete abi.name;\n        delete abi.outputs;\n    }\n    return abi;\n}\nfunction parseParamType(type) {\n    return parseParam(type, true);\n}\nexports.parseParamType = parseParamType;\n// @TODO: Allow a second boolean to expose names\nfunction formatParamType(paramType) {\n    return getParamCoder(exports.defaultCoerceFunc, paramType).type;\n}\nexports.formatParamType = formatParamType;\n// @TODO: Allow a second boolean to expose names and modifiers\nfunction formatSignature(fragment) {\n    return fragment.name + '(' + fragment.inputs.map(function (i) { return formatParamType(i); }).join(',') + ')';\n}\nexports.formatSignature = formatSignature;\nfunction parseSignature(fragment) {\n    if (typeof (fragment) === 'string') {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        fragment = fragment.replace(/\\s/g, ' ');\n        fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n        fragment = fragment.trim();\n        if (fragment.substring(0, 6) === 'event ') {\n            return parseSignatureEvent(fragment.substring(6).trim());\n        }\n        else {\n            if (fragment.substring(0, 9) === 'function ') {\n                fragment = fragment.substring(9);\n            }\n            return parseSignatureFunction(fragment.trim());\n        }\n    }\n    throw new Error('unknown signature');\n}\nexports.parseSignature = parseSignature;\nvar Coder = /** @class */ (function () {\n    function Coder(coerceFunc, name, type, localName, dynamic) {\n        this.coerceFunc = coerceFunc;\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    return Coder;\n}());\n// Clones the functionality of an existing Coder, but without a localName\nvar CoderAnonymous = /** @class */ (function (_super) {\n    __extends(CoderAnonymous, _super);\n    function CoderAnonymous(coder) {\n        var _this = _super.call(this, coder.coerceFunc, coder.name, coder.type, undefined, coder.dynamic) || this;\n        properties_1.defineReadOnly(_this, 'coder', coder);\n        return _this;\n    }\n    CoderAnonymous.prototype.encode = function (value) { return this.coder.encode(value); };\n    CoderAnonymous.prototype.decode = function (data, offset) { return this.coder.decode(data, offset); };\n    return CoderAnonymous;\n}(Coder));\nvar CoderNull = /** @class */ (function (_super) {\n    __extends(CoderNull, _super);\n    function CoderNull(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'null', '', localName, false) || this;\n    }\n    CoderNull.prototype.encode = function (value) {\n        return bytes_1.arrayify([]);\n    };\n    CoderNull.prototype.decode = function (data, offset) {\n        if (offset > data.length) {\n            throw new Error('invalid null');\n        }\n        return {\n            consumed: 0,\n            value: this.coerceFunc('null', undefined)\n        };\n    };\n    return CoderNull;\n}(Coder));\nvar CoderNumber = /** @class */ (function (_super) {\n    __extends(CoderNumber, _super);\n    function CoderNumber(coerceFunc, size, signed, localName) {\n        var _this = this;\n        var name = ((signed ? 'int' : 'uint') + (size * 8));\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.size = size;\n        _this.signed = signed;\n        return _this;\n    }\n    CoderNumber.prototype.encode = function (value) {\n        try {\n            var v = bignumber_1.bigNumberify(value);\n            if (this.signed) {\n                var bounds = constants_1.MaxUint256.maskn(this.size * 8 - 1);\n                if (v.gt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n                bounds = bounds.add(constants_1.One).mul(constants_1.NegativeOne);\n                if (v.lt(bounds)) {\n                    throw new Error('out-of-bounds');\n                }\n            }\n            else if (v.lt(constants_1.Zero) || v.gt(constants_1.MaxUint256.maskn(this.size * 8))) {\n                throw new Error('out-of-bounds');\n            }\n            v = v.toTwos(this.size * 8).maskn(this.size * 8);\n            if (this.signed) {\n                v = v.fromTwos(this.size * 8).toTwos(256);\n            }\n            return bytes_1.padZeros(bytes_1.arrayify(v), 32);\n        }\n        catch (error) {\n            errors.throwError('invalid number value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: value\n            });\n        }\n        return null;\n    };\n    CoderNumber.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        var junkLength = 32 - this.size;\n        var value = bignumber_1.bigNumberify(data.slice(offset + junkLength, offset + 32));\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        else {\n            value = value.maskn(this.size * 8);\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, value),\n        };\n    };\n    return CoderNumber;\n}(Coder));\nvar uint256Coder = new CoderNumber(function (type, value) { return value; }, 32, false, 'none');\nvar CoderBoolean = /** @class */ (function (_super) {\n    __extends(CoderBoolean, _super);\n    function CoderBoolean(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bool', 'bool', localName, false) || this;\n    }\n    CoderBoolean.prototype.encode = function (value) {\n        return uint256Coder.encode(!!value ? 1 : 0);\n    };\n    CoderBoolean.prototype.decode = function (data, offset) {\n        try {\n            var result = uint256Coder.decode(data, offset);\n        }\n        catch (error) {\n            if (error.reason === 'insufficient data for uint256 type') {\n                errors.throwError('insufficient data for boolean type', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'boolean',\n                    value: error.value\n                });\n            }\n            throw error;\n        }\n        return {\n            consumed: result.consumed,\n            value: this.coerceFunc('bool', !result.value.isZero())\n        };\n    };\n    return CoderBoolean;\n}(Coder));\nvar CoderFixedBytes = /** @class */ (function (_super) {\n    __extends(CoderFixedBytes, _super);\n    function CoderFixedBytes(coerceFunc, length, localName) {\n        var _this = this;\n        var name = ('bytes' + length);\n        _this = _super.call(this, coerceFunc, name, name, localName, false) || this;\n        _this.length = length;\n        return _this;\n    }\n    CoderFixedBytes.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            var data = bytes_1.arrayify(value);\n            if (data.length !== this.length) {\n                throw new Error('incorrect data length');\n            }\n            result.set(data);\n        }\n        catch (error) {\n            errors.throwError('invalid ' + this.name + ' value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: (error.value || value)\n            });\n        }\n        return result;\n    };\n    CoderFixedBytes.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for ' + this.name + ' type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: this.name,\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc(this.name, bytes_1.hexlify(data.slice(offset, offset + this.length)))\n        };\n    };\n    return CoderFixedBytes;\n}(Coder));\nvar CoderAddress = /** @class */ (function (_super) {\n    __extends(CoderAddress, _super);\n    function CoderAddress(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'address', 'address', localName, false) || this;\n    }\n    CoderAddress.prototype.encode = function (value) {\n        var result = new Uint8Array(32);\n        try {\n            result.set(bytes_1.arrayify(address_1.getAddress(value)), 12);\n        }\n        catch (error) {\n            errors.throwError('invalid address', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: value\n            });\n        }\n        return result;\n    };\n    CoderAddress.prototype.decode = function (data, offset) {\n        if (data.length < offset + 32) {\n            errors.throwError('insufficient data for address type', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'address',\n                value: bytes_1.hexlify(data.slice(offset, offset + 32))\n            });\n        }\n        return {\n            consumed: 32,\n            value: this.coerceFunc('address', address_1.getAddress(bytes_1.hexlify(data.slice(offset + 12, offset + 32))))\n        };\n    };\n    return CoderAddress;\n}(Coder));\nfunction _encodeDynamicBytes(value) {\n    var dataLength = 32 * Math.ceil(value.length / 32);\n    var padding = new Uint8Array(dataLength - value.length);\n    return bytes_1.concat([\n        uint256Coder.encode(value.length),\n        value,\n        padding\n    ]);\n}\nfunction _decodeDynamicBytes(data, offset, localName) {\n    if (data.length < offset + 32) {\n        errors.throwError('insufficient data for dynamicBytes length', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32))\n        });\n    }\n    var length = uint256Coder.decode(data, offset).value;\n    try {\n        length = length.toNumber();\n    }\n    catch (error) {\n        errors.throwError('dynamic bytes count too large', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: length.toString()\n        });\n    }\n    if (data.length < offset + 32 + length) {\n        errors.throwError('insufficient data for dynamicBytes type', errors.INVALID_ARGUMENT, {\n            arg: localName,\n            coderType: 'dynamicBytes',\n            value: bytes_1.hexlify(data.slice(offset, offset + 32 + length))\n        });\n    }\n    return {\n        consumed: 32 + 32 * Math.ceil(length / 32),\n        value: data.slice(offset + 32, offset + 32 + length),\n    };\n}\nvar CoderDynamicBytes = /** @class */ (function (_super) {\n    __extends(CoderDynamicBytes, _super);\n    function CoderDynamicBytes(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'bytes', 'bytes', localName, true) || this;\n    }\n    CoderDynamicBytes.prototype.encode = function (value) {\n        try {\n            return _encodeDynamicBytes(bytes_1.arrayify(value));\n        }\n        catch (error) {\n            errors.throwError('invalid bytes value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'bytes',\n                value: error.value\n            });\n        }\n        return null;\n    };\n    CoderDynamicBytes.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('bytes', bytes_1.hexlify(result.value));\n        return result;\n    };\n    return CoderDynamicBytes;\n}(Coder));\nvar CoderString = /** @class */ (function (_super) {\n    __extends(CoderString, _super);\n    function CoderString(coerceFunc, localName) {\n        return _super.call(this, coerceFunc, 'string', 'string', localName, true) || this;\n    }\n    CoderString.prototype.encode = function (value) {\n        if (typeof (value) !== 'string') {\n            errors.throwError('invalid string value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'string',\n                value: value\n            });\n        }\n        return _encodeDynamicBytes(utf8_1.toUtf8Bytes(value));\n    };\n    CoderString.prototype.decode = function (data, offset) {\n        var result = _decodeDynamicBytes(data, offset, this.localName);\n        result.value = this.coerceFunc('string', utf8_1.toUtf8String(result.value));\n        return result;\n    };\n    return CoderString;\n}(Coder));\nfunction alignSize(size) {\n    return 32 * Math.ceil(size / 32);\n}\nfunction pack(coders, values) {\n    if (Array.isArray(values)) {\n        // do nothing\n    }\n    else if (values && typeof (values) === 'object') {\n        var arrayValues = [];\n        coders.forEach(function (coder) {\n            arrayValues.push(values[coder.localName]);\n        });\n        values = arrayValues;\n    }\n    else {\n        errors.throwError('invalid tuple value', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    if (coders.length !== values.length) {\n        errors.throwError('types/value length mismatch', errors.INVALID_ARGUMENT, {\n            coderType: 'tuple',\n            value: values\n        });\n    }\n    var parts = [];\n    coders.forEach(function (coder, index) {\n        parts.push({ dynamic: coder.dynamic, value: coder.encode(values[index]) });\n    });\n    var staticSize = 0, dynamicSize = 0;\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            staticSize += 32;\n            dynamicSize += alignSize(part.value.length);\n        }\n        else {\n            staticSize += alignSize(part.value.length);\n        }\n    });\n    var offset = 0, dynamicOffset = staticSize;\n    var data = new Uint8Array(staticSize + dynamicSize);\n    parts.forEach(function (part) {\n        if (part.dynamic) {\n            //uint256Coder.encode(dynamicOffset).copy(data, offset);\n            data.set(uint256Coder.encode(dynamicOffset), offset);\n            offset += 32;\n            //part.value.copy(data, dynamicOffset);  @TODO\n            data.set(part.value, dynamicOffset);\n            dynamicOffset += alignSize(part.value.length);\n        }\n        else {\n            //part.value.copy(data, offset);  @TODO\n            data.set(part.value, offset);\n            offset += alignSize(part.value.length);\n        }\n    });\n    return data;\n}\nfunction unpack(coders, data, offset) {\n    var baseOffset = offset;\n    var consumed = 0;\n    var value = [];\n    coders.forEach(function (coder) {\n        if (coder.dynamic) {\n            var dynamicOffset = uint256Coder.decode(data, offset);\n            var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber());\n            // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n            result.consumed = dynamicOffset.consumed;\n        }\n        else {\n            var result = coder.decode(data, offset);\n        }\n        if (result.value != undefined) {\n            value.push(result.value);\n        }\n        offset += result.consumed;\n        consumed += result.consumed;\n    });\n    coders.forEach(function (coder, index) {\n        var name = coder.localName;\n        if (!name) {\n            return;\n        }\n        if (name === 'length') {\n            name = '_length';\n        }\n        if (value[name] != null) {\n            return;\n        }\n        value[name] = value[index];\n    });\n    return {\n        value: value,\n        consumed: consumed\n    };\n}\nvar CoderArray = /** @class */ (function (_super) {\n    __extends(CoderArray, _super);\n    function CoderArray(coerceFunc, coder, length, localName) {\n        var _this = this;\n        var type = (coder.type + '[' + (length >= 0 ? length : '') + ']');\n        var dynamic = (length === -1 || coder.dynamic);\n        _this = _super.call(this, coerceFunc, 'array', type, localName, dynamic) || this;\n        _this.coder = coder;\n        _this.length = length;\n        return _this;\n    }\n    CoderArray.prototype.encode = function (value) {\n        if (!Array.isArray(value)) {\n            errors.throwError('expected array value', errors.INVALID_ARGUMENT, {\n                arg: this.localName,\n                coderType: 'array',\n                value: value\n            });\n        }\n        var count = this.length;\n        var result = new Uint8Array(0);\n        if (count === -1) {\n            count = value.length;\n            result = uint256Coder.encode(count);\n        }\n        errors.checkArgumentCount(count, value.length, ' in coder array' + (this.localName ? (\" \" + this.localName) : \"\"));\n        var coders = [];\n        for (var i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return bytes_1.concat([result, pack(coders, value)]);\n    };\n    CoderArray.prototype.decode = function (data, offset) {\n        // @TODO:\n        //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n        var consumed = 0;\n        var count = this.length;\n        if (count === -1) {\n            try {\n                var decodedLength = uint256Coder.decode(data, offset);\n            }\n            catch (error) {\n                errors.throwError('insufficient data for dynamic array length', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: error.value\n                });\n            }\n            try {\n                count = decodedLength.value.toNumber();\n            }\n            catch (error) {\n                errors.throwError('array count too large', errors.INVALID_ARGUMENT, {\n                    arg: this.localName,\n                    coderType: 'array',\n                    value: decodedLength.value.toString()\n                });\n            }\n            consumed += decodedLength.consumed;\n            offset += decodedLength.consumed;\n        }\n        var coders = [];\n        for (var i = 0; i < count; i++) {\n            coders.push(new CoderAnonymous(this.coder));\n        }\n        var result = unpack(coders, data, offset);\n        result.consumed += consumed;\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderArray;\n}(Coder));\nvar CoderTuple = /** @class */ (function (_super) {\n    __extends(CoderTuple, _super);\n    function CoderTuple(coerceFunc, coders, localName) {\n        var _this = this;\n        var dynamic = false;\n        var types = [];\n        coders.forEach(function (coder) {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        var type = ('tuple(' + types.join(',') + ')');\n        _this = _super.call(this, coerceFunc, 'tuple', type, localName, dynamic) || this;\n        _this.coders = coders;\n        return _this;\n    }\n    CoderTuple.prototype.encode = function (value) {\n        return pack(this.coders, value);\n    };\n    CoderTuple.prototype.decode = function (data, offset) {\n        var result = unpack(this.coders, data, offset);\n        result.value = this.coerceFunc(this.type, result.value);\n        return result;\n    };\n    return CoderTuple;\n}(Coder));\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\nfunction splitNesting(value) {\n    value = value.trim();\n    var result = [];\n    var accum = '';\n    var depth = 0;\n    for (var offset = 0; offset < value.length; offset++) {\n        var c = value[offset];\n        if (c === ',' && depth === 0) {\n            result.push(accum);\n            accum = '';\n        }\n        else {\n            accum += c;\n            if (c === '(') {\n                depth++;\n            }\n            else if (c === ')') {\n                depth--;\n                if (depth === -1) {\n                    throw new Error('unbalanced parenthsis');\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n// @TODO: Is there a way to return \"class\"?\nvar paramTypeSimple = {\n    address: CoderAddress,\n    bool: CoderBoolean,\n    string: CoderString,\n    bytes: CoderDynamicBytes,\n};\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n    if (!components) {\n        components = [];\n    }\n    var coders = [];\n    components.forEach(function (component) {\n        coders.push(getParamCoder(coerceFunc, component));\n    });\n    return new CoderTuple(coerceFunc, coders, localName);\n}\nfunction getParamCoder(coerceFunc, param) {\n    var coder = paramTypeSimple[param.type];\n    if (coder) {\n        return new coder(coerceFunc, param.name);\n    }\n    var match = param.type.match(paramTypeNumber);\n    if (match) {\n        var size = parseInt(match[2] || \"256\");\n        if (size === 0 || size > 256 || (size % 8) !== 0) {\n            errors.throwError('invalid ' + match[1] + ' bit length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderNumber(coerceFunc, size / 8, (match[1] === 'int'), param.name);\n    }\n    var match = param.type.match(paramTypeBytes);\n    if (match) {\n        var size = parseInt(match[1]);\n        if (size === 0 || size > 32) {\n            errors.throwError('invalid bytes length', errors.INVALID_ARGUMENT, {\n                arg: 'param',\n                value: param\n            });\n        }\n        return new CoderFixedBytes(coerceFunc, size, param.name);\n    }\n    var match = param.type.match(paramTypeArray);\n    if (match) {\n        var size = parseInt(match[2] || \"-1\");\n        param = properties_1.shallowCopy(param);\n        param.type = match[1];\n        param = properties_1.deepCopy(param);\n        return new CoderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n    }\n    if (param.type.substring(0, 5) === 'tuple') {\n        return getTupleParamCoder(coerceFunc, param.components, param.name);\n    }\n    if (param.type === '') {\n        return new CoderNull(coerceFunc, param.name);\n    }\n    errors.throwError('invalid type', errors.INVALID_ARGUMENT, {\n        arg: 'type',\n        value: param.type\n    });\n    return null;\n}\nvar AbiCoder = /** @class */ (function () {\n    function AbiCoder(coerceFunc) {\n        errors.checkNew(this, AbiCoder);\n        if (!coerceFunc) {\n            coerceFunc = exports.defaultCoerceFunc;\n        }\n        properties_1.defineReadOnly(this, 'coerceFunc', coerceFunc);\n    }\n    AbiCoder.prototype.encode = function (types, values) {\n        if (types.length !== values.length) {\n            errors.throwError('types/values length mismatch', errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        var coders = [];\n        types.forEach(function (type) {\n            // Convert types to type objects\n            //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n            //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = type;\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return bytes_1.hexlify(new CoderTuple(this.coerceFunc, coders, '_').encode(values));\n    };\n    AbiCoder.prototype.decode = function (types, data) {\n        var coders = [];\n        types.forEach(function (type) {\n            // See encode for details\n            var typeObject = null;\n            if (typeof (type) === 'string') {\n                typeObject = parseParam(type);\n            }\n            else {\n                typeObject = properties_1.deepCopy(type);\n            }\n            coders.push(getParamCoder(this.coerceFunc, typeObject));\n        }, this);\n        return new CoderTuple(this.coerceFunc, coders, '_').decode(bytes_1.arrayify(data), 0).value;\n    };\n    return AbiCoder;\n}());\nexports.AbiCoder = AbiCoder;\nexports.defaultAbiCoder = new AbiCoder();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}