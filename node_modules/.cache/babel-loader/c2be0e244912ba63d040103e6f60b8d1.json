{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.message = void 0;\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:format:utils:exception\");\n\nconst Format = __importStar(require(\"../common\"));\n\nconst AstUtils = __importStar(require(\"../../ast/utils\")); //this function gives an error message\n//for those errors that are meant to possibly\n//be wrapped in a DecodingError and thrown\n\n\nfunction message(error) {\n  switch (error.kind) {\n    case \"UserDefinedTypeNotFoundError\":\n      let typeName = Format.Types.isContractDefinedType(error.type) ? error.type.definingContractName + \".\" + error.type.typeName : error.type.typeName;\n      return `Unknown ${error.type.typeClass} type ${typeName} of id ${error.type.id}`;\n\n    case \"UnsupportedConstantError\":\n      return `Unsupported constant type ${AstUtils.typeClass(error.definition)}`;\n\n    case \"UnusedImmutableError\":\n      return \"Cannot read unused immutable\";\n\n    case \"ReadErrorStack\":\n      return `Can't read stack from position ${error.from} to ${error.to}`;\n\n    case \"ReadErrorBytes\":\n      return `Can't read ${error.length} bytes from ${error.location} starting at ${error.start}`;\n\n    case \"ReadErrorStorage\":\n      if (error.range.length) {\n        return `Can't read ${error.range.length} bytes from storage starting at index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)}`;\n      } else {\n        return `Can't read storage from index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)} to index ${error.range.to.index} in ${slotAddressPrintout(error.range.to.slot)}`;\n      }\n\n    case \"StorageNotSuppliedError\":\n      return `Unknown storage at slot ${error.slot.toString()}`;\n    //note: not actually used at present\n\n    case \"CodeNotSuppliedError\":\n      return `Unknown code for address ${error.address}`;\n    //note: not actually used at present\n  }\n}\n\nexports.message = message;\n\nfunction slotAddressPrintout(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    let {\n      type: keyEncoding,\n      value: keyValue\n    } = keyInfoForPrinting(slot.key);\n    return \"keccak(\" + keyValue + \" as \" + keyEncoding + \", \" + slotAddressPrintout(slot.path) + \") + \" + slot.offset.toString();\n  } else if (slot.path !== undefined) {\n    const pathAddressPrintout = slotAddressPrintout(slot.path);\n    return slot.hashPath ? \"keccak(\" + pathAddressPrintout + \")\" + slot.offset.toString() : pathAddressPrintout + slot.offset.toString();\n  } else {\n    return slot.offset.toString();\n  }\n} //this is like the old toSoliditySha3Input, but for debugging purposes ONLY\n//it will NOT produce correct input to soliditySha3\n//please use mappingKeyAsHex instead if you wish to encode a mapping key.\n\n\nfunction keyInfoForPrinting(input) {\n  switch (input.type.typeClass) {\n    case \"uint\":\n      return {\n        type: \"uint\",\n        value: input.value.asBN.toString()\n      };\n\n    case \"int\":\n      return {\n        type: \"int\",\n        value: input.value.asBN.toString()\n      };\n\n    case \"fixed\":\n      return {\n        type: `fixed256x${input.type.places}`,\n        value: input.value.asBig.toString()\n      };\n\n    case \"ufixed\":\n      return {\n        type: `ufixed256x${input.type.places}`,\n        value: input.value.asBig.toString()\n      };\n\n    case \"bool\":\n      //this is the case that won't work as valid input to soliditySha3 :)\n      return {\n        type: \"uint\",\n        value: input.value.asBoolean.toString()\n      };\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return {\n            type: \"bytes32\",\n            value: input.value.asHex\n          };\n\n        case \"dynamic\":\n          return {\n            type: \"bytes\",\n            value: input.value.asHex\n          };\n      }\n\n    case \"address\":\n      return {\n        type: \"address\",\n        value: input.value.asAddress\n      };\n\n    case \"string\":\n      let coercedInput = input;\n\n      switch (coercedInput.value.kind) {\n        case \"valid\":\n          return {\n            type: \"string\",\n            value: coercedInput.value.asString\n          };\n\n        case \"malformed\":\n          return {\n            type: \"bytes\",\n            value: coercedInput.value.asHex\n          };\n      }\n\n    //fixed and ufixed are skipped for now\n  }\n}","map":{"version":3,"mappings":"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","names":["debug","message","error","kind","typeName","Format","Types","isContractDefinedType","type","definingContractName","typeClass","id","AstUtils","definition","from","to","length","location","start","range","index","slotAddressPrintout","slot","toString","address","exports","key","undefined","path","keyEncoding","value","keyValue","keyInfoForPrinting","offset","pathAddressPrintout","hashPath","input","asBN","places","asBig","asBoolean","asHex","asAddress","coercedInput","asString"],"sourceRoot":"","sources":["../../../../lib/format/utils/exception.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}