{"ast":null,"code":"const OS = require(\"os\");\n\nconst debug = require(\"debug\")(\"debug-utils\");\n\nconst util = require(\"util\");\n\nconst Codec = require(\"@truffle/codec\");\n\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\n\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\n\nhljsDefineSolidity(chromafi.hljs);\n\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\nconst commandReference = {\n  o: \"step over\",\n  i: \"step line / step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  p: \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  l: \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  h: \"print this help\",\n  v: \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  b: \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  B: \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  c: \"continue until breakpoint\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load new transaction\",\n  T: \"unload transaction\",\n  s: \"print stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources except via `;`\",\n  y: \"(if at end) reset & continue to final error\",\n  Y: \"reset & continue to previous error\"\n};\nconst shortCommandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction\",\n  p: \"print state\",\n  l: \"print context\",\n  h: \"print help\",\n  v: \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  b: \"add breakpoint\",\n  B: \"remove breakpoint\",\n  c: \"continue\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load\",\n  T: \"unload\",\n  s: \"stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources\",\n  y: \"reset & go to final error\",\n  Y: \"reset & go to previous error\"\n};\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\nconst DEFAULT_TAB_WIDTH = 8;\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  base: chalk,\n  lineNumbers: chalk,\n  trailingSpace: chalk,\n\n  /* classes hljs-solidity actually uses */\n  keyword: truffleColors.mint,\n  number: truffleColors.red,\n  string: truffleColors.green,\n  params: truffleColors.pink,\n  builtIn: truffleColors.watermelon,\n  built_in: truffleColors.watermelon,\n  //just to be sure\n  literal: truffleColors.watermelon,\n  function: truffleColors.orange,\n  title: truffleColors.orange,\n  class: truffleColors.orange,\n  comment: truffleColors.comment,\n  doctag: truffleColors.comment,\n  operator: truffleColors.blue,\n  punctuation: truffleColors.purple,\n\n  /* classes it might soon use! */\n  meta: truffleColors.pink,\n  metaString: truffleColors.green,\n  \"meta-string\": truffleColors.green,\n  //similar\n\n  /* classes it doesn't currently use but notionally could */\n  type: truffleColors.orange,\n  symbol: truffleColors.orange,\n  metaKeyword: truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint,\n  //again, to be sure\n  property: chalk,\n  //not putting any highlighting here for now\n\n  /* classes that don't make sense for Solidity */\n  regexp: chalk,\n  //solidity does not have regexps\n  subst: chalk,\n  //or string interpolation\n  name: chalk,\n  //or s-expressions\n  builtInName: chalk,\n  //or s-expressions, again\n  \"builtin-name\": chalk,\n  //just to be sure\n\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  section: chalk,\n  tag: chalk,\n  attr: chalk,\n  attribute: chalk,\n  variable: chalk,\n  bullet: chalk,\n  code: chalk,\n  emphasis: chalk,\n  strong: chalk,\n  formula: chalk,\n  link: chalk,\n  quote: chalk,\n  selectorAttr: chalk,\n  //lotta redundancy follows\n  \"selector-attr\": chalk,\n  selectorClass: chalk,\n  \"selector-class\": chalk,\n  selectorId: chalk,\n  \"selector-id\": chalk,\n  selectorPseudo: chalk,\n  \"selector-pseudo\": chalk,\n  selectorTag: chalk,\n  \"selector-tag\": chalk,\n  templateTag: chalk,\n  \"template-tag\": chalk,\n  templateVariable: chalk,\n  \"template-variable\": chalk,\n  addition: chalk,\n  deletion: chalk\n};\nvar DebugUtils = {\n  truffleColors,\n  //make these externally available\n  //panicCode may be either a number, BN, or decimal string\n  panicString: function (panicCode) {\n    let verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n\n    return verbose ? verbosePanicTable[panicCode] || verboseUnknownString : panicTable[panicCode] || unknownString;\n  },\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    } //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n\n\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    } //check #3: do generated source indices start directly after user source indices?\n    //(once again, if there's a gap between them, that's not a problem by itself,\n    //but it probably indicates that something bad is going on)\n\n\n    const lowestInternalIndex = Math.min(...compilation.contracts.map(contract => {\n      //find first defined index\n      let lowestConstructor = (contract.generatedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestConstructor === -1) {\n        lowestConstructor = Infinity;\n      }\n\n      let lowestDeployed = (contract.deployedGeneratedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestDeployed === -1) {\n        lowestDeployed = Infinity;\n      }\n\n      return Math.min(lowestConstructor, lowestDeployed);\n    }));\n\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    } //check #4: are there any AST ID collisions?\n\n\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occurred twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    }; //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n\n\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(source => !source || source.language !== \"Solidity\" || allIDsUnseenSoFar(source.ast));\n  },\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n  formatCommandDescription: function (commandId) {\n    return truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId];\n  },\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined ? `debug(${network}:${txHash.substring(0, 10)}...)> ` : `debug(${network})> `;\n  },\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(`${chalk.bold(\"Warning:\")} The source code for one or more contracts could not be found.`);\n    }\n\n    return lines.join(OS.EOL);\n  },\n  formatHelp: function () {\n    let lastCommand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"n\";\n    var prefix = [\"Commands:\", truffleColors.mint(\"(enter)\") + \" last command entered (\" + shortCommandReference[lastCommand] + \")\"];\n    var commandSections = [[\"o\", \"i\", \"u\", \"n\"], [\"c\", \"Y\"], [\"y\"], [\";\"], [\"g\", \"G\"], [\"p\"], [\"l\"], [\"s\", \"h\"], [\"q\", \"r\", \"t\", \"T\"], [\"b\"], [\"B\"], [\"+\", \"-\"], [\"?\"], [\"v\"], [\":\"]].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n    var suffix = [\"\"];\n    var lines = prefix.concat(commandSections).concat(suffix);\n    return lines.join(OS.EOL);\n  },\n  tabsToSpaces: function (inputLine) {\n    let tabLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TAB_WIDTH;\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n\n    return line;\n  },\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n    return prefix + line;\n  },\n  formatLinePointer: function (line, startCol, endCol, padding) {\n    let tabLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_TAB_WIDTH;\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n      let additional;\n\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (source, range, uncolorizedSource) {\n    let contextBefore = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    let contextAfter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n    //note: beforeLines now includes the line itself\n\n    var beforeLines = source.slice(startIndex, range.start.line + 1).map((line, index) => {\n      let number = startIndex + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var afterLines = source.slice(range.start.line + 1, endIndex + 1).map((line, index) => {\n      let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var pointerStart = range.start.column;\n    var pointerEnd;\n    let uncolorizedLine = uncolorizedSource[range.start.line]; // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat([DebugUtils.formatLinePointer( //the line-pointer formatter doesn't work right with colorized\n    //lines, so we pass in the uncolored version\n    uncolorizedLine, pointerStart, pointerEnd, prefixLength)], afterLines);\n    return allLines.join(OS.EOL);\n  },\n  formatBreakpointLocation: function (breakpoint, here, currentSourceId, sourceNames) {\n    let baseMessage;\n\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here ? `this point in line ${breakpoint.line + 1}` : `a point in line ${breakpoint.line + 1}`; //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"));\n  },\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(2, ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n    let formatted = slots.map((slot, index) => {\n      if (index === 0 || !Codec.Conversion.toBN(slot).eq(Codec.Conversion.toBN(slots[index - 1]).addn(1))) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n\n    for (let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE; wordIndex < calldata.length; wordIndex += Codec.Evm.Utils.WORD_SIZE) {\n      words.push(calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE));\n    }\n\n    let maxWordIndex = (words.length - 1) * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n\n    let formattedSelector;\n\n    if (selector.length > 0) {\n      formattedSelector = \"Calldata:\\n\" + `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` + truffleColors.pink(Codec.Conversion.toHexString(selector).slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \"));\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word).slice(2).padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n    formatted.unshift(formattedSelector);\n    return formatted.join(OS.EOL);\n  },\n  formatValue: function (value) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let nativized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized ? value : new Codec.Export.ResultInspector(value);\n    return util.inspect(valueToInspect, inspectOptions).split(/\\r?\\n/g).map((line, i) => {\n      // don't indent first line\n      const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n      return padding + line;\n    }).join(OS.EOL);\n  },\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    const name = decoding.definedIn ? `${decoding.definedIn.typeName}.${decoding.abi.name}` : decoding.abi.name;\n    return Codec.Export.formatFunctionLike(name, decoding.arguments, inspectOptions, false, indent);\n  },\n  formatStacktrace: function (stacktrace) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    //get message or panic code from stacktrace\n    const {\n      message,\n      panic,\n      custom\n    } = stacktrace[0]; //we want to print inner to outer, so first, let's\n    //reverse\n\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n\n    let lines = stacktrace.map(_ref => {\n      let {\n        functionName,\n        contractName,\n        address,\n        location,\n        isConstructor,\n        type\n      } = _ref;\n      let name;\n\n      if (contractName && functionName) {\n        name = `${contractName}.${functionName}`;\n      } else if (contractName) {\n        name = type === \"external\" && isConstructor ? `new ${contractName}` : contractName; //for internal calls, it doesn't really make sense\n        //to write \"new Contract\"\n      } else if (functionName) {\n        name = functionName;\n      } else {\n        name = \"unknown function\";\n      }\n\n      let locationString;\n\n      if (location) {\n        let {\n          source: {\n            sourcePath\n          },\n          sourceRange: {\n            lines: {\n              start: {\n                line,\n                column\n              }\n            }\n          }\n        } = location;\n        locationString = sourcePath ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n        : \"unknown location\";\n      } else {\n        locationString = \"unknown location\";\n      }\n\n      let addressString = type === \"external\" ? address !== undefined ? ` [address ${address}]` : \" [unknown address]\" : \"\";\n      return `at ${name}${addressString} (${locationString})`;\n    });\n    let status = stacktrace[0].status;\n\n    if (status != undefined) {\n      let statusLine;\n\n      if (message !== undefined) {\n        statusLine = status ? `Error: Improper return (caused message: ${message})` : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status ? `Panic: Improper return (caused ${DebugUtils.panicString(panic).toLowerCase()} (code 0x${panic.toString(16)}))` : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(16)})`;\n      } else if (custom !== undefined) {\n        statusLine = status ? `Error: Improper return (caused custom error)` : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status ? \"Error: Improper return (may be an unexpected self-destruct)\" : \"Error: Revert or exceptional halt\";\n      }\n\n      lines.unshift(statusLine);\n    }\n\n    let indented = lines.map((line, index) => index === 0 ? line : \" \".repeat(indent) + line);\n    return indented.join(OS.EOL);\n  },\n  colorize: function (code) {\n    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Solidity\";\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false,\n      //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n    };\n\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n\n        return chromafi(code, options);\n\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n\n        return chromafi(code, options);\n\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign({}, ...Object.entries(variables).map(_ref2 => {\n      let [variable, value] = _ref2;\n      return variable === \"this\" ? {\n        [replacement]: value\n      } : {\n        [variable]: value\n      };\n    }));\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const {\n      controller\n    } = bugger.selectors;\n\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const {\n        compilationId,\n        id,\n        internal\n      } = source; //stepInto should skip internal sources, but there still might be\n      //one at the end\n\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = { ...sources[compilationId],\n          [id]: source\n        };\n      }\n\n      await bugger.stepInto();\n    }\n\n    await bugger.reset(); //flatten sources before returning\n\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\nmodule.exports = DebugUtils;","map":{"version":3,"names":["OS","require","debug","util","Codec","BN","chromafi","hljsDefineSolidity","hljs","chalk","panicTable","verbosePanicTable","commandReference","o","i","u","n","p","l","h","v","b","B","c","q","r","t","T","s","g","G","y","Y","shortCommandReference","truffleColors","mint","hex","orange","pink","purple","green","red","yellow","blue","comment","hsl","watermelon","periwinkle","DEFAULT_TAB_WIDTH","trufflePalette","base","lineNumbers","trailingSpace","keyword","number","string","params","builtIn","built_in","literal","function","title","class","doctag","operator","punctuation","meta","metaString","type","symbol","metaKeyword","property","regexp","subst","name","builtInName","section","tag","attr","attribute","variable","bullet","code","emphasis","strong","formula","link","quote","selectorAttr","selectorClass","selectorId","selectorPseudo","selectorTag","templateTag","templateVariable","addition","deletion","DebugUtils","panicString","panicCode","verbose","unknownString","verboseUnknownString","isBN","toNumber","_","isUsableCompilation","compilation","unreliableSourceOrder","sources","includes","undefined","lowestInternalIndex","Math","min","contracts","map","contract","lowestConstructor","generatedSources","findIndex","x","Infinity","lowestDeployed","deployedGeneratedSources","length","astIds","Set","allIDsUnseenSoFar","node","Array","isArray","every","id","has","add","Object","values","source","language","ast","formatStartMessage","withTransaction","formatTransactionStartMessage","formatCommandDescription","commandId","formatPrompt","network","txHash","substring","formatAffectedInstances","instances","hasAllSource","lines","keys","address","instance","contractName","push","bold","join","EOL","formatHelp","lastCommand","prefix","commandSections","shortcuts","suffix","concat","tabsToSpaces","inputLine","tabLength","line","counter","remaining","repeat","formatLineNumberPrefix","cols","String","padStart","formatLinePointer","startCol","endCol","padding","output","pointedAt","additional","replace","formatRangeLines","range","uncolorizedSource","contextBefore","contextAfter","startIndex","max","start","endIndex","prefixLength","beforeLines","slice","index","afterLines","pointerStart","column","pointerEnd","uncolorizedLine","end","allLines","formatBreakpointLocation","breakpoint","here","currentSourceId","sourceNames","baseMessage","sourceId","sourceName","formatCurrentInstruction","instruction","pc","formatPC","formattedInstruction","formatInstruction","pushData","toString","formatStack","stack","formatted","item","unshift","formatMemory","memory","maxPrefixLength","Evm","Utils","WORD_SIZE","word","formatStorage","storage","slots","sort","slot","Conversion","toBN","eq","addn","formatCalldata","calldata","selector","SELECTOR_SIZE","words","wordIndex","maxWordIndex","formattedSelector","toHexString","data","padEnd","formatValue","value","indent","nativized","inspectOptions","colors","depth","maxArrayLength","breakLength","valueToInspect","Export","ResultInspector","inspect","split","formatCustomError","decoding","definedIn","typeName","abi","formatFunctionLike","arguments","formatStacktrace","stacktrace","message","panic","custom","reverse","functionName","location","isConstructor","locationString","sourcePath","sourceRange","addressString","status","statusLine","toLowerCase","indented","colorize","options","lang","stripIndent","codePad","lineEndPad","cleanThis","variables","replacement","assign","entries","getTransactionSourcesBeforeStarting","bugger","reset","controller","selectors","view","current","trace","finished","compilationId","internal","stepInto","module","exports"],"sources":["/Users/soheilvafaei/Documents/project/web/resume/ex7/node_modules/@truffle/debug-utils/index.js"],"sourcesContent":["const OS = require(\"os\");\nconst debug = require(\"debug\")(\"debug-utils\");\nconst util = require(\"util\");\nconst Codec = require(\"@truffle/codec\");\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\nhljsDefineSolidity(chromafi.hljs);\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\n\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\n\nconst commandReference = {\n  o: \"step over\",\n  i: \"step line / step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  p: \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  l: \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  h: \"print this help\",\n  v: \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  b: \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  B: \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  c: \"continue until breakpoint\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load new transaction\",\n  T: \"unload transaction\",\n  s: \"print stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources except via `;`\",\n  y: \"(if at end) reset & continue to final error\",\n  Y: \"reset & continue to previous error\"\n};\n\nconst shortCommandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction\",\n  p: \"print state\",\n  l: \"print context\",\n  h: \"print help\",\n  v: \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  b: \"add breakpoint\",\n  B: \"remove breakpoint\",\n  c: \"continue\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load\",\n  T: \"unload\",\n  s: \"stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources\",\n  y: \"reset & go to final error\",\n  Y: \"reset & go to previous error\"\n};\n\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\n\nconst DEFAULT_TAB_WIDTH = 8;\n\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  base: chalk,\n  lineNumbers: chalk,\n  trailingSpace: chalk,\n  /* classes hljs-solidity actually uses */\n  keyword: truffleColors.mint,\n  number: truffleColors.red,\n  string: truffleColors.green,\n  params: truffleColors.pink,\n  builtIn: truffleColors.watermelon,\n  built_in: truffleColors.watermelon, //just to be sure\n  literal: truffleColors.watermelon,\n  function: truffleColors.orange,\n  title: truffleColors.orange,\n  class: truffleColors.orange,\n  comment: truffleColors.comment,\n  doctag: truffleColors.comment,\n  operator: truffleColors.blue,\n  punctuation: truffleColors.purple,\n  /* classes it might soon use! */\n  meta: truffleColors.pink,\n  metaString: truffleColors.green,\n  \"meta-string\": truffleColors.green, //similar\n  /* classes it doesn't currently use but notionally could */\n  type: truffleColors.orange,\n  symbol: truffleColors.orange,\n  metaKeyword: truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint, //again, to be sure\n  property: chalk, //not putting any highlighting here for now\n  /* classes that don't make sense for Solidity */\n  regexp: chalk, //solidity does not have regexps\n  subst: chalk, //or string interpolation\n  name: chalk, //or s-expressions\n  builtInName: chalk, //or s-expressions, again\n  \"builtin-name\": chalk, //just to be sure\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  section: chalk,\n  tag: chalk,\n  attr: chalk,\n  attribute: chalk,\n  variable: chalk,\n  bullet: chalk,\n  code: chalk,\n  emphasis: chalk,\n  strong: chalk,\n  formula: chalk,\n  link: chalk,\n  quote: chalk,\n  selectorAttr: chalk, //lotta redundancy follows\n  \"selector-attr\": chalk,\n  selectorClass: chalk,\n  \"selector-class\": chalk,\n  selectorId: chalk,\n  \"selector-id\": chalk,\n  selectorPseudo: chalk,\n  \"selector-pseudo\": chalk,\n  selectorTag: chalk,\n  \"selector-tag\": chalk,\n  templateTag: chalk,\n  \"template-tag\": chalk,\n  templateVariable: chalk,\n  \"template-variable\": chalk,\n  addition: chalk,\n  deletion: chalk\n};\n\nvar DebugUtils = {\n  truffleColors, //make these externally available\n\n  //panicCode may be either a number, BN, or decimal string\n  panicString: function (panicCode, verbose = false) {\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n    return verbose\n      ? verbosePanicTable[panicCode] || verboseUnknownString\n      : panicTable[panicCode] || unknownString;\n  },\n\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    }\n\n    //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    //check #3: do generated source indices start directly after user source indices?\n    //(once again, if there's a gap between them, that's not a problem by itself,\n    //but it probably indicates that something bad is going on)\n    const lowestInternalIndex = Math.min(\n      ...compilation.contracts.map(contract => {\n        //find first defined index\n        let lowestConstructor = (contract.generatedSources || []).findIndex(\n          x => x !== undefined\n        );\n        if (lowestConstructor === -1) {\n          lowestConstructor = Infinity;\n        }\n        let lowestDeployed = (\n          contract.deployedGeneratedSources || []\n        ).findIndex(x => x !== undefined);\n        if (lowestDeployed === -1) {\n          lowestDeployed = Infinity;\n        }\n        return Math.min(lowestConstructor, lowestDeployed);\n      })\n    );\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    }\n\n    //check #4: are there any AST ID collisions?\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occurred twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    };\n\n    //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(\n      source =>\n        !source ||\n        source.language !== \"Solidity\" ||\n        allIDsUnseenSoFar(source.ast)\n    );\n  },\n\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n\n  formatCommandDescription: function (commandId) {\n    return (\n      truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId]\n    );\n  },\n\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined\n      ? `debug(${network}:${txHash.substring(0, 10)}...)> `\n      : `debug(${network})> `;\n  },\n\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\n        `${chalk.bold(\n          \"Warning:\"\n        )} The source code for one or more contracts could not be found.`\n      );\n    }\n\n    return lines.join(OS.EOL);\n  },\n\n  formatHelp: function (lastCommand = \"n\") {\n    var prefix = [\n      \"Commands:\",\n      truffleColors.mint(\"(enter)\") +\n        \" last command entered (\" +\n        shortCommandReference[lastCommand] +\n        \")\"\n    ];\n\n    var commandSections = [\n      [\"o\", \"i\", \"u\", \"n\"],\n      [\"c\", \"Y\"],\n      [\"y\"],\n      [\";\"],\n      [\"g\", \"G\"],\n      [\"p\"],\n      [\"l\"],\n      [\"s\", \"h\"],\n      [\"q\", \"r\", \"t\", \"T\"],\n      [\"b\"],\n      [\"B\"],\n      [\"+\", \"-\"],\n      [\"?\"],\n      [\"v\"],\n      [\":\"]\n    ].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n\n    var suffix = [\"\"];\n\n    var lines = prefix.concat(commandSections).concat(suffix);\n\n    return lines.join(OS.EOL);\n  },\n\n  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n    return line;\n  },\n\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n\n    return prefix + line;\n  },\n\n  formatLinePointer: function (\n    line,\n    startCol,\n    endCol,\n    padding,\n    tabLength = DEFAULT_TAB_WIDTH\n  ) {\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n\n      let additional;\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (\n    source,\n    range,\n    uncolorizedSource,\n    contextBefore = 2,\n    contextAfter = 0\n  ) {\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n\n    //note: beforeLines now includes the line itself\n    var beforeLines = source\n      .slice(startIndex, range.start.line + 1)\n      .map((line, index) => {\n        let number = startIndex + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n    var afterLines = source\n      .slice(range.start.line + 1, endIndex + 1)\n      .map((line, index) => {\n        let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n\n    var pointerStart = range.start.column;\n    var pointerEnd;\n\n    let uncolorizedLine = uncolorizedSource[range.start.line];\n\n    // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat(\n      [\n        DebugUtils.formatLinePointer(\n          //the line-pointer formatter doesn't work right with colorized\n          //lines, so we pass in the uncolored version\n          uncolorizedLine,\n          pointerStart,\n          pointerEnd,\n          prefixLength\n        )\n      ],\n      afterLines\n    );\n\n    return allLines.join(OS.EOL);\n  },\n\n  formatBreakpointLocation: function (\n    breakpoint,\n    here,\n    currentSourceId,\n    sourceNames\n  ) {\n    let baseMessage;\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here\n        ? `this point in line ${breakpoint.line + 1}`\n        : `a point in line ${breakpoint.line + 1}`;\n      //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(\n      instruction.name + \" \" + (instruction.pushData || \"\")\n    );\n  },\n\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(\n      2,\n      ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length\n    );\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE)\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n\n    let formatted = slots.map((slot, index) => {\n      if (\n        index === 0 ||\n        !Codec.Conversion.toBN(slot).eq(\n          Codec.Conversion.toBN(slots[index - 1]).addn(1)\n        )\n      ) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n    for (\n      let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE;\n      wordIndex < calldata.length;\n      wordIndex += Codec.Evm.Utils.WORD_SIZE\n    ) {\n      words.push(\n        calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE)\n      );\n    }\n    let maxWordIndex =\n      (words.length - 1) * Codec.Evm.Utils.WORD_SIZE +\n      Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n    let formattedSelector;\n    if (selector.length > 0) {\n      formattedSelector =\n        \"Calldata:\\n\" +\n        `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` +\n        truffleColors.pink(\n          Codec.Conversion.toHexString(selector)\n            .slice(2)\n            .padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \")\n        );\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (\n        index * Codec.Evm.Utils.WORD_SIZE +\n        Codec.Evm.Utils.SELECTOR_SIZE\n      )\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word)\n        .slice(2)\n        .padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n\n    formatted.unshift(formattedSelector);\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatValue: function (value, indent = 0, nativized = false) {\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized\n      ? value\n      : new Codec.Export.ResultInspector(value);\n    return util\n      .inspect(valueToInspect, inspectOptions)\n      .split(/\\r?\\n/g)\n      .map((line, i) => {\n        // don't indent first line\n        const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n        return padding + line;\n      })\n      .join(OS.EOL);\n  },\n\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding, indent = 0) {\n    const inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    const name = decoding.definedIn\n      ? `${decoding.definedIn.typeName}.${decoding.abi.name}`\n      : decoding.abi.name;\n    return Codec.Export.formatFunctionLike(\n      name,\n      decoding.arguments,\n      inspectOptions,\n      false,\n      indent\n    );\n  },\n\n  formatStacktrace: function (stacktrace, indent = 2) {\n    //get message or panic code from stacktrace\n    const { message, panic, custom } = stacktrace[0];\n    //we want to print inner to outer, so first, let's\n    //reverse\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n    let lines = stacktrace.map(\n      ({\n        functionName,\n        contractName,\n        address,\n        location,\n        isConstructor,\n        type\n      }) => {\n        let name;\n        if (contractName && functionName) {\n          name = `${contractName}.${functionName}`;\n        } else if (contractName) {\n          name =\n            type === \"external\" && isConstructor\n              ? `new ${contractName}`\n              : contractName;\n          //for internal calls, it doesn't really make sense\n          //to write \"new Contract\"\n        } else if (functionName) {\n          name = functionName;\n        } else {\n          name = \"unknown function\";\n        }\n        let locationString;\n        if (location) {\n          let {\n            source: { sourcePath },\n            sourceRange: {\n              lines: {\n                start: { line, column }\n              }\n            }\n          } = location;\n          locationString = sourcePath\n            ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n            : \"unknown location\";\n        } else {\n          locationString = \"unknown location\";\n        }\n        let addressString =\n          type === \"external\"\n            ? address !== undefined\n              ? ` [address ${address}]`\n              : \" [unknown address]\"\n            : \"\";\n        return `at ${name}${addressString} (${locationString})`;\n      }\n    );\n    let status = stacktrace[0].status;\n    if (status != undefined) {\n      let statusLine;\n      if (message !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused message: ${message})`\n          : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status\n          ? `Panic: Improper return (caused ${DebugUtils.panicString(\n              panic\n            ).toLowerCase()} (code 0x${panic.toString(16)}))`\n          : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(\n              16\n            )})`;\n      } else if (custom !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused custom error)`\n          : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status\n          ? \"Error: Improper return (may be an unexpected self-destruct)\"\n          : \"Error: Revert or exceptional halt\";\n      }\n      lines.unshift(statusLine);\n    }\n    let indented = lines.map((line, index) =>\n      index === 0 ? line : \" \".repeat(indent) + line\n    );\n    return indented.join(OS.EOL);\n  },\n\n  colorize: function (code, language = \"Solidity\") {\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false, //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n    };\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n        return chromafi(code, options);\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n        return chromafi(code, options);\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign(\n      {},\n      ...Object.entries(variables).map(([variable, value]) =>\n        variable === \"this\" ? { [replacement]: value } : { [variable]: value }\n      )\n    );\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const { controller } = bugger.selectors;\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const { compilationId, id, internal } = source;\n      //stepInto should skip internal sources, but there still might be\n      //one at the end\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = {\n          ...sources[compilationId],\n          [id]: source\n        };\n      }\n      await bugger.stepInto();\n    }\n    await bugger.reset();\n    //flatten sources before returning\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\n\nmodule.exports = DebugUtils;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}