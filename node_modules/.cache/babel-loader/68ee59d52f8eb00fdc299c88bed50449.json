{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:storage:allocate\");\n\nconst Compiler = __importStar(require(\"../../compiler\"));\n\nconst Common = __importStar(require(\"../../common\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst Ast = __importStar(require(\"../../ast\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst partition_1 = __importDefault(require(\"lodash/partition\"));\n\nclass UnknownBaseContractIdError extends Error {\n  constructor(derivedId, derivedName, derivedKind, baseId) {\n    const message = `Cannot locate base contract ID ${baseId} of ${derivedKind} ${derivedName} (ID ${derivedId})`;\n    super(message);\n    this.name = \"UnknownBaseContractIdError\";\n    this.derivedId = derivedId;\n    this.derivedName = derivedName;\n    this.derivedKind = derivedKind;\n    this.baseId = baseId;\n  }\n\n}\n\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError; //contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\n\nfunction getStorageAllocations(userDefinedTypesByCompilation) {\n  let allocations = {};\n\n  for (const compilation of Object.values(userDefinedTypesByCompilation)) {\n    const {\n      compiler,\n      types: userDefinedTypes\n    } = compilation;\n\n    for (const dataType of Object.values(compilation.types)) {\n      if (dataType.typeClass === \"struct\") {\n        try {\n          allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);\n        } catch (_a) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n          //note: a better way of handling this would probably be to *mark* it\n          //as failed rather than throwing an exception as that would lead to less\n          //recomputation, but this is simpler and I don't think the recomputation\n          //should really be a problem\n        }\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\n\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  let existingAllocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let allocations = existingAllocations;\n\n  for (const contractInfo of contracts) {\n    let {\n      contractNode: contract,\n      immutableReferences,\n      compiler,\n      compilationId\n    } = contractInfo;\n\n    try {\n      allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n    } catch (_a) {//we're just going to allow failure here and catch the problem elsewhere\n    }\n  }\n\n  return allocations;\n}\n\nexports.getStateAllocations = getStateAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);\n}\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {\n  let offset = 0; //will convert to BN when placing in slot\n\n  let index = Evm.Utils.WORD_SIZE - 1; //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  //otherwise, we need to allocate\n\n  let memberAllocations = [];\n\n  for (const member of members) {\n    let size;\n    ({\n      size,\n      allocations\n    } = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler)); //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n    //if it's sized in bytes but there's not enough room, we also need a new slot\n\n    if (Utils.isWordsLength(size) ? index < Evm.Utils.WORD_SIZE - 1 : size.bytes > index + 1) {\n      index = Evm.Utils.WORD_SIZE - 1;\n      offset += 1;\n    } //otherwise, we remain in place\n\n\n    let range;\n\n    if (Utils.isWordsLength(size)) {\n      //words case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n\n          },\n          index: 0 //...at the beginning of the word.\n\n        },\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n\n          },\n          index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n\n        }\n      };\n    } else {\n      //bytes case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n\n          },\n          index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n\n        },\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset) //end at the current slot...\n\n          },\n          index: index //...at the current position.\n\n        }\n      };\n    }\n\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer: {\n        location: \"storage\",\n        range\n      }\n    }); //finally, adjust the current position.\n    //if it was sized in words, move down that many slots and reset position w/in slot\n\n    if (Utils.isWordsLength(size)) {\n      offset += size.words;\n      index = Evm.Utils.WORD_SIZE - 1;\n    } //if it was sized in bytes, move down an appropriate number of bytes.\n    else {\n      index -= size.bytes; //but if this puts us into the next word, move to the next word.\n\n      if (index < 0) {\n        index = Evm.Utils.WORD_SIZE - 1;\n        offset += 1;\n      }\n    }\n  } //finally, let's determine the overall siz; we're dealing with a struct, so\n  //the size is measured in words\n  //it's one plus the last word used, i.e. one plus the current word... unless the\n  //current word remains entirely unused, then it's just the current word\n  //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n  //empty structs behave in versions where they're legal)\n\n\n  let totalSize;\n\n  if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n    totalSize = {\n      words: offset\n    };\n  } else {\n    totalSize = {\n      words: offset + 1\n    };\n  } //having made our allocation, let's add it to allocations!\n\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    size: totalSize\n  }; //...and we're done!\n\n  return allocations;\n}\n\nfunction getStateVariables(contractNode) {\n  // process for state variables\n  return contractNode.nodes.filter(node => node.nodeType === \"VariableDeclaration\" && node.stateVariable);\n}\n\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  let existingAllocations = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  //we're going to do a 2-deep clone here\n  let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(_ref => {\n    let [compilationId, compilationAllocations] = _ref;\n    return {\n      [compilationId]: Object.assign({}, compilationAllocations)\n    };\n  }));\n\n  if (!immutableReferences) {\n    immutableReferences = {}; //also, let's set this up for convenience\n  } //base contracts are listed from most derived to most base, so we\n  //have to reverse before processing, but reverse() is in place, so we\n  //clone with slice first\n\n\n  let linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse(); //first, let's get all the variables under consideration\n\n  let variables = [].concat(...linearizedBaseContractsFromBase.map(id => {\n    let baseNode = referenceDeclarations[id];\n\n    if (baseNode === undefined) {\n      throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n    }\n\n    return getStateVariables(baseNode).map(definition => ({\n      definition,\n      definedIn: baseNode\n    }));\n  })); //just in case the constant field ever gets removed\n\n  const isConstant = definition => definition.constant || definition.mutability === \"constant\"; //now: we split the variables into storage, constant, and code\n\n\n  let [constantVariables, variableVariables] = (0, partition_1.default)(variables, variable => isConstant(variable.definition)); //why use this function instead of just checking\n  //definition.mutability?\n  //because of a bug in Solidity 0.6.5 that causes the mutability field\n  //not to exist.  So, we also have to check against immutableReferences.\n\n  const isImmutable = definition => definition.mutability === \"immutable\" || definition.id.toString() in immutableReferences;\n\n  let [immutableVariables, storageVariables] = (0, partition_1.default)(variableVariables, variable => isImmutable(variable.definition)); //transform storage variables into data types\n\n  const storageVariableTypes = storageVariables.map(variable => ({\n    name: variable.definition.name,\n    type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n  })); //let's allocate the storage variables using a fictitious ID\n\n  const id = \"-1\";\n  const storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id]; //transform to new format\n\n  const storageVariableAllocations = storageVariables.map((_ref2, index) => {\n    let {\n      definition,\n      definedIn\n    } = _ref2;\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer: storageVariableStorageAllocations.members[index].pointer\n    };\n  }); //now let's create allocations for the immutables\n\n  let immutableVariableAllocations = immutableVariables.map(_ref3 => {\n    let {\n      definition,\n      definedIn\n    } = _ref3;\n    let references = immutableReferences[definition.id.toString()] || [];\n    let pointer;\n\n    if (references.length === 0) {\n      pointer = {\n        location: \"nowhere\"\n      };\n    } else {\n      pointer = {\n        location: \"code\",\n        start: references[0].start,\n        length: references[0].length\n      };\n    }\n\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer\n    };\n  }); //and let's create allocations for the constants\n\n  let constantVariableAllocations = constantVariables.map(_ref4 => {\n    let {\n      definition,\n      definedIn\n    } = _ref4;\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer: {\n        location: \"definition\",\n        definition: definition.value\n      }\n    };\n  }); //now, reweave the three together\n\n  let contractAllocation = [];\n\n  for (let variable of variables) {\n    let arrayToGrabFrom = isConstant(variable.definition) ? constantVariableAllocations : isImmutable(variable.definition) ? immutableVariableAllocations : storageVariableAllocations;\n    contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  } //finally, set things and return\n\n\n  if (!allocations[compilationId]) {\n    allocations[compilationId] = {};\n  }\n\n  allocations[compilationId][contract.id] = {\n    members: contractAllocation\n  };\n  return allocations;\n} //NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\n\n\nfunction storageSize(dataType, userDefinedTypes, allocations, compiler) {\n  return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;\n}\n\nexports.storageSize = storageSize;\n\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //we'll only directly handle reference types here;\n  //direct types will be handled by dispatching to Basic.Allocate.byteLength\n  //in the default case\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      {\n        switch (dataType.kind) {\n          case \"static\":\n            //really a basic type :)\n            return {\n              size: {\n                bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n              },\n              allocations: existingAllocations\n            };\n\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n        }\n      }\n\n    case \"string\":\n    case \"mapping\":\n      return {\n        size: {\n          words: 1\n        },\n        allocations: existingAllocations\n      };\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            //static array case\n            const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n\n            if (length === 0) {\n              //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n              return {\n                size: {\n                  words: 1\n                },\n                allocations: existingAllocations\n              };\n            }\n\n            let {\n              size: baseSize,\n              allocations\n            } = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n\n            if (!Utils.isWordsLength(baseSize)) {\n              //bytes case\n              const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n              debug(\"length %o\", length);\n              const numWords = Math.ceil(length / perWord);\n              return {\n                size: {\n                  words: numWords\n                },\n                allocations\n              };\n            } else {\n              //words case\n              return {\n                size: {\n                  words: baseSize.words * length\n                },\n                allocations\n              };\n            }\n\n        }\n      }\n\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id]; //may be undefined!\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[dataType.id];\n        } //having found our allocation, we can just look up its size\n\n\n        return {\n          size: allocation.size,\n          allocations\n        };\n      }\n\n    case \"userDefinedValueType\":\n      if (Compiler.Utils.solidityFamily(compiler) === \"0.8.7+\") {\n        //UDVTs were introduced in Solidity 0.8.8.  However, in that version,\n        //and that version only, they have a bug where they always take up a\n        //full word in storage regardless of the size of the underlying type.\n        return {\n          size: {\n            words: 1\n          },\n          allocations: existingAllocations\n        };\n      }\n\n    //otherwise, treat them normally\n    //DELIBERATE FALL-TRHOUGH\n\n    default:\n      //otherwise, it's a direct type\n      return {\n        size: {\n          bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n        },\n        allocations: existingAllocations\n      };\n  }\n}","map":{"version":3,"mappings":"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","names":["debug","UnknownBaseContractIdError","Error","constructor","derivedId","derivedName","derivedKind","baseId","message","name","exports","getStorageAllocations","userDefinedTypesByCompilation","allocations","compilation","Object","values","compiler","types","userDefinedTypes","dataType","typeClass","allocateStruct","getStateAllocations","contracts","referenceDeclarations","storageAllocations","existingAllocations","contractInfo","contractNode","contract","immutableReferences","compilationId","allocateContractState","allocateMembers","id","memberTypes","parentId","members","offset","index","Evm","Utils","WORD_SIZE","memberAllocations","member","size","storageSizeAndAllocate","type","isWordsLength","bytes","range","from","slot","bn_js_1","to","words","push","pointer","location","totalSize","getStateVariables","nodes","filter","node","nodeType","stateVariable","assign","entries","map","compilationAllocations","linearizedBaseContractsFromBase","linearizedBaseContracts","slice","reverse","variables","concat","baseNode","undefined","contractKind","definition","definedIn","isConstant","constant","mutability","constantVariables","variableVariables","variable","isImmutable","toString","immutableVariables","storageVariables","storageVariableTypes","Ast","Import","definitionToType","storageVariableStorageAllocations","storageVariableAllocations","immutableVariableAllocations","references","length","start","constantVariableAllocations","value","contractAllocation","arrayToGrabFrom","shift","storageSize","kind","Basic","Allocate","byteLength","toNumber","baseSize","baseType","perWord","Math","floor","numWords","ceil","allocation","storedType","Common","UnknownUserDefinedTypeError","Format","Types","typeString","Compiler","solidityFamily"],"sourceRoot":"","sources":["../../../../lib/storage/allocate/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}