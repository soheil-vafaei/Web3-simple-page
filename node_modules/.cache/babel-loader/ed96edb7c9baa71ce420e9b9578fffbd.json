{"ast":null,"code":"import { isTag, isText } from \"domhandler\";\nimport { filter, findOne } from \"./querying.js\";\nconst Checks = {\n  tag_name(name) {\n    if (typeof name === \"function\") {\n      return elem => isTag(elem) && name(elem.name);\n    } else if (name === \"*\") {\n      return isTag;\n    }\n\n    return elem => isTag(elem) && elem.name === name;\n  },\n\n  tag_type(type) {\n    if (typeof type === \"function\") {\n      return elem => type(elem.type);\n    }\n\n    return elem => elem.type === type;\n  },\n\n  tag_contains(data) {\n    if (typeof data === \"function\") {\n      return elem => isText(elem) && data(elem.data);\n    }\n\n    return elem => isText(elem) && elem.data === data;\n  }\n\n};\n/**\n * @param attrib Attribute to check.\n * @param value Attribute value to look for.\n * @returns A function to check whether the a node has an attribute with a\n *   particular value.\n */\n\nfunction getAttribCheck(attrib, value) {\n  if (typeof value === \"function\") {\n    return elem => isTag(elem) && value(elem.attribs[attrib]);\n  }\n\n  return elem => isTag(elem) && elem.attribs[attrib] === value;\n}\n/**\n * @param a First function to combine.\n * @param b Second function to combine.\n * @returns A function taking a node and returning `true` if either of the input\n *   functions returns `true` for the node.\n */\n\n\nfunction combineFuncs(a, b) {\n  return elem => a(elem) || b(elem);\n}\n/**\n * @param options An object describing nodes to look for.\n * @returns A function executing all checks in `options` and returning `true` if\n *   any of them match a node.\n */\n\n\nfunction compileTest(options) {\n  const funcs = Object.keys(options).map(key => {\n    const value = options[key];\n    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);\n  });\n  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);\n}\n/**\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param node The element to test.\n * @returns Whether the element matches the description in `options`.\n */\n\n\nexport function testElement(options, node) {\n  const test = compileTest(options);\n  return test ? test(node) : true;\n}\n/**\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes that match `options`.\n */\n\nexport function getElements(options, nodes, recurse) {\n  let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n  const test = compileTest(options);\n  return test ? filter(test, nodes, recurse, limit) : [];\n}\n/**\n * @category Legacy Query Functions\n * @param id The unique ID attribute value to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @returns The node with the supplied ID.\n */\n\nexport function getElementById(id, nodes) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!Array.isArray(nodes)) nodes = [nodes];\n  return findOne(getAttribCheck(\"id\", id), nodes, recurse);\n}\n/**\n * @category Legacy Query Functions\n * @param tagName Tag name to search for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `tagName`.\n */\n\nexport function getElementsByTagName(tagName, nodes) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n  return filter(Checks[\"tag_name\"](tagName), nodes, recurse, limit);\n}\n/**\n * @category Legacy Query Functions\n * @param type Element type to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `type`.\n */\n\nexport function getElementsByTagType(type, nodes) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n  return filter(Checks[\"tag_type\"](type), nodes, recurse, limit);\n}","map":{"version":3,"mappings":"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","names":["isTag","isText","filter","findOne","Checks","tag_name","name","elem","tag_type","type","tag_contains","data","getAttribCheck","attrib","value","attribs","combineFuncs","a","b","compileTest","options","funcs","Object","keys","map","key","prototype","hasOwnProperty","call","length","reduce","testElement","node","test","getElements","nodes","recurse","limit","Infinity","getElementById","id","Array","isArray","getElementsByTagName","tagName","getElementsByTagType"],"sourceRoot":"https://raw.githubusercontent.com/fb55/domutils/f7e357b5c210b6731c2a60e0b7b3cfaa1f96b706/src/","sources":["legacy.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}