{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = exports.abiSelector = exports.abiTupleSignature = exports.abiTypeSignature = exports.abiSignature = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:abi-data:utils\");\n\nconst Ast = __importStar(require(\"../ast\"));\n\nconst abi_utils_1 = require(\"@truffle/abi-utils\");\n\nObject.defineProperty(exports, \"abiSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiSignature;\n  }\n});\nObject.defineProperty(exports, \"abiTypeSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiTypeSignature;\n  }\n});\nObject.defineProperty(exports, \"abiTupleSignature\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiTupleSignature;\n  }\n});\nObject.defineProperty(exports, \"abiSelector\", {\n  enumerable: true,\n  get: function () {\n    return abi_utils_1.abiSelector;\n  }\n});\nexports.DEFAULT_CONSTRUCTOR_ABI = {\n  type: \"constructor\",\n  inputs: [],\n  stateMutability: \"nonpayable\"\n}; //note the return value only includes functions!\n\nfunction computeSelectors(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return Object.assign({}, ...abi.filter(abiEntry => abiEntry.type === \"function\").map(abiEntry => ({\n    [(0, abi_utils_1.abiSelector)(abiEntry)]: abiEntry\n  })));\n}\n\nexports.computeSelectors = computeSelectors; //does this ABI have a payable fallback (or receive) function?\n\nfunction abiHasPayableFallback(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return abi.some(abiEntry => (abiEntry.type === \"fallback\" || abiEntry.type === \"receive\") && abiEntry.stateMutability === \"payable\");\n}\n\nexports.abiHasPayableFallback = abiHasPayableFallback; //note: undefined does not match itself :P\n\nfunction abisMatch(entry1, entry2) {\n  //we'll consider two abi entries to match if they have the same\n  //type, name (if applicable), and inputs (if applicable).\n  //since there's already a signature function, we can just use that.\n  if (!entry1 || !entry2) {\n    return false;\n  }\n\n  if (entry1.type !== entry2.type) {\n    return false;\n  }\n\n  switch (entry1.type) {\n    case \"function\":\n    case \"event\":\n    case \"error\":\n      return (0, abi_utils_1.abiSignature)(entry1) === (0, abi_utils_1.abiSignature)(entry2);\n\n    case \"constructor\":\n      return (0, abi_utils_1.abiTupleSignature)(entry1.inputs) === (0, abi_utils_1.abiTupleSignature)(entry2.inputs);\n\n    case \"fallback\":\n    case \"receive\":\n      return true;\n  }\n}\n\nexports.abisMatch = abisMatch;\n\nfunction definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {\n  try {\n    return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));\n  } catch (_) {\n    return false; //if an exception occurs, well, that's not a match!\n  }\n}\n\nexports.definitionMatchesAbi = definitionMatchesAbi;\n\nfunction topicsCount(abiEntry) {\n  let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector\n\n  return abiEntry.inputs.filter(_ref => {\n    let {\n      indexed\n    } = _ref;\n    return indexed;\n  }).length + selectorCount;\n}\n\nexports.topicsCount = topicsCount;\n\nfunction abiEntryIsObviouslyIllTyped(abiEntry) {\n  switch (abiEntry.type) {\n    case \"fallback\":\n    case \"receive\":\n      return false;\n\n    case \"constructor\":\n    case \"event\":\n    case \"error\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);\n\n    case \"function\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) || abiEntry.outputs.some(abiParameterIsObviouslyIllTyped);\n  }\n}\n\nexports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;\n\nfunction abiParameterIsObviouslyIllTyped(abiParameter) {\n  const legalBaseTypeClasses = [\"uint\", \"int\", \"fixed\", \"ufixed\", \"bool\", \"address\", \"bytes\", \"string\", \"function\", \"tuple\"];\n  const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];\n  const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);\n\n  if (abiParameter.components) {\n    return abiParameter.components.some(abiParameterIsObviouslyIllTyped) || baseTypeClassIsObviouslyWrong;\n  } else {\n    return baseTypeClassIsObviouslyWrong;\n  }\n}\n\nfunction abiEntryHasStorageParameters(abiEntry) {\n  const isStorage = parameter => parameter.type.endsWith(\" storage\");\n\n  return abiEntry.type === \"function\" && (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)); //Note the lack of recursion!  Storage parameters can only occur at\n  //top level so there's no need to recurse here\n  //(they can also only occur for functions)\n}\n\nexports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;","map":{"version":3,"mappings":"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","names":["debug","Object","enumerable","get","abi_utils_1","exports","type","inputs","stateMutability","computeSelectors","abi","undefined","assign","filter","abiEntry","map","abiHasPayableFallback","some","abisMatch","entry1","entry2","definitionMatchesAbi","definition","referenceDeclarations","Ast","Utils","definitionToAbi","_","topicsCount","selectorCount","anonymous","indexed","length","abiEntryIsObviouslyIllTyped","abiParameterIsObviouslyIllTyped","outputs","abiParameter","legalBaseTypeClasses","baseTypeClass","match","baseTypeClassIsObviouslyWrong","includes","components","abiEntryHasStorageParameters","isStorage","parameter","endsWith"],"sourceRoot":"","sources":["../../../lib/abi-data/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}