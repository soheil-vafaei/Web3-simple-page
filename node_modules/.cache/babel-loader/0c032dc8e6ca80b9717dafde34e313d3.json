{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:decode\");\n\nconst AstConstant = __importStar(require(\"./ast-constant\"));\n\nconst AbiData = __importStar(require(\"./abi-data\"));\n\nconst Compiler = __importStar(require(\"./compiler\"));\n\nconst Format = __importStar(require(\"./format\"));\n\nconst Basic = __importStar(require(\"./basic\"));\n\nconst Memory = __importStar(require(\"./memory\"));\n\nconst Special = __importStar(require(\"./special\"));\n\nconst Stack = __importStar(require(\"./stack\"));\n\nconst Storage = __importStar(require(\"./storage\"));\n\nconst Topic = __importStar(require(\"./topic\"));\n\nfunction* decode(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return Format.Utils.Circularity.tie(yield* decodeDispatch(dataType, pointer, info, options));\n}\n\nexports.default = decode;\n\nfunction* decodeDispatch(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  debug(\"type %O\", dataType);\n  debug(\"pointer %O\", pointer);\n\n  switch (pointer.location) {\n    case \"storage\":\n      return yield* Storage.Decode.decodeStorage(dataType, pointer, info);\n\n    case \"stack\":\n      return yield* Stack.Decode.decodeStack(dataType, pointer, info);\n\n    case \"stackliteral\":\n      return yield* Stack.Decode.decodeLiteral(dataType, pointer, info);\n\n    case \"definition\":\n      return yield* AstConstant.Decode.decodeConstant(dataType, pointer, info);\n\n    case \"special\":\n      return yield* Special.Decode.decodeSpecial(dataType, pointer, info);\n\n    case \"calldata\":\n    case \"eventdata\":\n    case \"returndata\":\n      return yield* AbiData.Decode.decodeAbi(dataType, pointer, info, options);\n\n    case \"eventtopic\":\n      return yield* Topic.Decode.decodeTopic(dataType, pointer, info, options);\n\n    case \"code\":\n    case \"nowhere\":\n      //currently only basic types can go in code, so we'll dispatch directly to decodeBasic\n      //(if it's a nowhere pointer, this will return an error result, of course)\n      //(also, Solidity <0.8.9 would always zero-pad immutables regardless of type,\n      //so we have to set the padding mode appropriately to allow for this)\n      return yield* Basic.Decode.decodeBasic(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n        paddingMode: \"defaultOrZero\"\n      }));\n\n    case \"memory\":\n      //this case -- decoding something that resides *directly* in memory,\n      //rather than located via a pointer -- only comes up when decoding immutables\n      //in a constructor.  thus, we turn on the forceRightPadding option on Solidity\n      //versions prior to 0.8.9, because before then all immutables would be right-padded\n      //while in memory\n      switch (Compiler.Utils.solidityFamily(info.currentContext.compiler)) {\n        case \"0.5.x\":\n        case \"0.8.x\":\n        case \"0.8.7+\":\n          return yield* Memory.Decode.decodeMemory(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n            paddingMode: \"right\"\n          }));\n\n        default:\n          return yield* Memory.Decode.decodeMemory(dataType, pointer, info, options);\n      }\n\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA,MAAMA,KAAK,GAAG,qBAAY,cAAZ,CAAd;;AAEA;;AACA;;AACA;;AACA;;AAEA;;AAGA;;AACA;;AACA;;AACA;;AACA;;AAEA,UAAyBC,MAAzB,CACEC,QADF,EAEEC,OAFF,EAGEC,IAHF,EAI8B;EAAA,IAA5BC,OAA4B,uEAAF,EAAE;EAE5B,OAAOC,MAAM,CAACC,KAAP,CAAaC,WAAb,CAAyBC,GAAzB,CACL,OAAOC,cAAc,CAACR,QAAD,EAAWC,OAAX,EAAoBC,IAApB,EAA0BC,OAA1B,CADhB,CAAP;AAGD;;AATDM;;AAWA,UAAUD,cAAV,CACER,QADF,EAEEC,OAFF,EAGEC,IAHF,EAI8B;EAAA,IAA5BC,OAA4B,uEAAF,EAAE;EAE5BL,KAAK,CAAC,SAAD,EAAYE,QAAZ,CAAL;EACAF,KAAK,CAAC,YAAD,EAAeG,OAAf,CAAL;;EAEA,QAAQA,OAAO,CAACS,QAAhB;IACE,KAAK,SAAL;MACE,OAAO,OAAOC,OAAO,CAACC,MAAR,CAAeC,aAAf,CAA6Bb,QAA7B,EAAuCC,OAAvC,EAAgDC,IAAhD,CAAd;;IAEF,KAAK,OAAL;MACE,OAAO,OAAOY,KAAK,CAACF,MAAN,CAAaG,WAAb,CAAyBf,QAAzB,EAAmCC,OAAnC,EAA4CC,IAA5C,CAAd;;IAEF,KAAK,cAAL;MACE,OAAO,OAAOY,KAAK,CAACF,MAAN,CAAaI,aAAb,CAA2BhB,QAA3B,EAAqCC,OAArC,EAA8CC,IAA9C,CAAd;;IAEF,KAAK,YAAL;MACE,OAAO,OAAOe,WAAW,CAACL,MAAZ,CAAmBM,cAAnB,CAAkClB,QAAlC,EAA4CC,OAA5C,EAAqDC,IAArD,CAAd;;IAEF,KAAK,SAAL;MACE,OAAO,OAAOiB,OAAO,CAACP,MAAR,CAAeQ,aAAf,CAA6BpB,QAA7B,EAAuCC,OAAvC,EAAgDC,IAAhD,CAAd;;IAEF,KAAK,UAAL;IACA,KAAK,WAAL;IACA,KAAK,YAAL;MACE,OAAO,OAAOmB,OAAO,CAACT,MAAR,CAAeU,SAAf,CAAyBtB,QAAzB,EAAmCC,OAAnC,EAA4CC,IAA5C,EAAkDC,OAAlD,CAAd;;IAEF,KAAK,YAAL;MACE,OAAO,OAAOoB,KAAK,CAACX,MAAN,CAAaY,WAAb,CAAyBxB,QAAzB,EAAmCC,OAAnC,EAA4CC,IAA5C,EAAkDC,OAAlD,CAAd;;IAEF,KAAK,MAAL;IACA,KAAK,SAAL;MACE;MACA;MACA;MACA;MACA,OAAO,OAAOsB,KAAK,CAACb,MAAN,CAAac,WAAb,CAAyB1B,QAAzB,EAAmCC,OAAnC,EAA4CC,IAA5C,EAAgDyB,gCACzDxB,OADyD,GAClD;QACVyB,WAAW,EAAE;MADH,CADkD,CAAhD,CAAd;;IAKF,KAAK,QAAL;MACE;MACA;MACA;MACA;MACA;MACA,QAAQC,QAAQ,CAACxB,KAAT,CAAeyB,cAAf,CAA8B5B,IAAI,CAAC6B,cAAL,CAAoBC,QAAlD,CAAR;QACE,KAAK,OAAL;QACA,KAAK,OAAL;QACA,KAAK,QAAL;UACE,OAAO,OAAOC,MAAM,CAACrB,MAAP,CAAcsB,YAAd,CAA2BlC,QAA3B,EAAqCC,OAArC,EAA8CC,IAA9C,EAAkDyB,gCAC3DxB,OAD2D,GACpD;YACVyB,WAAW,EAAE;UADH,CADoD,CAAlD,CAAd;;QAIF;UACE,OAAO,OAAOK,MAAM,CAACrB,MAAP,CAAcsB,YAAd,CACZlC,QADY,EAEZC,OAFY,EAGZC,IAHY,EAIZC,OAJY,CAAd;MATJ;;EAzCJ;AA0DD","names":["debug","decode","dataType","pointer","info","options","Format","Utils","Circularity","tie","decodeDispatch","exports","location","Storage","Decode","decodeStorage","Stack","decodeStack","decodeLiteral","AstConstant","decodeConstant","Special","decodeSpecial","AbiData","decodeAbi","Topic","decodeTopic","Basic","decodeBasic","Object","paddingMode","Compiler","solidityFamily","currentContext","compiler","Memory","decodeMemory"],"sourceRoot":"","sources":["../../lib/decode.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}