{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.infoToCompilations = exports.findCompilationAndContract = exports.collectUserDefinedTypesAndTaggedOutputs = exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:compilations:utils\");\n\nconst Ast = __importStar(require(\"../ast\"));\n\nconst compile_common_1 = require(\"@truffle/compile-common\");\n\nconst Format = __importStar(require(\"../format\"));\n\nconst errors_1 = require(\"../errors\");\n\nfunction shimCompilations(inputCompilations) {\n  let shimmedCompilationIdPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return inputCompilations.map((compilation, compilationIndex) => shimCompilation(compilation, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`));\n}\n\nexports.shimCompilations = shimCompilations;\n\nfunction shimCompilation(inputCompilation) {\n  let shimmedCompilationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"shimmedcompilation\";\n  return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {\n    files: inputCompilation.sourceIndexes,\n    sources: inputCompilation.sources,\n    shimmedCompilationId,\n    compiler: inputCompilation.compiler\n  })), {\n    compiler: inputCompilation.compiler\n  });\n}\n\nexports.shimCompilation = shimCompilation;\n/**\n * wrapper around shimContracts that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\n\nfunction shimArtifacts(artifacts, files) {\n  let shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"shimmedcompilation\";\n  return [shimContracts(artifacts, {\n    files,\n    shimmedCompilationId\n  })];\n}\n\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above functions.\n * Note: if you pass in options.sources, options.files will be ignored.\n * Note: if you pass in options.sources, sources will not have\n * compiler set unless you also pass in options.compiler; in this case\n * you should set that up separately, as in shimCompilation().\n */\n\nfunction shimContracts(artifacts) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    files,\n    sources: inputSources\n  } = options;\n  const shimmedCompilationId = options.shimmedCompilationId || \"shimmedcompilation\";\n  let contracts = [];\n  let sources = [];\n  let unreliableSourceOrder = false;\n\n  for (let artifact of artifacts) {\n    let {\n      contractName,\n      bytecode,\n      sourceMap,\n      deployedBytecode,\n      deployedSourceMap,\n      immutableReferences,\n      sourcePath,\n      source,\n      ast,\n      abi,\n      compiler,\n      generatedSources,\n      deployedGeneratedSources\n    } = artifact;\n\n    if (artifact.contract_name) {\n      //just in case\n      contractName = artifact.contract_name; //dunno what's up w/ the type of contract_name, but it needs coercing\n    }\n\n    debug(\"contractName: %s\", contractName);\n    let contractObject = {\n      contractName,\n      bytecode,\n      sourceMap,\n      deployedBytecode,\n      deployedSourceMap,\n      immutableReferences,\n      abi,\n      generatedSources: normalizeGeneratedSources(generatedSources, compiler),\n      deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),\n      compiler\n    };\n    let sourceObject = {\n      sourcePath,\n      source,\n      ast: ast,\n      compiler,\n      language: inferLanguage(ast, compiler, sourcePath)\n    }; //ast needs to be coerced because schema doesn't quite match our types here...\n    //if files or sources was passed, trust that to determine the source index\n    //(assuming we have a sourcePath! currently it will be absent when dealing with\n    //Solidity versions <0.4.9; presumably we will fix this if we ever properly\n    //support versions that old, but for now this is necessary to get debug -x to work)\n\n    if ((files || inputSources) && sourcePath) {\n      //note: we never set the unreliableSourceOrder flag in this branch;\n      //we just trust files/sources.  If this info is bad, then, uh, too bad.\n      debug(\"inputSources: %O\", inputSources);\n      debug(\"files: %O\", files);\n      debug(\"sourcePath: %O\", sourcePath);\n      const index = inputSources ? inputSources.findIndex(source => source.sourcePath === sourcePath) : files.indexOf(sourcePath);\n\n      if (!inputSources) {\n        //if inputSources was passed, we'll handle this separately below\n        sourceObject.id = index.toString(); //HACK\n\n        sources[index] = sourceObject;\n      }\n\n      debug(\"files || inputSources; index: %d\", index);\n      contractObject.primarySourceId = index.toString(); //HACK\n    } else {\n      //if neither was passed, attempt to determine it from the ast\n      let index;\n      let needsAdding;\n\n      if (sourceObject.ast) {\n        //note: this works for both Solidity and Vyper\n        index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n      } else if (compiler && compiler.name === \"vyper\") {\n        index = 0; //if it's Vyper but there's no AST, we can\n        //assume that it was compiled alone and therefore has index 0\n      } //if that didn't work, try the source map\n\n\n      if (index === undefined && (sourceMap || deployedSourceMap)) {\n        const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n        index = extractPrimarySource(sourceMapString);\n      } //else leave undefined for now\n\n\n      ({\n        index,\n        needsAdding,\n        unreliableSourceOrder\n      } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));\n\n      if (needsAdding) {\n        //if we're in this case, inputSources was not passed\n        sourceObject.id = index.toString(); //HACK\n\n        sources[index] = sourceObject;\n        debug(\"else; index: %d\", index);\n      } //whether needed adding or not, set the source ID on the contract object\n\n\n      contractObject.primarySourceId = index.toString(); //HACK\n\n      debug(\"(no index unless mentioned)\");\n    }\n\n    contracts.push(contractObject);\n  } //now: check for id overlap with internal sources\n  //(don't bother if inputSources or files was passed)\n\n\n  if (!inputSources && !files) {\n    for (let contract of contracts) {\n      const {\n        generatedSources,\n        deployedGeneratedSources\n      } = contract;\n\n      for (let index in generatedSources) {\n        if (index in sources) {\n          unreliableSourceOrder = true;\n        }\n      }\n\n      for (let index in deployedGeneratedSources) {\n        if (index in sources) {\n          unreliableSourceOrder = true;\n        }\n      }\n    }\n  }\n\n  let compiler;\n\n  if (options.compiler) {\n    compiler = options.compiler;\n  } else if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    compiler = contracts[0].compiler;\n  } //if input sources was passed, set up the sources object directly :)\n\n\n  if (inputSources) {\n    sources = inputSources.map((_ref, index) => {\n      let {\n        sourcePath,\n        contents: source,\n        ast,\n        language\n      } = _ref;\n      return {\n        sourcePath,\n        source,\n        ast: ast,\n        language,\n        id: index.toString(),\n        compiler //redundant but let's include it\n\n      };\n    });\n  }\n\n  return {\n    id: shimmedCompilationId,\n    unreliableSourceOrder,\n    sources,\n    contracts,\n    compiler\n  };\n}\n\nexports.shimContracts = shimContracts; //note: this works for Vyper too!\n\nfunction sourceIndexForAst(ast) {\n  if (Array.isArray(ast)) {\n    //special handling for old Vyper versions\n    ast = ast[0];\n  }\n\n  if (!ast) {\n    return undefined;\n  }\n\n  return parseInt(ast.src.split(\":\")[2]); //src is given as start:length:file.\n  //we want just the file.\n}\n\nfunction getContractNode(contract, compilation) {\n  const {\n    contractName,\n    sourceMap,\n    deployedSourceMap,\n    primarySourceId\n  } = contract;\n  const {\n    unreliableSourceOrder,\n    sources\n  } = compilation;\n  let sourcesToCheck; //we will attempt to locate the primary source;\n  //if we can't find it, we'll just check every source in this\n  //compilation.\n\n  if (primarySourceId !== undefined) {\n    sourcesToCheck = [sources.find(source => source && source.id === primarySourceId)];\n  } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n    const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n    let sourceId = extractPrimarySource(sourceMapString);\n    sourcesToCheck = [sources[sourceId]];\n  } else {\n    //WARNING: if we end up in this case, we could get the wrong contract!\n    //(but we shouldn't end up here)\n    sourcesToCheck = sources;\n  }\n\n  return sourcesToCheck.reduce((foundNode, source) => {\n    if (foundNode || !source) {\n      return foundNode;\n    }\n\n    if (!source.ast || source.language !== \"Solidity\") {\n      //ignore non-Solidity ASTs for now, we don't support them yet\n      return undefined;\n    }\n\n    return source.ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === contractName);\n  }, undefined);\n}\n\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n */\n\nfunction extractPrimarySource(sourceMap) {\n  if (!sourceMap) {\n    //HACK?\n    return 0; //in this case (e.g. a Vyper contract with an old-style\n    //source map) we infer that it was compiled by itself\n  }\n\n  return parseInt(sourceMap.match(/^[^:]*:[^:]*:([^:]*):/)[1] || \"0\");\n}\n\nfunction normalizeGeneratedSources(generatedSources, compiler) {\n  if (!generatedSources) {\n    return [];\n  }\n\n  if (!isGeneratedSources(generatedSources)) {\n    return generatedSources; //if already normalizeed, leave alone\n  }\n\n  let sources = []; //output\n\n  for (let source of generatedSources) {\n    sources[source.id] = {\n      id: source.id.toString(),\n      sourcePath: source.name,\n      source: source.contents,\n      //ast needs to be coerced because schema doesn't quite match our types here...\n      ast: source.ast,\n      compiler: compiler,\n      language: source.language\n    };\n  }\n\n  return sources;\n} //HACK\n\n\nfunction isGeneratedSources(sources) {\n  //note: for some reason arr.includes(undefined) returns true on sparse arrays\n  //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization\n  return sources.length > 0 && !sources.includes(undefined) && (sources[0].contents !== undefined || sources[0].name !== undefined);\n} //HACK, maybe?\n\n\nfunction inferLanguage(ast, compiler, sourcePath) {\n  if (ast) {\n    if (ast.nodeType === \"SourceUnit\") {\n      return \"Solidity\";\n    } else if (ast.nodeType && ast.nodeType.startsWith(\"Yul\")) {\n      //Every Yul source I've seen has YulBlock as the root, but\n      //I'm not sure that that's *always* the case\n      return \"Yul\";\n    } else if (Array.isArray(ast) || ast.ast_type === \"Module\") {\n      return \"Vyper\";\n    }\n  } else if (compiler) {\n    if (compiler.name === \"vyper\") {\n      return \"Vyper\";\n    } else if (compiler.name === \"solc\") {\n      //assuming sources compiled with solc without sourcePath are Solidity\n      if (sourcePath && sourcePath.endsWith(\".yul\")) {\n        return \"Yul\";\n      } else {\n        return \"Solidity\";\n      }\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n  //first: is this already there? only add it if it's not.\n  //(we determine this by sourcePath if present, and the actual source\n  //contents if not)\n  debug(\"sourcePath: %s\", sourceObject.sourcePath);\n  debug(\"given index: %d\", index);\n  debug(\"sources: %o\", sources.map(source => source.sourcePath));\n\n  if (sources.every(existingSource => existingSource.sourcePath !== sourceObject.sourcePath || !sourceObject.sourcePath && !existingSource.sourcePath && existingSource.source !== sourceObject.source)) {\n    if (unreliableSourceOrder || index === undefined || index in sources) {\n      //if we can't add it at the correct spot, set the\n      //unreliable source order flag\n      debug(\"collision!\");\n      unreliableSourceOrder = true;\n    } //otherwise, just leave things alone\n\n\n    if (unreliableSourceOrder) {\n      //in case of unreliable source order, we'll ignore what indices\n      //things are *supposed* to have and just append things to the end\n      index = sources.length;\n    }\n\n    return {\n      index,\n      needsAdding: true,\n      unreliableSourceOrder\n    };\n  } else {\n    //return index: null indicates don't add this because it's\n    //already present\n    debug(\"already present, not adding\");\n    return {\n      index,\n      needsAdding: false,\n      unreliableSourceOrder\n    };\n  }\n}\n/**\n * convert Vyper source maps to solidity ones\n * (note we won't bother handling the case where the compressed\n * version doesn't exist; that will have to wait for a later version)\n */\n\n\nfunction simpleShimSourceMap(sourceMap) {\n  if (sourceMap === undefined) {\n    return undefined; //undefined case\n  } else if (typeof sourceMap === \"object\") {\n    return sourceMap.pc_pos_map_compressed; //Vyper object case\n  } else {\n    try {\n      return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case\n    } catch (_) {\n      return sourceMap; //Solidity case\n    }\n  }\n}\n\nexports.simpleShimSourceMap = simpleShimSourceMap;\n/**\n * collects user defined types & tagged outputs for a given set of compilations,\n * returning both the definition nodes and (for the types) the type objects\n *\n * \"Tagged outputs\" means user-defined things that are output by a contract\n * (not input to a contract), and which are distinguished by (potentially\n * ambiguous) selectors.  So, events and custom errors are tagged outputs.\n * Function arguments are not tagged outputs (they're not outputs).\n * Return values are not tagged outputs (they don't have a selector).\n * Built-in errors (Error(string) and Panic(uint))... OK I guess those could\n * be considered tagged outputs, but we're only looking at user-defined ones\n * here.\n */\n\nfunction collectUserDefinedTypesAndTaggedOutputs(compilations) {\n  let references = {};\n  let types = {};\n\n  for (const compilation of compilations) {\n    references[compilation.id] = {};\n    types[compilation.id] = {\n      compiler: compilation.compiler,\n      types: {}\n    };\n\n    for (const source of compilation.sources) {\n      if (!source) {\n        continue; //remember, sources could be empty if shimmed!\n      }\n\n      const {\n        ast,\n        compiler,\n        language\n      } = source;\n\n      if (language === \"Solidity\" && ast) {\n        //don't check Yul or Vyper sources!\n        for (const node of ast.nodes) {\n          if (node.nodeType === \"StructDefinition\" || node.nodeType === \"EnumDefinition\" || node.nodeType === \"UserDefinedValueTypeDefinition\" || node.nodeType === \"ContractDefinition\") {\n            references[compilation.id][node.id] = node; //we don't have all the references yet, but we actually don't need them :)\n\n            const dataType = Ast.Import.definitionToStoredType(node, compilation.id, compiler, references[compilation.id]);\n            types[compilation.id].types[dataType.id] = dataType;\n          } else if (node.nodeType === \"EventDefinition\" || node.nodeType === \"ErrorDefinition\") {\n            references[compilation.id][node.id] = node;\n          }\n\n          if (node.nodeType === \"ContractDefinition\") {\n            for (const subNode of node.nodes) {\n              if (subNode.nodeType === \"StructDefinition\" || subNode.nodeType === \"EnumDefinition\" || subNode.nodeType === \"UserDefinedValueTypeDefinition\") {\n                references[compilation.id][subNode.id] = subNode; //we don't have all the references yet, but we only need the\n                //reference to the defining contract, which we just added above!\n\n                const dataType = Ast.Import.definitionToStoredType(subNode, compilation.id, compiler, references[compilation.id]);\n                types[compilation.id].types[dataType.id] = dataType;\n              } else if (subNode.nodeType === \"EventDefinition\" || subNode.nodeType === \"ErrorDefinition\") {\n                references[compilation.id][subNode.id] = subNode;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    definitions: references,\n    typesByCompilation: types,\n    types: Format.Types.forgetCompilations(types)\n  };\n}\n\nexports.collectUserDefinedTypesAndTaggedOutputs = collectUserDefinedTypesAndTaggedOutputs;\n/**\n * Given a list of compilations, and an artifact appearing in one\n * of those compilations, finds the compilation and the corresponding\n * contract object\n * (these may be undefined if they can't be found)\n */\n\nfunction findCompilationAndContract(compilations, artifact) {\n  const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.deployedBytecode);\n  const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.bytecode);\n  let firstNameMatch;\n  let multipleNameMatches = false;\n\n  for (const compilation of compilations) {\n    for (const contract of compilation.contracts) {\n      const nameMatches = contract.contractName === (artifact.contractName || artifact.contract_name);\n\n      if (nameMatches) {\n        if (bytecode) {\n          if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode) === bytecode) {\n            return {\n              compilation,\n              contract\n            };\n          }\n        } else if (deployedBytecode) {\n          if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode) === deployedBytecode) {\n            return {\n              compilation,\n              contract\n            };\n          }\n        } else if (!firstNameMatch) {\n          //if we have a name match, but no bytecode to go by, record this one.\n          //if it turns out to be the only one, we'll return it later.\n          firstNameMatch = {\n            compilation,\n            contract\n          };\n        } else if (!multipleNameMatches) {\n          //on the other hand, if there *is* an existing name match already,\n          //record that we've got multiple.\n          multipleNameMatches = true;\n        }\n      }\n    }\n  } //once the loop is done, if we haven't returned a bytecode match,\n  //check if we've got a unique name match, and return it if so\n\n\n  if (firstNameMatch && !multipleNameMatches) {\n    return firstNameMatch;\n  } //otherwise, if there's no bytecode match, and either no name match\n  //or multiple name matches, just return a default fallback\n\n\n  const defaultContract = {\n    contractName: artifact.contractName || artifact.contract_name,\n    abi: artifact.abi\n  };\n  const defaultCompilation = {\n    id: \"defaultCompilation\",\n    sources: [],\n    contracts: [defaultContract]\n  };\n  return {\n    compilation: defaultCompilation,\n    contract: defaultContract\n  };\n}\n\nexports.findCompilationAndContract = findCompilationAndContract;\n\nfunction projectInfoIsCodecStyle(info) {\n  return Boolean(info.compilations);\n}\n\nfunction projectInfoIsCommonStyle(info) {\n  return Boolean(info.commonCompilations);\n}\n\nfunction projectInfoIsArtifacts(info) {\n  return Boolean(info.artifacts);\n}\n\nfunction infoToCompilations(projectInfo) {\n  if (!projectInfo) {\n    throw new errors_1.NoProjectInfoError();\n  }\n\n  if (projectInfoIsCodecStyle(projectInfo)) {\n    return projectInfo.compilations;\n  } else if (projectInfoIsCommonStyle(projectInfo)) {\n    return shimCompilations(projectInfo.commonCompilations);\n  } else if (projectInfoIsArtifacts(projectInfo)) {\n    return shimArtifacts(projectInfo.artifacts);\n  }\n}\n\nexports.infoToCompilations = infoToCompilations;","map":{"version":3,"mappings":"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","names":["debug","shimCompilations","inputCompilations","shimmedCompilationIdPrefix","map","compilation","compilationIndex","shimCompilation","exports","inputCompilation","shimmedCompilationId","shimContracts","contracts","files","sourceIndexes","sources","compiler","shimArtifacts","artifacts","options","inputSources","unreliableSourceOrder","artifact","contractName","bytecode","sourceMap","deployedBytecode","deployedSourceMap","immutableReferences","sourcePath","source","ast","abi","generatedSources","deployedGeneratedSources","contract_name","contractObject","normalizeGeneratedSources","sourceObject","language","inferLanguage","index","findIndex","indexOf","id","toString","primarySourceId","needsAdding","sourceIndexForAst","name","undefined","sourceMapString","simpleShimSourceMap","extractPrimarySource","getIndexToAddAt","push","contract","length","contents","Array","isArray","parseInt","src","split","getContractNode","sourcesToCheck","find","sourceId","reduce","foundNode","nodes","node","nodeType","match","isGeneratedSources","includes","startsWith","ast_type","endsWith","every","existingSource","pc_pos_map_compressed","JSON","parse","_","collectUserDefinedTypesAndTaggedOutputs","compilations","references","types","dataType","Ast","Import","definitionToStoredType","subNode","definitions","typesByCompilation","Format","Types","forgetCompilations","findCompilationAndContract","compile_common_1","NewToLegacy","forBytecode","firstNameMatch","multipleNameMatches","nameMatches","defaultContract","defaultCompilation","projectInfoIsCodecStyle","info","Boolean","projectInfoIsCommonStyle","commonCompilations","projectInfoIsArtifacts","infoToCompilations","projectInfo","errors_1"],"sourceRoot":"","sources":["../../../lib/compilations/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}