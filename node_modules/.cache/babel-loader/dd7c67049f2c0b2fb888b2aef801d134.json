{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringCases = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:wrap:string\");\n\nconst dispatch_1 = require(\"./dispatch\");\n\nconst errors_1 = require(\"./errors\");\n\nconst decode_1 = require(\"../bytes/decode\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst Utils = __importStar(require(\"./utils\"));\n\nconst Messages = __importStar(require(\"./messages\"));\n\nconst stringCasesBasic = [stringFromString, stringFromBoxedString, stringFromCodecStringValue, stringFromUint8ArrayLike, stringFailureCase];\nexports.stringCases = [stringFromTypeValueInput, ...stringCasesBasic];\n\nfunction* stringFromString(dataType, input, wrapOptions) {\n  if (typeof input !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a string\");\n  }\n\n  if (!Utils.isValidUtf16(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"valid\",\n      asString: input\n    }\n  };\n}\n\nfunction* stringFromBoxedString(dataType, input, wrapOptions) {\n  if (!Utils.isBoxedString(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a boxed string\");\n  } //defer to primitive string case\n\n\n  return yield* stringFromString(dataType, input.valueOf(), wrapOptions);\n}\n\nfunction* stringFromCodecStringValue(dataType, input, wrapOptions) {\n  if (!Utils.isWrappedResult(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a wrapped result\");\n  }\n\n  if (input.type.typeClass !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));\n  }\n\n  if (input.kind !== \"value\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);\n  } //rather than dealing with the different kinds in this case\n  //for rewrapping, we'll just rewrap directly;\n  //yes, this is a bit inconsistent with how we handle this case for other types\n\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: input.value\n  };\n}\n\nfunction* stringFromUint8ArrayLike(dataType, input, wrapOptions) {\n  if (!Utils.isUint8ArrayLike(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a Uint8Array-like\");\n  } //the next series of checks is delegated to a helper fn\n\n\n  (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)\n\n  const info = (0, decode_1.decodeString)(new Uint8Array(input));\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: info\n  };\n}\n\nfunction* stringFromTypeValueInput(dataType, input, wrapOptions) {\n  if (!Utils.isTypeValueInput(input)) {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, \"Input was not a type/value pair\");\n  }\n\n  if (input.type !== \"string\") {\n    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));\n  } //extract value & try again, with loose option turned on\n\n\n  return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), {\n    loose: true\n  }), stringCasesBasic);\n}\n\nfunction* stringFailureCase(dataType, input, wrapOptions) {\n  throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, Messages.notAStringMessage);\n}","map":{"version":3,"mappings":"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","names":["debug","stringCasesBasic","stringFromString","stringFromBoxedString","stringFromCodecStringValue","stringFromUint8ArrayLike","stringFailureCase","exports","stringFromTypeValueInput","dataType","input","wrapOptions","errors_1","name","Utils","isValidUtf16","Messages","invalidUtf16Message","type","kind","value","asString","isBoxedString","valueOf","isWrappedResult","typeClass","wrappedTypeMessage","errorResultMessage","isUint8ArrayLike","info","Uint8Array","isTypeValueInput","specifiedTypeMessage","Object","loose","notAStringMessage"],"sourceRoot":"","sources":["../../../lib/wrap/string.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}