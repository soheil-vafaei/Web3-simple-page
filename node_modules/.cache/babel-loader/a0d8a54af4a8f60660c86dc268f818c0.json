{"ast":null,"code":"const Reason = require(\"./reason\");\n\nconst handlers = require(\"./handlers\");\n\nconst utils = require(\"./utils\");\n\nconst override = {\n  timeoutMessage: \"not mined within\",\n  // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function (context, web3Error) {\n    const constructor = this;\n    let currentBlock = override.defaultMaxBlocks; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n    if (!handlers.ignoreTimeoutError(context, web3Error)) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      const receipt = override.extractReceipt(web3Error.message);\n\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      } //set up gas for getting reason -- we want it to be a lot, but not infinite\n\n\n      const defaultGas = utils.bigNumberify(Math.floor(context.blockLimit / 2)).toHexString(); // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache --vmErrorsOnRPCResponse=true\n\n      const reason = await Reason.get({ ...context.params,\n        gas: defaultGas\n      }, //don't be gas-limited here!\n      constructor.web3, constructor.interfaceAdapter);\n\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += ` -- Reason given: ${reason}.`;\n      }\n\n      return context.promiEvent.reject(web3Error);\n    } // This will run every block from now until contract.timeoutBlocks\n\n\n    const listener = function (pollID) {\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.interfaceAdapter.getTransactionReceipt(context.transactionHash).then(result => {\n        if (!result) return; // make sure reporter receives tx receipt promievent\n\n        handlers.receipt(context, result);\n        result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n      }).catch(err => {\n        clearInterval(pollID);\n        context.promiEvent.reject(err);\n      });\n    }; // Start polling\n\n\n    let currentPollingBlock = await constructor.interfaceAdapter.getBlockNumber();\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.interfaceAdapter.getBlockNumber();\n\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\nmodule.exports = override;","map":{"version":3,"names":["Reason","require","handlers","utils","override","timeoutMessage","defaultWeb3Error","defaultMaxBlocks","pollingInterval","extractReceipt","message","hasReceipt","includes","receiptString","split","trim","JSON","parse","err","start","context","web3Error","constructor","currentBlock","ignoreTimeoutError","receipt","defaultGas","bigNumberify","Math","floor","blockLimit","toHexString","reason","get","params","gas","web3","interfaceAdapter","promiEvent","reject","listener","pollID","timeoutBlocks","clearInterval","getTransactionReceipt","transactionHash","then","result","contractAddress","at","resolve","catch","currentPollingBlock","getBlockNumber","setInterval","newBlock","module","exports"],"sources":["/Users/soheilvafaei/Documents/resume/Web3/web3 simple react web3 js/node_modules/@truffle/contract/lib/override.js"],"sourcesContent":["const Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\nconst utils = require(\"./utils\");\n\nconst override = {\n  timeoutMessage: \"not mined within\", // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\", // Substring of default Web3 error\n  defaultMaxBlocks: 50, // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {\n        // ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function (context, web3Error) {\n    const constructor = this;\n    let currentBlock = override.defaultMaxBlocks;\n\n    // Reject after attempting to get reason string if we shouldn't be waiting.\n    if (!handlers.ignoreTimeoutError(context, web3Error)) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      const receipt = override.extractReceipt(web3Error.message);\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      }\n\n      //set up gas for getting reason -- we want it to be a lot, but not infinite\n      const defaultGas = utils\n        .bigNumberify(Math.floor(context.blockLimit / 2))\n        .toHexString();\n\n      // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache --vmErrorsOnRPCResponse=true\n      const reason = await Reason.get(\n        { ...context.params, gas: defaultGas }, //don't be gas-limited here!\n        constructor.web3,\n        constructor.interfaceAdapter\n      );\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += ` -- Reason given: ${reason}.`;\n      }\n\n      return context.promiEvent.reject(web3Error);\n    }\n\n    // This will run every block from now until contract.timeoutBlocks\n    const listener = function (pollID) {\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.interfaceAdapter\n        .getTransactionReceipt(context.transactionHash)\n        .then(result => {\n          if (!result) return;\n\n          // make sure reporter receives tx receipt promievent\n          handlers.receipt(context, result);\n          result.contractAddress\n            ? constructor\n                .at(result.contractAddress)\n                .then(context.promiEvent.resolve)\n                .catch(context.promiEvent.reject)\n            : constructor.promiEvent.resolve(result);\n        })\n        .catch(err => {\n          clearInterval(pollID);\n          context.promiEvent.reject(err);\n        });\n    };\n\n    // Start polling\n    let currentPollingBlock =\n      await constructor.interfaceAdapter.getBlockNumber();\n\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.interfaceAdapter.getBlockNumber();\n\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\n\nmodule.exports = override;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}