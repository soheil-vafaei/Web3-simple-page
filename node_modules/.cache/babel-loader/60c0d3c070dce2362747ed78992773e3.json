{"ast":null,"code":"const DebugUtils = require(\"@truffle/debug-utils\");\n/**\n * Methods to fetch and decode reason string from ganache when a tx errors.\n */\n\n\nconst reason = {\n  /**\n   * Extracts a reason string from `eth_call` response\n   * @param  {Object}           res  response from `eth_call` to extract reason\n   * @param  {Web3}             web3 a helpful friend\n   * @param  {InterfaceAdapter}      interfaceAdapter a new helpful friend\n   * @return {String|Undefined}      decoded reason string\n   */\n  _extract: function (res, web3, _interfaceAdapter) {\n    //I'm not sure why interfaceAdapter is here if it's not used,\n    //so I just put an underscore in front of its name for now...\n    if (!res || !res.error && !res.result) return;\n    const isObject = res && typeof res === \"object\" && res.error && res.error.data;\n    const isString = res && typeof res === \"object\" && typeof res.result === \"string\";\n\n    if (isObject) {\n      // NOTE that Ganache >=2 returns the reason string when\n      // vmErrorsOnRPCResponse === true, which this code could\n      // be updated to respect (instead of computing here)\n      const data = res.error.data;\n      let resData;\n\n      if (typeof data === \"string\") {\n        resData = data; // geth, Ganache >7.0.0\n      } else if (\"result\" in data) {\n        // there is a single result (Ganache 7.0.0)\n        resData = data.result;\n      } else {\n        // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0\n        // NOTE this only works for a single failed transaction at a time.\n        const hash = Object.keys(data)[0];\n        const errorDetails = data[hash];\n        resData = errorDetails.return\n        /* ganache 2.0 */\n        ;\n      }\n\n      return reason._decode(resData, web3);\n    } else if (isString) {\n      return reason._decode(res.result, web3);\n    } else {\n      return undefined;\n    }\n  },\n  _decode: function (rawData, web3) {\n    const errorStringHash = \"0x08c379a0\";\n    const panicCodeHash = \"0x4e487b71\";\n    const selectorLength = 2 + 2 * 4; //0x then 4 bytes (0x then 8 hex digits)\n\n    const wordLength = 2 * 32; //32 bytes (64 hex digits)\n\n    if (!rawData) {\n      return undefined;\n    } else if (rawData === \"0x\") {\n      //no revert message\n      return undefined;\n    } else if (rawData.startsWith(errorStringHash)) {\n      try {\n        return web3.eth.abi.decodeParameter(\"string\", rawData.slice(selectorLength));\n      } catch (_) {\n        //no reasonable way to handle this case at present\n        return undefined;\n      }\n    } else if (rawData.startsWith(panicCodeHash)) {\n      if (rawData.length === selectorLength + wordLength) {\n        const panicCode = web3.eth.abi.decodeParameter(\"uint256\", rawData.slice(selectorLength)); //this returns a decimal string\n\n        return `Panic: ${DebugUtils.panicString(panicCode)}`;\n      } else {\n        //incorrectly encoded panic...?\n        return undefined;\n      }\n    } else {\n      //we can't reasonably handle custom errors here\n      //(but we can probably assume it is one?)\n      return \"Custom error (could not decode)\";\n    }\n  },\n\n  /**\n   * Runs tx via `eth_call` and resolves a reason string if it exists on the response.\n   * @param  {Object} web3\n   * @param  {Object} interfaceAdapter\n   * @return {String|Undefined}\n   */\n  get: function (params, web3, interfaceAdapter) {\n    const packet = {\n      jsonrpc: \"2.0\",\n      method: \"eth_call\",\n      params: [params, \"latest\"],\n      id: new Date().getTime()\n    };\n    return new Promise(resolve => {\n      web3.currentProvider.send(packet, (err, response) => {\n        const reasonString = reason._extract(response, web3, interfaceAdapter);\n\n        resolve(reasonString);\n      });\n    });\n  }\n};\nmodule.exports = reason;","map":{"version":3,"names":["DebugUtils","require","reason","_extract","res","web3","_interfaceAdapter","error","result","isObject","data","isString","resData","hash","Object","keys","errorDetails","return","_decode","undefined","rawData","errorStringHash","panicCodeHash","selectorLength","wordLength","startsWith","eth","abi","decodeParameter","slice","_","length","panicCode","panicString","get","params","interfaceAdapter","packet","jsonrpc","method","id","Date","getTime","Promise","resolve","currentProvider","send","err","response","reasonString","module","exports"],"sources":["/Users/soheilvafaei/Documents/project/web/web3/ex7/node_modules/@truffle/contract/lib/reason.js"],"sourcesContent":["const DebugUtils = require(\"@truffle/debug-utils\");\n\n/**\n * Methods to fetch and decode reason string from ganache when a tx errors.\n */\n\nconst reason = {\n  /**\n   * Extracts a reason string from `eth_call` response\n   * @param  {Object}           res  response from `eth_call` to extract reason\n   * @param  {Web3}             web3 a helpful friend\n   * @param  {InterfaceAdapter}      interfaceAdapter a new helpful friend\n   * @return {String|Undefined}      decoded reason string\n   */\n  _extract: function (res, web3, _interfaceAdapter) {\n    //I'm not sure why interfaceAdapter is here if it's not used,\n    //so I just put an underscore in front of its name for now...\n    if (!res || (!res.error && !res.result)) return;\n\n    const isObject =\n      res && typeof res === \"object\" && res.error && res.error.data;\n    const isString =\n      res && typeof res === \"object\" && typeof res.result === \"string\";\n\n    if (isObject) {\n      // NOTE that Ganache >=2 returns the reason string when\n      // vmErrorsOnRPCResponse === true, which this code could\n      // be updated to respect (instead of computing here)\n      const data = res.error.data;\n      let resData;\n      if (typeof data === \"string\") {\n        resData = data; // geth, Ganache >7.0.0\n      } else if (\"result\" in data) {\n        // there is a single result (Ganache 7.0.0)\n        resData = data.result;\n      } else {\n        // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0\n        // NOTE this only works for a single failed transaction at a time.\n        const hash = Object.keys(data)[0];\n        const errorDetails = data[hash];\n        resData = errorDetails.return /* ganache 2.0 */;\n      }\n\n      return reason._decode(resData, web3);\n    } else if (isString) {\n      return reason._decode(res.result, web3);\n    } else {\n      return undefined;\n    }\n  },\n\n  _decode: function (rawData, web3) {\n    const errorStringHash = \"0x08c379a0\";\n    const panicCodeHash = \"0x4e487b71\";\n    const selectorLength = 2 + 2 * 4; //0x then 4 bytes (0x then 8 hex digits)\n    const wordLength = 2 * 32; //32 bytes (64 hex digits)\n    if (!rawData) {\n      return undefined;\n    } else if (rawData === \"0x\") {\n      //no revert message\n      return undefined;\n    } else if (rawData.startsWith(errorStringHash)) {\n      try {\n        return web3.eth.abi.decodeParameter(\n          \"string\",\n          rawData.slice(selectorLength)\n        );\n      } catch (_) {\n        //no reasonable way to handle this case at present\n        return undefined;\n      }\n    } else if (rawData.startsWith(panicCodeHash)) {\n      if (rawData.length === selectorLength + wordLength) {\n        const panicCode = web3.eth.abi.decodeParameter(\n          \"uint256\",\n          rawData.slice(selectorLength)\n        ); //this returns a decimal string\n        return `Panic: ${DebugUtils.panicString(panicCode)}`;\n      } else {\n        //incorrectly encoded panic...?\n        return undefined;\n      }\n    } else {\n      //we can't reasonably handle custom errors here\n      //(but we can probably assume it is one?)\n      return \"Custom error (could not decode)\";\n    }\n  },\n\n  /**\n   * Runs tx via `eth_call` and resolves a reason string if it exists on the response.\n   * @param  {Object} web3\n   * @param  {Object} interfaceAdapter\n   * @return {String|Undefined}\n   */\n  get: function (params, web3, interfaceAdapter) {\n    const packet = {\n      jsonrpc: \"2.0\",\n      method: \"eth_call\",\n      params: [params, \"latest\"],\n      id: new Date().getTime()\n    };\n\n    return new Promise(resolve => {\n      web3.currentProvider.send(packet, (err, response) => {\n        const reasonString = reason._extract(response, web3, interfaceAdapter);\n        resolve(reasonString);\n      });\n    });\n  }\n};\n\nmodule.exports = reason;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}