{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definitionToStoredType = exports.definitionToType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:ast:import\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst Compiler = __importStar(require(\"../../compiler\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst import_1 = require(\"../../contexts/import\"); //NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\n\n\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n  let typeClass = Utils.typeClass(definition);\n  let typeHint = Utils.typeStringWithoutLocation(definition);\n\n  switch (typeClass) {\n    case \"bool\":\n      return {\n        typeClass,\n        typeHint\n      };\n\n    case \"address\":\n      {\n        switch (Compiler.Utils.solidityFamily(compiler)) {\n          case \"unknown\": //I guess?\n\n          case \"pre-0.5.0\":\n            return {\n              typeClass,\n              kind: \"general\",\n              typeHint\n            };\n\n          default:\n            return {\n              typeClass,\n              kind: \"specific\",\n              payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"uint\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n\n    case \"int\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n\n    case \"fixed\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n\n    case \"ufixed\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n\n    case \"string\":\n      {\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            typeHint\n          };\n        }\n\n        let location = forceLocation || Utils.referenceType(definition);\n        return {\n          typeClass,\n          location,\n          typeHint\n        };\n      }\n\n    case \"bytes\":\n      {\n        let length = Utils.specifiedSize(definition);\n\n        if (length !== null) {\n          return {\n            typeClass,\n            kind: \"static\",\n            length,\n            typeHint\n          };\n        } else {\n          if (forceLocation === null) {\n            return {\n              typeClass,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n\n          let location = forceLocation || Utils.referenceType(definition);\n          return {\n            typeClass,\n            kind: \"dynamic\",\n            location,\n            typeHint\n          };\n        }\n      }\n\n    case \"array\":\n      {\n        let baseDefinition = Utils.baseDefinition(definition);\n        let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n        let location = forceLocation || Utils.referenceType(definition);\n\n        if (Utils.isDynamicArray(definition)) {\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n        } else {\n          let length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              typeHint\n            };\n          }\n        }\n      }\n\n    case \"mapping\":\n      {\n        let keyDefinition = Utils.keyDefinition(definition); //note that we can skip the scopes argument here! that's only needed when\n        //a general node, rather than a declaration, is being passed in\n\n        let keyType = definitionToType(keyDefinition, compilationId, compiler, null); //suppress the location on the key type (it'll be given as memory but\n        //this is meaningless)\n        //also, we have to tell TypeScript ourselves that this will be an elementary\n        //type; it has no way of knowing that\n\n        debug(\"definition: %O\", definition);\n        let valueDefinition = Utils.valueDefinition(definition);\n        let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            keyType,\n            valueType\n          };\n        }\n\n        return {\n          typeClass,\n          keyType,\n          valueType,\n          location: \"storage\"\n        };\n      }\n\n    case \"function\":\n      {\n        //WARNING! This case will not work unless given the actual\n        //definition!  It should return something *roughly* usable, though.\n        let visibility = Utils.visibility(definition); //undefined if bad node\n\n        let mutability = Utils.mutability(definition); //undefined if bad node\n\n        let [inputParameters, outputParameters] = Utils.parameters(definition) || [[], []]; //HACK\n        //note: don't force a location on these! use the listed location!\n\n        let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n        let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n\n        switch (visibility) {\n          case \"internal\":\n            return {\n              typeClass,\n              visibility,\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n\n          case \"external\":\n            return {\n              typeClass,\n              visibility,\n              kind: \"specific\",\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"struct\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/struct (.*)/)[1];\n        let definingContractName;\n        let typeName;\n\n        if (qualifiedName.includes(\".\")) {\n          [definingContractName, typeName] = qualifiedName.split(\".\");\n        } else {\n          typeName = qualifiedName; //leave definingContractName undefined\n        }\n\n        if (forceLocation === null) {\n          if (definingContractName) {\n            return {\n              typeClass,\n              kind: \"local\",\n              id,\n              typeName,\n              definingContractName\n            };\n          } else {\n            return {\n              typeClass,\n              kind: \"global\",\n              id,\n              typeName\n            };\n          }\n        }\n\n        let location = forceLocation || Utils.referenceType(definition);\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            location\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName,\n            location\n          };\n        }\n      }\n\n    case \"enum\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/enum (.*)/)[1];\n        let definingContractName;\n        let typeName;\n\n        if (qualifiedName.includes(\".\")) {\n          [definingContractName, typeName] = qualifiedName.split(\".\");\n        } else {\n          typeName = qualifiedName; //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let definingContractName;\n        let typeName;\n\n        if (typeHint.includes(\".\")) {\n          [definingContractName, typeName] = typeHint.split(\".\");\n        } else {\n          typeName = typeHint; //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n\n    case \"contract\":\n      {\n        let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);\n        let typeName = typeHint.match(/(contract|library|interface) (.*)/)[2]; //note: we use the type string rather than the type identifier\n        //in order to avoid having to deal with the underscore problem\n\n        let contractKind = Utils.contractKind(definition);\n        return {\n          typeClass,\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind\n        };\n      }\n\n    case \"magic\":\n      {\n        let typeIdentifier = Utils.typeIdentifier(definition);\n        let variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];\n        return {\n          typeClass,\n          variable\n        };\n      }\n  }\n}\n\nexports.definitionToType = definitionToType; //whereas the above takes variable definitions, this takes the actual type\n//definition\n\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n  switch (definition.nodeType) {\n    case \"StructDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        const memberTypes = definition.members.map(member => ({\n          name: member.name,\n          type: definitionToType(member, compilationId, compiler, null)\n        }));\n\n        if (definingContract) {\n          return {\n            typeClass: \"struct\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            memberTypes\n          };\n        } else {\n          return {\n            typeClass: \"struct\",\n            kind: \"global\",\n            id,\n            typeName,\n            memberTypes\n          };\n        }\n      }\n\n    case \"EnumDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        const options = definition.members.map(member => member.name);\n\n        if (definingContract) {\n          return {\n            typeClass: \"enum\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            options\n          };\n        } else {\n          return {\n            typeClass: \"enum\",\n            kind: \"global\",\n            id,\n            typeName,\n            options\n          };\n        }\n      }\n\n    case \"UserDefinedValueTypeDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        let underlyingType = //we know it's that, TS doesn't\n        definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here\n\n        if (definingContract) {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            underlyingType\n          };\n        } else {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"global\",\n            id,\n            typeName,\n            underlyingType\n          };\n        }\n      }\n\n    case \"ContractDefinition\":\n      {\n        let id = (0, import_1.makeTypeId)(definition.id, compilationId);\n        let typeName = definition.name;\n        let contractKind = definition.contractKind;\n        let payable = Utils.isContractPayable(definition);\n        return {\n          typeClass: \"contract\",\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind,\n          payable\n        };\n      }\n  }\n}\n\nexports.definitionToStoredType = definitionToStoredType;\n\nfunction getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {\n  const id = (0, import_1.makeTypeId)(definition.id, compilationId);\n  let definingContractName;\n  let typeName;\n\n  if (definition.canonicalName) {\n    if (definition.canonicalName.includes(\".\")) {\n      [definingContractName, typeName] = definition.canonicalName.split(\".\");\n    } else {\n      typeName = definition.canonicalName;\n    }\n  } else {\n    //due to a bug, in 0.8.8 UDVTs lack a canonicalName.\n    //so we'll set typeName based on name instead of canonicalName,\n    //and set definingContractName below based on definingContract.\n    //(this does mean that we'll mess up a bit if referenceDeclarations\n    //is not passed... but realistically that shouldn't come up?  really the\n    //same kind of hapepns for every type)\n    typeName = definition.name;\n  }\n\n  let definingContract = undefined;\n  ;\n\n  if (referenceDeclarations) {\n    let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === \"ContractDefinition\" && node.nodes.some(subNode => (0, import_1.makeTypeId)(subNode.id, compilationId) === id));\n\n    if (contractDefinition) {\n      definingContract = definitionToStoredType(contractDefinition, compilationId, compiler); //can skip reference declarations\n\n      if (!definingContractName) {\n        definingContractName = contractDefinition.name;\n      }\n    }\n  }\n\n  return {\n    definingContract,\n    definingContractName,\n    typeName,\n    id\n  };\n}","map":{"version":3,"mappings":"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","names":["debug","definitionToType","definition","compilationId","compiler","forceLocation","typeClass","Utils","typeHint","typeStringWithoutLocation","Compiler","solidityFamily","kind","payable","typeIdentifier","bytes","specifiedSize","bits","places","decimalPlaces","location","referenceType","length","baseDefinition","baseType","isDynamicArray","bn_js_1","staticLengthAsString","keyDefinition","keyType","valueDefinition","valueType","visibility","mutability","inputParameters","outputParameters","parameters","inputParameterTypes","map","parameter","outputParameterTypes","id","typeId","qualifiedName","match","definingContractName","typeName","includes","split","contractKind","variable","exports","definitionToStoredType","referenceDeclarations","nodeType","definingContract","getDefiningInfo","memberTypes","members","member","name","type","options","underlyingType","isContractPayable","canonicalName","undefined","contractDefinition","Object","values","find","node","nodes","some","subNode"],"sourceRoot":"","sources":["../../../../lib/ast/import/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}