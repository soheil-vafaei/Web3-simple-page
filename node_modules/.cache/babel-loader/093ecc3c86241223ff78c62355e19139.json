{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst util = require('util');\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source</caption>\n * const n = new NoFilter('Zm9v', 'base64');\n * n.pipe(process.stdout);\n *\n * @example <caption>sink</caption>\n * const n = new Nofilter();\n * // NOTE: 'finish' fires when the input is done writing\n * n.on('finish', function() { console.log(n.toString('base64')); });\n * process.stdin.pipe(n);\n */\n\n\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer} [input] - Source data\n   * @param {string} [inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {Object} [options={}] - Other options\n   * @param {string|Buffer} [options.input=null] - Input source data\n   * @param {string} [options.inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes\n   *   to store in the internal buffer before ceasing to read from the\n   *   underlying resource. Default=16kb, or 16 for objectMode streams\n   * @param {string} [options.encoding=null] - If specified, then buffers will\n   *   be decoded to strings using the specified encoding\n   * @param {boolean} [options.objectMode=false] - Whether this stream should\n   *   behave as a stream of objects. Meaning that stream.read(n) returns a\n   *   single value instead of a Buffer of size n\n   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode\n   *   strings into Buffers before passing them to _write()\n   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'\n   *   events, setting this stream's objectMode based on the objectMode of the\n   *   input stream\n   * @param {boolean} [options.readError=false] - If true, when a read()\n   *   underflows, throw an error.\n   */\n  constructor(input, inputEncoding, options) {\n    if (options == null) {\n      options = {};\n    }\n\n    let inp;\n    let inpE;\n\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input;\n\n          if (inputEncoding != null && typeof inputEncoding === 'object') {\n            options = inputEncoding;\n          }\n        } else {\n          options = input;\n        }\n\n        break;\n\n      case 'string':\n        inp = input;\n\n        if (inputEncoding != null && typeof inputEncoding === 'object') {\n          options = inputEncoding;\n        } else {\n          inpE = inputEncoding;\n        }\n\n        break;\n    }\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (inp == null) {\n      inp = options.input;\n    }\n\n    if (inpE == null) {\n      inpE = options.inputEncoding;\n    }\n\n    delete options.input;\n    delete options.inputEncoding;\n    const watchPipe = options.watchPipe != null ? options.watchPipe : true;\n    delete options.watchPipe;\n    const readError = !!options.readError;\n    delete options.readError;\n    super(options);\n    this.readError = readError;\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        const om = readable._readableState.objectMode;\n\n        if (this.length > 0 && om !== this._readableState.objectMode) {\n          throw new Error('Do not switch objectMode in the middle of the stream');\n        }\n\n        this._readableState.objectMode = om;\n        return this._writableState.objectMode = om;\n      });\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE);\n    }\n  }\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {Object} obj The object to test.\n   * @returns {boolean} true if obj is a NoFilter\n   */\n\n\n  static isNoFilter(obj) {\n    return obj instanceof this;\n  }\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 - The first object to compare\n   * @param {NoFilter} nf2 - The second object to compare\n   * @returns {number} -1, 0, 1 for less, equal, greater\n   *\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')];\n   * arr.sort(NoFilter.compare);\n   */\n\n\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n\n    if (nf1 === nf2) {\n      return 0;\n    } else {\n      return nf1.compare(nf2);\n    }\n  }\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer\n   */\n\n\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters');\n    }\n\n    if (list.length === 0 || length === 0) {\n      return Buffer.alloc(0);\n    }\n\n    if (length == null) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters');\n        }\n\n        return tot + nf.length;\n      }, 0);\n    }\n\n    let allBufs = true;\n    let allObjs = true;\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters');\n      }\n\n      const buf = nf.slice();\n\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false;\n      } else {\n        allBufs = false;\n      }\n\n      return buf;\n    });\n\n    if (allBufs) {\n      return Buffer.concat(bufs, length);\n    }\n\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length);\n    } // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n\n\n    throw new Error('Concatenating mixed object and byte streams not supported');\n  }\n  /**\n   * @private\n   */\n\n\n  _transform(chunk, encoding, callback) {\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    this.push(chunk);\n    callback();\n  }\n  /**\n   * @private\n   */\n\n\n  _bufArray() {\n    let bufs = this._readableState.buffer; // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head;\n      bufs = [];\n\n      while (b != null) {\n        bufs.push(b.data);\n        b = b.next;\n      }\n    }\n\n    return bufs;\n  }\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] - Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer\n   * @throws Error - if readError is true and there was underflow\n   * @fires NoFilter#read\n   */\n\n\n  read(size) {\n    const buf = super.read(size);\n\n    if (buf != null) {\n      /*\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @type {Buffer|string|Object}\n       *\n       */\n      this.emit('read', buf);\n\n      if (this.readError && buf.length < size) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`);\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`);\n    }\n\n    return buf;\n  }\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {function} [cb=null] - finished/error callback used in *addition*\n   *   to the promise\n   * @returns {Promise<Buffer|String>} fulfilled when complete\n   */\n\n\n  promise(cb) {\n    let done = false;\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read();\n\n        if (cb != null && !done) {\n          done = true;\n          cb(null, data);\n        }\n\n        resolve(data);\n      });\n      this.on('error', er => {\n        if (cb != null && !done) {\n          done = true;\n          cb(er);\n        }\n\n        reject(er);\n      });\n    });\n  }\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other - The other object to compare\n   * @returns {Number} -1, 0, 1 for less, equal, greater\n   */\n\n\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n\n    if (this === other) {\n      return 0;\n    } else {\n      const buf1 = this.slice();\n      const buf2 = other.slice(); // these will both be buffers because of the check above.\n\n      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n        return buf1.compare(buf2);\n      }\n\n      throw new Error('Cannot compare streams in object mode');\n    }\n  }\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other\n   * @returns {boolean} Equal?\n   */\n\n\n  equals(other) {\n    return this.compare(other) === 0;\n  }\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {Number} [start=0] - beginning offset\n   * @param {Number} [end=length] - ending offset\n   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n\n\n  slice(start, end) {\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end);\n    }\n\n    const bufs = this._bufArray();\n\n    switch (bufs.length) {\n      case 0:\n        return Buffer.alloc(0);\n\n      case 1:\n        return bufs[0].slice(start, end);\n\n      default:\n        const b = Buffer.concat(bufs); // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n\n        return b.slice(start, end);\n    }\n  }\n  /**\n    * Get a byte by offset.  I didn't want to get into metaprogramming\n    * to give you the `NoFilter[0]` syntax.\n    *\n    * @param {Number} index - The byte to retrieve\n    * @returns {Number} 0-255\n    */\n\n\n  get(index) {\n    return this.slice()[index];\n  }\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so\n   * that round-tripping will produce a Buffer.\n   *\n   * @returns {Object}\n   *\n   * @example output for 'foo'\n   *   { type: 'Buffer', data: [ 102, 111, 111 ] }\n   */\n\n\n  toJSON() {\n    const b = this.slice();\n\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON();\n    } else {\n      return b;\n    }\n  }\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {String} [encoding='utf8'] - Which to use for decoding?\n   * @param {Number} [start=0] - Start offset\n   * @param {Number} [end=length] - End offset\n   * @returns {String}\n   */\n\n\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end);\n\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf);\n    }\n\n    if ((!encoding || encoding === 'utf8') && util.TextDecoder) {\n      const td = new util.TextDecoder('utf8', {\n        fatal: true,\n        ignoreBOM: true\n      });\n      return td.decode(buf);\n    }\n\n    return buf.toString(encoding, start, end);\n  }\n  /**\n   * @private\n   * @deprecated\n   */\n\n\n  inspect(depth, options) {\n    return this[util.inspect.custom](depth, options);\n  }\n  /**\n   * @private\n   */\n\n\n  [util.inspect.custom](depth, options) {\n    const bufs = this._bufArray();\n\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        if (options != null ? options.stylize : undefined) {\n          return options.stylize(b.toString('hex'), 'string');\n        } else {\n          return b.toString('hex');\n        }\n      } else {\n        return util.inspect(b, options);\n      }\n    }).join(', ');\n    return `${this.constructor.name} [${hex}]`;\n  }\n  /**\n   * Current readable length, in bytes.\n   *\n   * @member {number}\n   * @readonly\n   */\n\n\n  get length() {\n    return this._readableState.length;\n  }\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val - The value to write\n   * @returns {boolean} true on success\n   */\n\n\n  writeBigInt(val) {\n    let str = val.toString(16);\n\n    if (val < 0) {\n      // two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2));\n      const mask = BigInt(1) << sz * BigInt(8);\n      val = mask + val;\n      str = val.toString(16);\n    }\n\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n\n    return this.push(Buffer.from(str, 'hex'));\n  }\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number}  [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n\n\n  readUBigInt(len) {\n    const b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return BigInt('0x' + b.toString('hex'));\n  }\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n\n\n  readBigInt(len) {\n    const b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    let ret = BigInt('0x' + b.toString('hex')); // negative?\n\n    if (b[0] & 0x80) {\n      // two's complement\n      const mask = BigInt(1) << BigInt(b.length) * BigInt(8);\n      ret = ret - mask;\n    }\n\n    return ret;\n  }\n\n}\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\n\n\nfunction _read_gen(meth, len) {\n  return function (val) {\n    const b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b[meth].call(b, 0, true);\n  };\n}\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\n\n\nfunction _write_gen(meth, len) {\n  return function (val) {\n    const b = Buffer.alloc(len);\n    b[meth].call(b, val, 0, true);\n    return this.push(b);\n  };\n}\n\nObject.assign(NoFilter.prototype, {\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @function writeUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value - 0-255\n   * @returns {boolean} true on success\n   */\n  writeUInt8: _write_gen('writeUInt8', 1),\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16LE: _write_gen('writeUInt16LE', 2),\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16BE: _write_gen('writeUInt16BE', 2),\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32LE: _write_gen('writeUInt32LE', 4),\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32BE: _write_gen('writeUInt32BE', 4),\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @function writeInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt8: _write_gen('writeInt8', 1),\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16LE: _write_gen('writeInt16LE', 2),\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16BE: _write_gen('writeInt16BE', 2),\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32LE: _write_gen('writeInt32LE', 4),\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32BE: _write_gen('writeInt32BE', 4),\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatLE: _write_gen('writeFloatLE', 4),\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatBE: _write_gen('writeFloatBE', 4),\n\n  /**\n   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleLE: _write_gen('writeDoubleLE', 8),\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleBE: _write_gen('writeDoubleBE', 8),\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @function readUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt8: _read_gen('readUInt8', 1),\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16LE: _read_gen('readUInt16LE', 2),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16BE: _read_gen('readUInt16BE', 2),\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32LE: _read_gen('readUInt32LE', 4),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32BE: _read_gen('readUInt32BE', 4),\n\n  /**\n   * Read a signed 8-bit integer from the stream.\n   * Consumes 1 byte.\n   *\n   * @function readInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt8: _read_gen('readInt8', 1),\n\n  /**\n   * Read a signed 16-bit little-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16LE: _read_gen('readInt16LE', 2),\n\n  /**\n   * Read a signed 16-bit big-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16BE: _read_gen('readInt16BE', 2),\n\n  /**\n   * Read a signed 32-bit little-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32LE: _read_gen('readInt32LE', 4),\n\n  /**\n   * Read a signed 32-bit big-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32BE: _read_gen('readInt32BE', 4),\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatLE: _read_gen('readFloatLE', 4),\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatBE: _read_gen('readFloatBE', 4),\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleLE: _read_gen('readDoubleLE', 8),\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleBE: _read_gen('readDoubleBE', 8)\n});\nmodule.exports = NoFilter;","map":{"version":3,"names":["stream","require","util","NoFilter","Transform","constructor","input","inputEncoding","options","inp","inpE","Buffer","isBuffer","watchPipe","readError","on","readable","om","_readableState","objectMode","length","Error","_writableState","end","isNoFilter","obj","compare","nf1","nf2","TypeError","concat","list","Array","isArray","alloc","reduce","tot","nf","allBufs","allObjs","bufs","map","buf","slice","_transform","chunk","encoding","callback","from","push","_bufArray","buffer","b","head","data","next","read","size","emit","promise","cb","done","Promise","resolve","reject","er","other","buf1","buf2","equals","start","get","index","toJSON","toString","JSON","stringify","TextDecoder","td","fatal","ignoreBOM","decode","inspect","depth","custom","hex","stylize","undefined","join","name","writeBigInt","val","str","sz","BigInt","Math","floor","mask","readUBigInt","len","readBigInt","ret","_read_gen","meth","call","_write_gen","Object","assign","prototype","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","readUInt8","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","module","exports"],"sources":["/Users/soheilvafaei/Documents/project/web/web3/ex7/node_modules/nofilter/lib/index.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source</caption>\n * const n = new NoFilter('Zm9v', 'base64');\n * n.pipe(process.stdout);\n *\n * @example <caption>sink</caption>\n * const n = new Nofilter();\n * // NOTE: 'finish' fires when the input is done writing\n * n.on('finish', function() { console.log(n.toString('base64')); });\n * process.stdin.pipe(n);\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer} [input] - Source data\n   * @param {string} [inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {Object} [options={}] - Other options\n   * @param {string|Buffer} [options.input=null] - Input source data\n   * @param {string} [options.inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes\n   *   to store in the internal buffer before ceasing to read from the\n   *   underlying resource. Default=16kb, or 16 for objectMode streams\n   * @param {string} [options.encoding=null] - If specified, then buffers will\n   *   be decoded to strings using the specified encoding\n   * @param {boolean} [options.objectMode=false] - Whether this stream should\n   *   behave as a stream of objects. Meaning that stream.read(n) returns a\n   *   single value instead of a Buffer of size n\n   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode\n   *   strings into Buffers before passing them to _write()\n   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'\n   *   events, setting this stream's objectMode based on the objectMode of the\n   *   input stream\n   * @param {boolean} [options.readError=false] - If true, when a read()\n   *   underflows, throw an error.\n   */\n  constructor(input, inputEncoding, options) {\n    if (options == null) {\n      options = {}\n    }\n    let inp\n    let inpE\n    switch (typeof(input)) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n          if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {\n            options = inputEncoding\n          }\n        } else {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {\n          options = inputEncoding\n        } else {\n          inpE = inputEncoding\n        }\n        break\n    }\n\n    if ((options == null)) {\n      options = {}\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe != null ? options.watchPipe : true\n    delete options.watchPipe\n    const readError = !! options.readError\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        const om = readable._readableState.objectMode\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream')\n        }\n\n        this._readableState.objectMode = om\n        return this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {Object} obj The object to test.\n   * @returns {boolean} true if obj is a NoFilter\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 - The first object to compare\n   * @param {NoFilter} nf2 - The second object to compare\n   * @returns {number} -1, 0, 1 for less, equal, greater\n   *\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')];\n   * arr.sort(NoFilter.compare);\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    } else {\n      return nf1.compare(nf2)\n    }\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @private\n   */\n  _transform(chunk, encoding, callback) {\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @private\n   */\n  _bufArray() {\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] - Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer\n   * @throws Error - if readError is true and there was underflow\n   * @fires NoFilter#read\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /*\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @type {Buffer|string|Object}\n       *\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {function} [cb=null] - finished/error callback used in *addition*\n   *   to the promise\n   * @returns {Promise<Buffer|String>} fulfilled when complete\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', (er) => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other - The other object to compare\n   * @returns {Number} -1, 0, 1 for less, equal, greater\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    } else {\n      const buf1 = this.slice()\n      const buf2 = other.slice()\n      // these will both be buffers because of the check above.\n      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n        return buf1.compare(buf2)\n      }\n      throw new Error('Cannot compare streams in object mode')\n    }\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {Number} [start=0] - beginning offset\n   * @param {Number} [end=length] - ending offset\n   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default:\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n    }\n  }\n\n  /**\n    * Get a byte by offset.  I didn't want to get into metaprogramming\n    * to give you the `NoFilter[0]` syntax.\n    *\n    * @param {Number} index - The byte to retrieve\n    * @returns {Number} 0-255\n    */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so\n   * that round-tripping will produce a Buffer.\n   *\n   * @returns {Object}\n   *\n   * @example output for 'foo'\n   *   { type: 'Buffer', data: [ 102, 111, 111 ] }\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    } else {\n      return b\n    }\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {String} [encoding='utf8'] - Which to use for decoding?\n   * @param {Number} [start=0] - Start offset\n   * @param {Number} [end=length] - End offset\n   * @returns {String}\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if ((!encoding || (encoding === 'utf8')) && util.TextDecoder) {\n      const td = new util.TextDecoder('utf8', {\n        fatal: true,\n        ignoreBOM: true\n      })\n      return td.decode(buf)\n    }\n    return buf.toString(encoding, start, end)\n  }\n\n  /**\n   * @private\n   * @deprecated\n   */\n  inspect(depth, options) {\n    return this[util.inspect.custom](depth, options)\n  }\n\n  /**\n   * @private\n   */\n  [util.inspect.custom](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map((b) => {\n      if (Buffer.isBuffer(b)) {\n        if ((options != null ? options.stylize : undefined)) {\n          return options.stylize(b.toString('hex'), 'string')\n        } else {\n          return b.toString('hex')\n        }\n      } else {\n        return util.inspect(b, options)\n      }\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @member {number}\n   * @readonly\n   */\n  get length() {\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val - The value to write\n   * @returns {boolean} true on success\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number}  [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt('0x' + b.toString('hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt('0x' + b.toString('hex'))\n    // negative?\n    if (b[0] & 0x80) {\n      // two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret = ret - mask\n    }\n    return ret\n  }\n}\n\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\nfunction _read_gen(meth, len) {\n  return function(val) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b[meth].call(b, 0, true)\n  }\n}\n\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\nfunction _write_gen(meth, len) {\n  return function(val) {\n    const b = Buffer.alloc(len)\n    b[meth].call(b, val, 0, true)\n    return this.push(b)\n  }\n}\n\nObject.assign(NoFilter.prototype, {\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @function writeUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value - 0-255\n   * @returns {boolean} true on success\n   */\n  writeUInt8: _write_gen('writeUInt8', 1),\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16LE: _write_gen('writeUInt16LE', 2),\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16BE: _write_gen('writeUInt16BE', 2),\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32LE: _write_gen('writeUInt32LE', 4),\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32BE: _write_gen('writeUInt32BE', 4),\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @function writeInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt8: _write_gen('writeInt8', 1),\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16LE: _write_gen('writeInt16LE', 2),\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16BE: _write_gen('writeInt16BE', 2),\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32LE: _write_gen('writeInt32LE', 4),\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32BE: _write_gen('writeInt32BE', 4),\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatLE: _write_gen('writeFloatLE', 4),\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatBE: _write_gen('writeFloatBE', 4),\n\n  /**\n   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleLE: _write_gen('writeDoubleLE', 8),\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleBE: _write_gen('writeDoubleBE', 8),\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @function readUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt8: _read_gen('readUInt8', 1),\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16LE: _read_gen('readUInt16LE', 2),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16BE: _read_gen('readUInt16BE', 2),\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32LE: _read_gen('readUInt32LE', 4),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32BE: _read_gen('readUInt32BE', 4),\n\n  /**\n   * Read a signed 8-bit integer from the stream.\n   * Consumes 1 byte.\n   *\n   * @function readInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt8: _read_gen('readInt8', 1),\n\n  /**\n   * Read a signed 16-bit little-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16LE: _read_gen('readInt16LE', 2),\n\n  /**\n   * Read a signed 16-bit big-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16BE: _read_gen('readInt16BE', 2),\n\n  /**\n   * Read a signed 32-bit little-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32LE: _read_gen('readInt32LE', 4),\n\n  /**\n   * Read a signed 32-bit big-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32BE: _read_gen('readInt32BE', 4),\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatLE: _read_gen('readFloatLE', 4),\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatBE: _read_gen('readFloatBE', 4),\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleLE: _read_gen('readDoubleLE', 8),\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleBE: _read_gen('readDoubleBE', 8)\n})\n\nmodule.exports = NoFilter\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}