{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst util = require('util');\n\nconst Decoder = require('./decoder');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst constants = require('./constants');\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst NoFilter = require('nofilter');\n\nconst MT = constants.MT;\nconst SYMS = constants.SYMS;\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\n\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    const separator = opts.separator;\n    delete opts.separator;\n    const stream_errors = opts.stream_errors;\n    delete opts.stream_errors;\n    super(opts);\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder(opts);\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb);\n  }\n\n  _flush(cb) {\n    return this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n\n        return cb();\n      } else {\n        return cb(er);\n      }\n    });\n  }\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {(Buffer|string)} input - the CBOR bytes to format\n   * @param {string} [encoding='hex'] - the encoding of input, ignored if\n   *   input is Buffer\n   * @param {function(Error, string): undefined} cb - callback\n   * @returns {Promise} if callback not specified\n   */\n\n\n  static diagnose(input, encoding, cb) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n\n    let opts = {};\n    let encod = 'hex';\n\n    switch (typeof encoding) {\n      case 'function':\n        cb = encoding;\n        encod = utils.guessEncoding(input);\n        break;\n\n      case 'object':\n        opts = utils.extend({}, encoding);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n        break;\n\n      default:\n        encod = encoding != null ? encoding : 'hex';\n    }\n\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        return d.on('error', reject);\n      });\n    }\n\n    d.pipe(bs);\n    d.end(input, encod);\n    return p;\n  }\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString());\n    } else {\n      return this.emit('error', er);\n    }\n  }\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len];\n    }\n  }\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ');\n        }\n\n        break;\n\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ');\n          } else {\n            return this.push(', ');\n          }\n        }\n\n    }\n  }\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n\n    this._fore(parent_mt, pos);\n\n    return this.push((() => {\n      switch (false) {\n        case val !== SYMS.NULL:\n          return 'null';\n\n        case val !== SYMS.UNDEFINED:\n          return 'undefined';\n\n        case typeof val !== 'string':\n          return JSON.stringify(val);\n\n        case !(this.float_bytes > 0):\n          const fb = this.float_bytes;\n          this.float_bytes = -1;\n          return util.inspect(val) + '_' + fb;\n\n        case !Buffer.isBuffer(val):\n          return 'h\\'' + val.toString('hex') + '\\'';\n\n        case !(val instanceof bignumber):\n          return val.toString();\n\n        default:\n          return util.inspect(val);\n      }\n    })());\n  }\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`);\n        break;\n\n      case MT.ARRAY:\n        this.push('[');\n        break;\n\n      case MT.MAP:\n        this.push('{');\n        break;\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ');\n    }\n  }\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')');\n\n      case MT.ARRAY:\n        return this.push(']');\n\n      case MT.MAP:\n        return this.push('}');\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')');\n    }\n  }\n\n  _on_data() {\n    return this.push(this.separator);\n  }\n\n}\n\nmodule.exports = Diagnose;","map":{"version":3,"names":["stream","require","util","Decoder","Simple","utils","constants","bignumber","BigNumber","NoFilter","MT","SYMS","Diagnose","Transform","constructor","options","opts","Object","assign","separator","stream_errors","readableObjectMode","writableObjectMode","float_bytes","parser","on","_on_more","bind","_on_value","_on_start","_on_stop","_on_data","_on_error","_transform","fresh","encoding","cb","write","_flush","er","diagnose","input","Error","encod","guessEncoding","extend","bs","d","p","toString","Promise","resolve","reject","pipe","end","push","emit","mt","len","parent_mt","pos","SIMPLE_FLOAT","_fore","BYTE_STRING","UTF8_STRING","ARRAY","MAP","val","BREAK","NULL","UNDEFINED","JSON","stringify","fb","inspect","Buffer","isBuffer","tag","TAG","STREAM","module","exports"],"sources":["/Users/soheilvafaei/Documents/project/web/web3/ex7/node_modules/cbor/lib/diagnose.js"],"sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\nconst Decoder = require('./decoder')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst constants = require('./constants')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\n\nconst MT = constants.MT\nconst SYMS = constants.SYMS\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\nclass Diagnose extends stream.Transform {\n\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    })\n    const separator = opts.separator\n    delete opts.separator\n    const stream_errors = opts.stream_errors\n    delete opts.stream_errors\n    super(opts)\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder(opts)\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb)\n  }\n\n  _flush(cb) {\n    return this.parser._flush((er) => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      } else {\n        return cb(er)\n      }\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {(Buffer|string)} input - the CBOR bytes to format\n   * @param {string} [encoding='hex'] - the encoding of input, ignored if\n   *   input is Buffer\n   * @param {function(Error, string): undefined} cb - callback\n   * @returns {Promise} if callback not specified\n   */\n  static diagnose(input, encoding, cb) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    let opts = {}\n    let encod = 'hex'\n    switch (typeof encoding) {\n      case 'function':\n        cb = encoding\n        encod = utils.guessEncoding(input)\n        break\n      case 'object':\n        opts = utils.extend({}, encoding)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n        break\n      default:\n        encod = (encoding != null) ? encoding : 'hex'\n    }\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        return d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    d.end(input, encod)\n    return p\n  }\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString())\n    } else {\n      return this.emit('error', er)\n    }\n  }\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len]\n    }\n  }\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ')\n          } else {\n            return this.push(', ')\n          }\n        }\n    }\n  }\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    return this.push((() => {\n      switch (false) {\n        case val !== SYMS.NULL:\n          return 'null'\n        case val !== SYMS.UNDEFINED:\n          return 'undefined'\n        case typeof val !== 'string':\n          return JSON.stringify(val)\n        case !(this.float_bytes > 0):\n          const fb = this.float_bytes\n          this.float_bytes = -1\n          return (util.inspect(val)) + '_' + fb\n        case !Buffer.isBuffer(val):\n          return 'h\\'' + (val.toString('hex')) + '\\''\n        case !(val instanceof bignumber):\n          return val.toString()\n        default:\n          return util.inspect(val)\n      }\n    })())\n  }\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ')\n    }\n  }\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')')\n      case MT.ARRAY:\n        return this.push(']')\n      case MT.MAP:\n        return this.push('}')\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')')\n    }\n  }\n\n  _on_data() {\n    return this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}