{"ast":null,"code":"const debug = require(\"debug\")(\"contract:handlers\");\n\nconst StatusError = require(\"./statuserror\");\n\nconst Utils = require(\"./utils\");\n\nconst Reason = require(\"./reason\");\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\n\n\nconst handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n  maxConfirmations: 24,\n  // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50,\n  // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\",\n  // Substring of web3 timeout error.\n  defaultWeb3Error: \"please check your gas limit\",\n\n  // Substring of default Web3 error\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash web3 timeout errors at user's request.\n   * @param  {Object} contract contract instance\n   * @param  {Object} message  error message\n   * @return {Boolean}\n   */\n  ignoreTimeoutError(_ref, _ref2) {\n    let {\n      contract\n    } = _ref;\n    let {\n      message\n    } = _ref2;\n    const timedOut = message && message.includes(handlers.timeoutMessage);\n    const shouldWait = contract && contract.timeoutBlocks && contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n    const waitForTxPropagation = message && message.includes(handlers.defaultWeb3Error);\n    return shouldWait && (timedOut || waitForTxPropagation);\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function (emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context)); // web3 block polls if the confirmation listener is enabled so we want to\n    // give users a way of opting out of this behavior - it causes problems in testing\n\n    if (!context.contract.disableConfirmationListener) {\n      emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    }\n\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n  // -----------------------------------  Handlers -------------------------------------------------\n\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function (context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function (context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n  confirmation: function (context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt); // Per web3: initial confirmation index is 0\n\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function (context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs; // Decode logs, use as receipt.logs for ease of use.\n\n    try {\n      receipt.logs = receipt.logs ? Utils.decodeLogs.call(context.contract, receipt.logs) : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    } // Emit receipt\n\n\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt); // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    } // .method(): resolve/reject receipt in handler\n\n\n    if (receipt.status !== undefined && !receipt.status) {\n      const reason = await Reason.get(context.params, context.contract.web3, context.contract.interfaceAdapter);\n      const error = new StatusError(context.params, receipt.transactionHash, receipt, reason);\n      return context.promiEvent.reject(error);\n    } // This object has some duplicate data but is backward compatible.\n\n\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    }); //HACK: adding this conditional for when the handler is invoked\n    //manually during stacktracing\n\n    if (this.removeListener) {\n      this.removeListener(\"receipt\", handlers.receipt);\n    }\n  }\n};\nmodule.exports = handlers;","map":{"version":3,"names":["debug","require","StatusError","Utils","Reason","handlers","maxConfirmations","defaultTimeoutBlocks","timeoutMessage","defaultWeb3Error","ignoreTimeoutError","contract","message","timedOut","includes","shouldWait","timeoutBlocks","waitForTxPropagation","setup","emitter","context","on","error","bind","hash","disableConfirmationListener","confirmation","receipt","promiEvent","eventEmitter","emit","removeListener","transactionHash","number","rawLogs","logs","decodeLogs","call","reject","onlyEmitReceipt","status","undefined","reason","get","params","web3","interfaceAdapter","resolve","tx","module","exports"],"sources":["/Users/soheilvafaei/Documents/project/web/web3/ex7/node_modules/@truffle/contract/lib/handlers.js"],"sourcesContent":["const debug = require(\"debug\")(\"contract:handlers\");\nconst StatusError = require(\"./statuserror\");\nconst Utils = require(\"./utils\");\nconst Reason = require(\"./reason\");\n\n/*\n  Handlers for events emitted by `send` / `call` etc.\n */\nconst handlers = {\n  // ----------------------------------- Constants -------------------------------------------------\n\n  maxConfirmations: 24, // Maximum number of confirmation web3 emits\n  defaultTimeoutBlocks: 50, // Maximum number of blocks web3 will wait before abandoning tx\n  timeoutMessage: \"50 blocks\", // Substring of web3 timeout error.\n  defaultWeb3Error: \"please check your gas limit\", // Substring of default Web3 error\n\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Parses error message and determines if we should squash web3 timeout errors at user's request.\n   * @param  {Object} contract contract instance\n   * @param  {Object} message  error message\n   * @return {Boolean}\n   */\n  ignoreTimeoutError({ contract }, { message }) {\n    const timedOut = message && message.includes(handlers.timeoutMessage);\n\n    const shouldWait =\n      contract &&\n      contract.timeoutBlocks &&\n      contract.timeoutBlocks > handlers.defaultTimeoutBlocks;\n\n    const waitForTxPropagation =\n      message && message.includes(handlers.defaultWeb3Error);\n\n    return shouldWait && (timedOut || waitForTxPropagation);\n  },\n\n  /**\n   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.\n   * @param {Object}       context  execution state\n   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call\n   */\n  setup: function(emitter, context) {\n    emitter.on(\"error\", handlers.error.bind(emitter, context));\n    emitter.on(\"transactionHash\", handlers.hash.bind(emitter, context));\n    // web3 block polls if the confirmation listener is enabled so we want to\n    // give users a way of opting out of this behavior - it causes problems in testing\n    if (!context.contract.disableConfirmationListener) {\n      emitter.on(\"confirmation\", handlers.confirmation.bind(emitter, context));\n    }\n    emitter.on(\"receipt\", handlers.receipt.bind(emitter, context));\n  },\n\n  // -----------------------------------  Handlers -------------------------------------------------\n  /**\n   * Error event handler. Emits error unless error is block timeout and user has\n   * specified we should wait longer\n   * @param  {Object} context   execution state\n   * @param  {Object} error     error\n   */\n  error: function(context, error) {\n    if (!handlers.ignoreTimeoutError(context, error)) {\n      context.promiEvent.eventEmitter.emit(\"error\", error);\n      this.removeListener(\"error\", handlers.error);\n    }\n  },\n\n  /**\n   * Transaction hash event handler. Attaches the hash to the context object\n   * so it can be attached to the contract instance after a deployment resolves.\n   * @param  {Object} context   execution state\n   * @param  {String} hash      transaction hash\n   */\n  hash: function(context, hash) {\n    context.transactionHash = hash;\n    context.promiEvent.eventEmitter.emit(\"transactionHash\", hash);\n    this.removeListener(\"transactionHash\", handlers.hash);\n  },\n\n  confirmation: function(context, number, receipt) {\n    context.promiEvent.eventEmitter.emit(\"confirmation\", number, receipt);\n\n    // Per web3: initial confirmation index is 0\n    if (number === handlers.maxConfirmations + 1) {\n      this.removeListener(\"confirmation\", handlers.confirmation);\n    }\n  },\n\n  /**\n   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,\n   * and (for method calls only) resolves/rejects the promiEvent with the receipt.\n   * @param  {Object} context   execution state\n   * @param  {Object} receipt   transaction receipt\n   */\n  receipt: async function(context, receipt) {\n    // keep around the raw (not decoded) logs in the raw logs field as a\n    // stopgap until we can get the ABI for all events, not just the current\n    // contract\n    receipt.rawLogs = receipt.logs;\n\n    // Decode logs, use as receipt.logs for ease of use.\n    try {\n      receipt.logs = receipt.logs\n        ? Utils.decodeLogs.call(context.contract, receipt.logs)\n        : [];\n    } catch (error) {\n      return context.promiEvent.reject(error);\n    }\n\n    // Emit receipt\n    context.promiEvent.eventEmitter.emit(\"receipt\", receipt);\n\n    // .new(): Exit early. We need the promiEvent to resolve a contract instance.\n    if (context.onlyEmitReceipt) {\n      context.receipt = receipt;\n      return;\n    }\n\n    // .method(): resolve/reject receipt in handler\n    if (receipt.status !== undefined && !receipt.status) {\n      const reason = await Reason.get(\n        context.params,\n        context.contract.web3,\n        context.contract.interfaceAdapter\n      );\n\n      const error = new StatusError(\n        context.params,\n        receipt.transactionHash,\n        receipt,\n        reason\n      );\n\n      return context.promiEvent.reject(error);\n    }\n\n    // This object has some duplicate data but is backward compatible.\n    context.promiEvent.resolve({\n      tx: receipt.transactionHash,\n      receipt: receipt,\n      logs: receipt.logs\n    });\n\n    //HACK: adding this conditional for when the handler is invoked\n    //manually during stacktracing\n    if (this.removeListener) {\n      this.removeListener(\"receipt\", handlers.receipt);\n    }\n  }\n};\n\nmodule.exports = handlers;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}