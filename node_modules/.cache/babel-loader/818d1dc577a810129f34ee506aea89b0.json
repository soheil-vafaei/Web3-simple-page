{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.abifyResult = exports.abifyType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:abify\");\n\nconst Format = __importStar(require(\"./format\"));\n\nconst Common = __importStar(require(\"./common\"));\n\nconst Conversion = __importStar(require(\"./conversion\"));\n/** @category ABIfication */\n\n\nfunction abifyType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    //we only need to specially handle types that don't go in\n    //the ABI, or that have some information loss when going\n    //in the ABI\n    //note that we do need to handle arrays, due to recursion!\n    //First: types that do not go in the ABI\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n    case \"options\":\n      return undefined;\n    //Next: address & contract, these can get handled together\n\n    case \"address\":\n    case \"contract\":\n      return {\n        typeClass: \"address\",\n        kind: \"general\",\n        typeHint: Format.Types.typeString(dataType)\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            typeClass: \"function\",\n            visibility: \"external\",\n            kind: \"general\",\n            typeHint: Format.Types.typeString(dataType)\n          };\n\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n\n      break;\n    //to satisfy TypeScript\n    //the complex cases: struct & enum\n\n    case \"struct\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.memberTypes) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        const memberTypes = fullType.memberTypes.map(_ref => {\n          let {\n            name,\n            type: memberType\n          } = _ref;\n          return {\n            name,\n            type: abifyType(memberType, userDefinedTypes)\n          };\n        });\n        return {\n          typeClass: \"tuple\",\n          typeHint: Format.Types.typeString(fullType),\n          memberTypes\n        };\n      }\n\n    case \"enum\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.options) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        let numOptions = fullType.options.length;\n        let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n        return {\n          typeClass: \"uint\",\n          bits,\n          typeHint: Format.Types.typeString(fullType)\n        };\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.underlyingType) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        const abifiedUnderlying = abifyType(fullType.underlyingType, userDefinedTypes);\n        return Object.assign(Object.assign({}, abifiedUnderlying), {\n          typeHint: Format.Types.typeStringWithoutLocation(dataType)\n        });\n      }\n    //finally: arrays\n\n    case \"array\":\n      return Object.assign(Object.assign({}, dataType), {\n        typeHint: Format.Types.typeString(dataType),\n        baseType: abifyType(dataType.baseType, userDefinedTypes)\n      });\n    //default case: just leave as-is\n\n    default:\n      return dataType;\n  }\n}\n\nexports.abifyType = abifyType;\n/** @category ABIfication */\n\nfunction abifyResult(result, userDefinedTypes) {\n  switch (result.type.typeClass) {\n    case \"mapping\": //doesn't go in ABI\n\n    case \"magic\": //doesn't go in ABI\n\n    case \"type\":\n      //doesn't go in ABI\n      return undefined;\n\n    case \"address\":\n      //abify the type but leave the value alone\n      return Object.assign(Object.assign({}, result), {\n        type: abifyType(result.type, userDefinedTypes)\n      });\n\n    case \"contract\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: abifyType(result.type, userDefinedTypes),\n              kind: \"value\",\n              value: {\n                asAddress: coercedResult.value.address,\n                rawAsHex: coercedResult.value.rawAddress\n              }\n            };\n\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"ContractPaddingError\":\n                return {\n                  type: abifyType(result.type, userDefinedTypes),\n                  kind: \"error\",\n                  error: {\n                    kind: \"AddressPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n\n              default:\n                //other contract errors are generic errors!\n                //but TS doesn't know this so we coerce\n                return Object.assign(Object.assign({}, coercedResult), {\n                  type: abifyType(result.type, userDefinedTypes)\n                });\n            }\n\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n          }\n\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n\n      break;\n    //to satisfy TypeScript\n\n    case \"struct\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(_ref2 => {\n              let {\n                name,\n                value: member\n              } = _ref2;\n              return {\n                name,\n                value: abifyResult(member, userDefinedTypes)\n              };\n            });\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes) //note: may throw exception\n\n            });\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return abifyResult(coercedResult.value, userDefinedTypes);\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n\n        break; //to satisfy TS :P\n      }\n\n    case \"enum\":\n      {\n        //NOTE: this is the one case where errors are converted to non-error values!!\n        //(other than recursively, I mean)\n        //be aware!\n        let coercedResult = result;\n        let uintType = abifyType(result.type, userDefinedTypes); //may throw exception\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: uintType,\n              kind: \"value\",\n              value: {\n                asBN: coercedResult.value.numericAsBN.clone()\n              }\n            };\n\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"EnumOutOfRangeError\":\n                return {\n                  type: uintType,\n                  kind: \"value\",\n                  value: {\n                    asBN: coercedResult.error.rawAsBN.clone()\n                  }\n                };\n\n              case \"EnumPaddingError\":\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: {\n                    kind: \"UintPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n\n              case \"EnumNotFoundDecodingError\":\n                let numericValue = coercedResult.error.rawAsBN.clone();\n\n                if (numericValue.bitLength() <= uintType.bits) {\n                  return {\n                    type: uintType,\n                    kind: \"value\",\n                    value: {\n                      asBN: numericValue\n                    }\n                  };\n                } else {\n                  return {\n                    type: uintType,\n                    kind: \"error\",\n                    error: {\n                      kind: \"UintPaddingError\",\n                      paddingType: \"left\",\n                      raw: Conversion.toHexString(numericValue)\n                    }\n                  };\n                }\n\n              default:\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: coercedResult.error\n                };\n            }\n\n        }\n      }\n\n    case \"array\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(member => abifyResult(member, userDefinedTypes));\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n      }\n\n    default:\n      return result;\n    //just coerce :-/\n  }\n}\n\nexports.abifyResult = abifyResult;\n/** @category ABIfication */\n\nfunction abifyCalldataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  switch (decoding.kind) {\n    case \"function\":\n    case \"constructor\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\n\nexports.abifyCalldataDecoding = abifyCalldataDecoding;\n/** @category ABIfication */\n\nfunction abifyLogDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  return Object.assign(Object.assign({}, decoding), {\n    decodingMode: \"abi\",\n    arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n      value: abifyResult(argument.value, userDefinedTypes)\n    }))\n  });\n}\n\nexports.abifyLogDecoding = abifyLogDecoding;\n/** @category ABIfication */\n\nfunction abifyReturndataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  switch (decoding.kind) {\n    case \"return\":\n    case \"revert\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n\n    case \"bytecode\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        immutables: undefined\n      });\n\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\n\nexports.abifyReturndataDecoding = abifyReturndataDecoding;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA,MAAMA,KAAK,GAAG,qBAAY,aAAZ,CAAd;;AAEA;;AACA;;AAMA;AAEA;;;AACA,SAAgBC,SAAhB,CACEC,QADF,EAEEC,gBAFF,EAE2C;EAEzC,QAAQD,QAAQ,CAACE,SAAjB;IACE;IACA;IACA;IACA;IACA;IACA,KAAK,SAAL;IACA,KAAK,OAAL;IACA,KAAK,MAAL;IACA,KAAK,SAAL;MACE,OAAOC,SAAP;IACF;;IACA,KAAK,SAAL;IACA,KAAK,UAAL;MACE,OAAO;QACLD,SAAS,EAAE,SADN;QAELE,IAAI,EAAE,SAFD;QAGLC,QAAQ,EAAEC,MAAM,CAACC,KAAP,CAAaC,UAAb,CAAwBR,QAAxB;MAHL,CAAP;;IAKF,KAAK,UAAL;MACE,QAAQA,QAAQ,CAACS,UAAjB;QACE,KAAK,UAAL;UACE,OAAO;YACLP,SAAS,EAAE,UADN;YAELO,UAAU,EAAE,UAFP;YAGLL,IAAI,EAAE,SAHD;YAILC,QAAQ,EAAEC,MAAM,CAACC,KAAP,CAAaC,UAAb,CAAwBR,QAAxB;UAJL,CAAP;;QAMF,KAAK,UAAL;UAAiB;UACf,OAAOG,SAAP;MATJ;;MAWA;IAAO;IACT;;IACA,KAAK,QAAL;MAAe;QACb,MAAMO,QAAQ,GACZJ,MAAM,CAACC,KAAP,CAAaG,QAAb,CAAsBV,QAAtB,EAAgCC,gBAAhC,CADF;;QAGA,IAAI,CAACS,QAAQ,CAACC,WAAd,EAA2B;UACzB,IAAIC,aAAa,GAAGN,MAAM,CAACC,KAAP,CAAaC,UAAb,CAAwBR,QAAxB,CAApB;UACA,MAAM,IAAIa,MAAM,CAACC,2BAAX,CACJd,QAAQ,CAACe,EADL,EAEJH,aAFI,CAAN;QAID;;QACD,MAAMD,WAAW,GAAGD,QAAQ,CAACC,WAAT,CAAqBK,GAArB,CAClB;UAAA,IAAC;YAAEC,IAAF;YAAQC,IAAI,EAAEC;UAAd,CAAD;UAAA,OAAiC;YAC/BF,IAD+B;YAE/BC,IAAI,EAAEnB,SAAS,CAACoB,UAAD,EAAalB,gBAAb;UAFgB,CAAjC;QAAA,CADkB,CAApB;QAMA,OAAO;UACLC,SAAS,EAAE,OADN;UAELG,QAAQ,EAAEC,MAAM,CAACC,KAAP,CAAaC,UAAb,CAAwBE,QAAxB,CAFL;UAGLC;QAHK,CAAP;MAKD;;IACD,KAAK,MAAL;MAAa;QACX,MAAMD,QAAQ,GACZJ,MAAM,CAACC,KAAP,CAAaG,QAAb,CAAsBV,QAAtB,EAAgCC,gBAAhC,CADF;;QAGA,IAAI,CAACS,QAAQ,CAACU,OAAd,EAAuB;UACrB,IAAIR,aAAa,GAAGN,MAAM,CAACC,KAAP,CAAaC,UAAb,CAAwBR,QAAxB,CAApB;UACA,MAAM,IAAIa,MAAM,CAACC,2BAAX,CACJd,QAAQ,CAACe,EADL,EAEJH,aAFI,CAAN;QAID;;QACD,IAAIS,UAAU,GAAGX,QAAQ,CAACU,OAAT,CAAiBE,MAAlC;QACA,IAAIC,IAAI,GAAG,IAAIC,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACE,IAAL,CAAUL,UAAV,IAAwB,CAAlC,CAAf;QACA,OAAO;UACLnB,SAAS,EAAE,MADN;UAELqB,IAFK;UAGLlB,QAAQ,EAAEC,MAAM,CAACC,KAAP,CAAaC,UAAb,CAAwBE,QAAxB;QAHL,CAAP;MAKD;;IACD,KAAK,sBAAL;MAA6B;QAC3B,MAAMA,QAAQ,GACZJ,MAAM,CAACC,KAAP,CAAaG,QAAb,CAAsBV,QAAtB,EAAgCC,gBAAhC,CADF;;QAGA,IAAI,CAACS,QAAQ,CAACiB,cAAd,EAA8B;UAC5B,IAAIf,aAAa,GAAGN,MAAM,CAACC,KAAP,CAAaC,UAAb,CAAwBR,QAAxB,CAApB;UACA,MAAM,IAAIa,MAAM,CAACC,2BAAX,CACJd,QAAQ,CAACe,EADL,EAEJH,aAFI,CAAN;QAID;;QACD,MAAMgB,iBAAiB,GAAG7B,SAAS,CACjCW,QAAQ,CAACiB,cADwB,EAEjC1B,gBAFiC,CAAnC;QAIA,uCACK2B,iBADL,GACsB;UACpBvB,QAAQ,EAAEC,MAAM,CAACC,KAAP,CAAasB,yBAAb,CAAuC7B,QAAvC;QADU,CADtB;MAID;IACD;;IACA,KAAK,OAAL;MACE,uCACKA,QADL,GACa;QACXK,QAAQ,EAAEC,MAAM,CAACC,KAAP,CAAaC,UAAb,CAAwBR,QAAxB,CADC;QAEX8B,QAAQ,EAAE/B,SAAS,CAACC,QAAQ,CAAC8B,QAAV,EAAoB7B,gBAApB;MAFR,CADb;IAKF;;IACA;MACE,OAAOD,QAAP;EAxGJ;AA0GD;;AA9GD+B;AAgHA;;AACA,SAAgBC,WAAhB,CACEC,MADF,EAEEhC,gBAFF,EAE2C;EAEzC,QAAQgC,MAAM,CAACf,IAAP,CAAYhB,SAApB;IACE,KAAK,SAAL,CADF,CACkB;;IAChB,KAAK,OAAL,CAFF,CAEgB;;IACd,KAAK,MAAL;MAAa;MACX,OAAOC,SAAP;;IACF,KAAK,SAAL;MACE;MACA,uCACmC8B,MADnC,GAC0C;QACxCf,IAAI,EAA4BnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd;MADD,CAD1C;;IAIF,KAAK,UAAL;MAAiB;QACf,IAAIiC,aAAa,GAAiCD,MAAlD;;QACA,QAAQC,aAAa,CAAC9B,IAAtB;UACE,KAAK,OAAL;YACE,OAAO;cACLc,IAAI,EACFnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd,CAFN;cAILG,IAAI,EAAE,OAJD;cAKL+B,KAAK,EAAE;gBACLC,SAAS,EAAEF,aAAa,CAACC,KAAd,CAAoBE,OAD1B;gBAELC,QAAQ,EAAEJ,aAAa,CAACC,KAAd,CAAoBI;cAFzB;YALF,CAAP;;UAUF,KAAK,OAAL;YACE,QAAQL,aAAa,CAACM,KAAd,CAAoBpC,IAA5B;cACE,KAAK,sBAAL;gBACE,OAAO;kBACLc,IAAI,EACFnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd,CAFN;kBAILG,IAAI,EAAE,OAJD;kBAKLoC,KAAK,EAAE;oBACLpC,IAAI,EAAE,qBADD;oBAELqC,WAAW,EAAEP,aAAa,CAACM,KAAd,CAAoBC,WAF5B;oBAGLC,GAAG,EAAER,aAAa,CAACM,KAAd,CAAoBE;kBAHpB;gBALF,CAAP;;cAWF;gBACE;gBACA;gBACA,OAAOC,gCACFT,aADE,GACW;kBAChBhB,IAAI,EACFnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd;gBAFK,CADX,CAAP;YAhBJ;;QAbJ;;QAqCA,MAvCe,CAuCR;MACR;;IACD,KAAK,UAAL;MACE,QAAQgC,MAAM,CAACf,IAAP,CAAYT,UAApB;QACE,KAAK,UAAL;UAAiB;YACf,IAAIyB,aAAa,GAAyCD,MAA1D;YACA,uCACKC,aADL,GACkB;cAChBhB,IAAI,EACFnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd;YAFK,CADlB;UAMD;;QACD,KAAK,UAAL;UAAiB;UACf,OAAOE,SAAP;MAXJ;;MAaA;IAAO;;IACT,KAAK,QAAL;MAAe;QACb,IAAI+B,aAAa,GAA+BD,MAAhD;;QACA,QAAQC,aAAa,CAAC9B,IAAtB;UACE,KAAK,OAAL;YACE,IAAI8B,aAAa,CAACU,SAAd,KAA4BzC,SAAhC,EAA2C;cACzC,OAAOA,SAAP,CADyC,CACvB;YACnB;;YACD,IAAI0C,cAAc,GAAGX,aAAa,CAACC,KAAd,CAAoBnB,GAApB,CACnB;cAAA,IAAC;gBAAEC,IAAF;gBAAQkB,KAAK,EAAEW;cAAf,CAAD;cAAA,OAA8B;gBAC5B7B,IAD4B;gBAE5BkB,KAAK,EAAEH,WAAW,CAACc,MAAD,EAAS7C,gBAAT;cAFU,CAA9B;YAAA,CADmB,CAArB;YAMA,OAAO;cACLG,IAAI,EAAE,OADD;cAELc,IAAI,EACFnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd,CAHN;cAKLkC,KAAK,EAAEU;YALF,CAAP;;UAOF,KAAK,OAAL;YACE,uCACKX,aADL,GACkB;cAChBhB,IAAI,EACFnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd,CAFK,CAGd;;YAHc,CADlB;QAnBJ;MA0BD;;IACD,KAAK,sBAAL;MAA6B;QAC3B,MAAMiC,aAAa,GAA6CD,MAAhE;;QACA,QAAQC,aAAa,CAAC9B,IAAtB;UACE,KAAK,OAAL;YACE,OAAO4B,WAAW,CAACE,aAAa,CAACC,KAAf,EAAsBlC,gBAAtB,CAAlB;;UACF,KAAK,OAAL;YACE,OAAO0C,gCACFT,aADE,GACW;cAChBhB,IAAI,EAAEnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd;YADC,CADX,CAAP;QAJJ;;QASA,MAX2B,CAWpB;MACR;;IACD,KAAK,MAAL;MAAa;QACX;QACA;QACA;QACA,IAAIiC,aAAa,GAA6BD,MAA9C;QACA,IAAIc,QAAQ,GACVhD,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd,CADX,CALW,CAOR;;QACH,QAAQiC,aAAa,CAAC9B,IAAtB;UACE,KAAK,OAAL;YACE,OAAO;cACLc,IAAI,EAAE6B,QADD;cAEL3C,IAAI,EAAE,OAFD;cAGL+B,KAAK,EAAE;gBACLa,IAAI,EAAEd,aAAa,CAACC,KAAd,CAAoBc,WAApB,CAAgCC,KAAhC;cADD;YAHF,CAAP;;UAOF,KAAK,OAAL;YACE,QAAQhB,aAAa,CAACM,KAAd,CAAoBpC,IAA5B;cACE,KAAK,qBAAL;gBACE,OAAO;kBACLc,IAAI,EAAE6B,QADD;kBAEL3C,IAAI,EAAE,OAFD;kBAGL+B,KAAK,EAAE;oBACLa,IAAI,EAAEd,aAAa,CAACM,KAAd,CAAoBW,OAApB,CAA4BD,KAA5B;kBADD;gBAHF,CAAP;;cAOF,KAAK,kBAAL;gBACE,OAAO;kBACLhC,IAAI,EAAE6B,QADD;kBAEL3C,IAAI,EAAE,OAFD;kBAGLoC,KAAK,EAAE;oBACLpC,IAAI,EAAE,kBADD;oBAELqC,WAAW,EAAEP,aAAa,CAACM,KAAd,CAAoBC,WAF5B;oBAGLC,GAAG,EAAER,aAAa,CAACM,KAAd,CAAoBE;kBAHpB;gBAHF,CAAP;;cASF,KAAK,2BAAL;gBACE,IAAIU,YAAY,GAAGlB,aAAa,CAACM,KAAd,CAAoBW,OAApB,CAA4BD,KAA5B,EAAnB;;gBACA,IAAIE,YAAY,CAACC,SAAb,MAA4BN,QAAQ,CAACxB,IAAzC,EAA+C;kBAC7C,OAAO;oBACLL,IAAI,EAAE6B,QADD;oBAEL3C,IAAI,EAAE,OAFD;oBAGL+B,KAAK,EAAE;sBACLa,IAAI,EAAEI;oBADD;kBAHF,CAAP;gBAOD,CARD,MAQO;kBACL,OAAO;oBACLlC,IAAI,EAAE6B,QADD;oBAEL3C,IAAI,EAAE,OAFD;oBAGLoC,KAAK,EAAE;sBACLpC,IAAI,EAAE,kBADD;sBAELqC,WAAW,EAAE,MAFR;sBAGLC,GAAG,EAAEY,UAAU,CAACC,WAAX,CAAuBH,YAAvB;oBAHA;kBAHF,CAAP;gBASD;;cACH;gBACE,OAAO;kBACLlC,IAAI,EAAE6B,QADD;kBAEL3C,IAAI,EAAE,OAFD;kBAGLoC,KAAK,EAAEN,aAAa,CAACM;gBAHhB,CAAP;YAzCJ;;QAVJ;MA0DD;;IACD,KAAK,OAAL;MAAc;QACZ,IAAIN,aAAa,GAA8BD,MAA/C;;QACA,QAAQC,aAAa,CAAC9B,IAAtB;UACE,KAAK,OAAL;YACE,IAAI8B,aAAa,CAACU,SAAd,KAA4BzC,SAAhC,EAA2C;cACzC,OAAOA,SAAP,CADyC,CACvB;YACnB;;YACD,IAAI0C,cAAc,GAAGX,aAAa,CAACC,KAAd,CAAoBnB,GAApB,CAAwB8B,MAAM,IACjDd,WAAW,CAACc,MAAD,EAAS7C,gBAAT,CADQ,CAArB;YAGA,OAAO;cACLG,IAAI,EAAE,OADD;cAELc,IAAI,EACFnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd,CAHN;cAKLkC,KAAK,EAAEU;YALF,CAAP;;UAOF,KAAK,OAAL;YACE,uCACKX,aADL,GACkB;cAChBhB,IAAI,EACFnB,SAAS,CAACkC,MAAM,CAACf,IAAR,EAAcjB,gBAAd;YAFK,CADlB;QAhBJ;MAuBD;;IACD;MACE,OAAgCgC,MAAhC;IAAwC;EA3M5C;AA6MD;;AAjNDF;AAmNA;;AACA,SAAgByB,qBAAhB,CACEC,QADF,EAEExD,gBAFF,EAE0C;EAExC,IAAIwD,QAAQ,CAACC,YAAT,KAA0B,KAA9B,EAAqC;IACnC,OAAOD,QAAP;EACD;;EACD,QAAQA,QAAQ,CAACrD,IAAjB;IACE,KAAK,UAAL;IACA,KAAK,aAAL;MACE,uCACKqD,QADL,GACa;QACXC,YAAY,EAAE,KADH;QAEXC,SAAS,EAAEF,QAAQ,CAACE,SAAT,CAAmB3C,GAAnB,CAAuB4C,QAAQ,IAAIjB,gCACzCiB,QADyC,GACjC;UACXzB,KAAK,EAAEH,WAAW,CAAC4B,QAAQ,CAACzB,KAAV,EAAiBlC,gBAAjB;QADP,CADiC,CAAnC;MAFA,CADb;;IAQF;MACE,uCACKwD,QADL,GACa;QACXC,YAAY,EAAE;MADH,CADb;EAZJ;AAiBD;;AAxBD3B;AA0BA;;AACA,SAAgB8B,gBAAhB,CACEJ,QADF,EAEExD,gBAFF,EAE0C;EAExC,IAAIwD,QAAQ,CAACC,YAAT,KAA0B,KAA9B,EAAqC;IACnC,OAAOD,QAAP;EACD;;EACD,uCACKA,QADL,GACa;IACXC,YAAY,EAAE,KADH;IAEXC,SAAS,EAAEF,QAAQ,CAACE,SAAT,CAAmB3C,GAAnB,CAAuB4C,QAAQ,IAAIjB,gCACzCiB,QADyC,GACjC;MACXzB,KAAK,EAAEH,WAAW,CAAC4B,QAAQ,CAACzB,KAAV,EAAiBlC,gBAAjB;IADP,CADiC,CAAnC;EAFA,CADb;AAQD;;AAfD8B;AAiBA;;AACA,SAAgB+B,uBAAhB,CACEL,QADF,EAEExD,gBAFF,EAE0C;EAExC,IAAIwD,QAAQ,CAACC,YAAT,KAA0B,KAA9B,EAAqC;IACnC,OAAOD,QAAP;EACD;;EACD,QAAQA,QAAQ,CAACrD,IAAjB;IACE,KAAK,QAAL;IACA,KAAK,QAAL;MACE,uCACKqD,QADL,GACa;QACXC,YAAY,EAAE,KADH;QAEXC,SAAS,EAAEF,QAAQ,CAACE,SAAT,CAAmB3C,GAAnB,CAAuB4C,QAAQ,IAAIjB,gCACzCiB,QADyC,GACjC;UACXzB,KAAK,EAAEH,WAAW,CAAC4B,QAAQ,CAACzB,KAAV,EAAiBlC,gBAAjB;QADP,CADiC,CAAnC;MAFA,CADb;;IAQF,KAAK,UAAL;MACE,uCACKwD,QADL,GACa;QACXC,YAAY,EAAE,KADH;QAEXK,UAAU,EAAE5D;MAFD,CADb;;IAKF;MACE,uCACKsD,QADL,GACa;QACXC,YAAY,EAAE;MADH,CADb;EAlBJ;AAuBD;;AA9BD3B","names":["debug","abifyType","dataType","userDefinedTypes","typeClass","undefined","kind","typeHint","Format","Types","typeString","visibility","fullType","memberTypes","typeToDisplay","Common","UnknownUserDefinedTypeError","id","map","name","type","memberType","options","numOptions","length","bits","Math","ceil","log2","underlyingType","abifiedUnderlying","typeStringWithoutLocation","baseType","exports","abifyResult","result","coercedResult","value","asAddress","address","rawAsHex","rawAddress","error","paddingType","raw","Object","reference","abifiedMembers","member","uintType","asBN","numericAsBN","clone","rawAsBN","numericValue","bitLength","Conversion","toHexString","abifyCalldataDecoding","decoding","decodingMode","arguments","argument","abifyLogDecoding","abifyReturndataDecoding","immutables"],"sourceRoot":"","sources":["../../lib/abify.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}