{"ast":null,"code":"const {\n  Web3Shim,\n  createInterfaceAdapter\n} = require(\"@truffle/interface-adapter\");\n\nconst utils = require(\"../utils\");\n\nconst execute = require(\"../execute\");\n\nconst bootstrap = require(\"./bootstrap\");\n\nconst debug = require(\"debug\")(\"contract:contract:constructorMethods\");\n\nconst OS = require(\"os\");\n\nmodule.exports = Contract => ({\n  configureNetwork() {\n    let {\n      networkType,\n      provider\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // otherwise use existing value as default (at most one of these)\n    networkType = networkType || this.networkType;\n    provider = provider || this.currentProvider; // recreate interfaceadapter\n\n    this.interfaceAdapter = createInterfaceAdapter({\n      networkType,\n      provider\n    });\n\n    if (this.web3) {\n      // update existing\n      this.web3.setNetworkType(networkType);\n      this.web3.setProvider(provider);\n    } else {\n      // create new\n      this.web3 = new Web3Shim({\n        networkType,\n        provider\n      });\n    } // save properties\n\n\n    this.currentProvider = provider;\n    this.networkType = networkType;\n  },\n\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(`Invalid provider passed to setProvider(); provider is ${provider}`);\n    }\n\n    this.configureNetwork({\n      provider\n    });\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(`${this.contractName} error: contract binary not set. Can't deploy new instance.\\n` + `This contract may be abstract, not implement an abstract parent's methods completely\\n` + `or not invoke an inherited contract's constructor correctly\\n`);\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  async at(address) {\n    if (address == null || typeof address !== \"string\" || address.length !== 42) {\n      throw new Error(`Invalid address passed to ${this.contractName}.at(): ${address}`);\n    }\n\n    await this.detectNetwork();\n    const onChainCode = await this.interfaceAdapter.getCode(address);\n    await utils.checkCode(onChainCode, this.contractName, address);\n    return new this(address);\n  },\n\n  async deployed() {\n    if (this.reloadJson) {\n      this.reloadJson(); //truffle test monkey-patches in this method\n    }\n\n    utils.checkProvider(this);\n    await this.detectNetwork();\n    utils.checkNetworkArtifactMatch(this);\n    utils.checkDeployment(this);\n    return new this(this.address);\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // guard interfaceAdapter!\n    if (this.interfaceAdapter == null) {\n      throw new Error(\"Provider not set or invalid\");\n    } // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n\n\n    if (this.network_id && this.networks[this.network_id] != null) {\n      const {\n        gasLimit\n      } = await this.interfaceAdapter.getBlock(\"latest\");\n      return {\n        id: this.network_id,\n        blockLimit: gasLimit\n      };\n    } // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n\n\n    const chainNetworkID = await this.interfaceAdapter.getNetworkId();\n    const {\n      gasLimit\n    } = await this.interfaceAdapter.getBlock(\"latest\");\n    return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n\n  setNetworkType() {\n    let networkType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ethereum\";\n    this.configureNetwork({\n      networkType\n    });\n  },\n\n  setWallet(wallet) {\n    this.configureNetwork();\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  // accepts 4 input formats\n  //  - (<name>, <address>)\n  //  - (<contractType>) - must have a deployed instance with an address\n  //  - (<contractInstance>)\n  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })\n  link(name, address) {\n    switch (typeof name) {\n      case \"string\":\n        // Case: Contract.link(<libraryName>, <address>)\n        if (this._json.networks[this.network_id] == null) {\n          this._json.networks[this.network_id] = {\n            events: {},\n            links: {}\n          };\n        }\n\n        this.network.links[name] = address;\n        return;\n\n      case \"function\":\n        // Case: Contract.link(<contractType>)\n        const contract = name;\n\n        if (contract.isDeployed() === false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n        Object.keys(contract.events).forEach(topic => {\n          this.network.events[topic] = contract.events[topic];\n        });\n        return;\n\n      case \"object\":\n        // 2 Cases:\n        //   - Contract.link({<libraryName>: <address>, ... })\n        //   - Contract.link(<instance>)\n        const obj = name;\n\n        if (obj.constructor && typeof obj.constructor.contractName === \"string\" && obj.address) {\n          // obj is a Truffle contract instance\n          this.link(obj.constructor.contractName, obj.address);\n        } else {\n          // obj is of the form { <libraryName>: <address>, ... }\n          Object.keys(obj).forEach(name => this.link(name, obj[name]));\n        }\n\n        return;\n\n      default:\n        const invalidInput = `Input to the link method is in the incorrect` + ` format. Input must be one of the following:${OS.EOL}` + `    - a library name and address                 > (\"MyLibrary\", ` + `\"0x123456789...\")${OS.EOL}` + `    - a contract type                            > ` + `(MyContract)${OS.EOL}` + `    - a contract instance                        > ` + `(myContract)${OS.EOL}` + `    - an object with library names and addresses > ({ <libName>: ` + `<address>, <libName2>: <address2>, ... })${OS.EOL}`;\n        throw new Error(invalidInput);\n    }\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n    let network_id; // If we have a network id passed\n\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n    temp._property_values = {};\n    temp._json = json;\n    bootstrap(temp);\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    }\n\n    if (this.currentProvider) {\n      temp.configureNetwork({\n        provider: this.currentProvider,\n        networkType: this.networkType\n      });\n    } // Copy over custom key/values to the contract class\n\n\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      } // If there's not a setter, then the property is immutable.\n\n\n      throw new Error(`${key} property is immutable`);\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});","map":{"version":3,"names":["Web3Shim","createInterfaceAdapter","require","utils","execute","bootstrap","debug","OS","module","exports","Contract","configureNetwork","networkType","provider","currentProvider","interfaceAdapter","web3","setNetworkType","setProvider","Error","new","checkProvider","bytecode","contractName","constructorABI","abi","filter","i","type","deploy","call","arguments","at","address","length","detectNetwork","onChainCode","getCode","checkCode","deployed","reloadJson","checkNetworkArtifactMatch","checkDeployment","defaults","class_defaults","Object","keys","forEach","key","value","hasNetwork","network_id","_json","networks","isDeployed","network","gasLimit","getBlock","id","blockLimit","chainNetworkID","getNetworkId","setInstanceNetworkID","setNetwork","setWallet","wallet","eth","accounts","resetAddress","link","name","events","links","contract","topic","obj","constructor","invalidInput","EOL","clone","json","temp","TruffleContract","apply","prototype","create","merge","_constructorMethods","_properties","_property_values","indexOf","addProp","fn","getter","get","setter","val","set","definition","enumerable","configurable","defineProperty","toJSON","decodeLogs"],"sources":["/Users/soheilvafaei/Documents/resume/Web3/web3 simple react web3 js/node_modules/@truffle/contract/lib/contract/constructorMethods.js"],"sourcesContent":["const {\n  Web3Shim,\n  createInterfaceAdapter\n} = require(\"@truffle/interface-adapter\");\nconst utils = require(\"../utils\");\nconst execute = require(\"../execute\");\nconst bootstrap = require(\"./bootstrap\");\nconst debug = require(\"debug\")(\"contract:contract:constructorMethods\");\nconst OS = require(\"os\");\n\nmodule.exports = Contract => ({\n  configureNetwork({ networkType, provider } = {}) {\n    // otherwise use existing value as default (at most one of these)\n    networkType = networkType || this.networkType;\n    provider = provider || this.currentProvider;\n\n    // recreate interfaceadapter\n    this.interfaceAdapter = createInterfaceAdapter({ networkType, provider });\n\n    if (this.web3) {\n      // update existing\n      this.web3.setNetworkType(networkType);\n      this.web3.setProvider(provider);\n    } else {\n      // create new\n      this.web3 = new Web3Shim({ networkType, provider });\n    }\n\n    // save properties\n    this.currentProvider = provider;\n    this.networkType = networkType;\n  },\n\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(\n        `Invalid provider passed to setProvider(); provider is ${provider}`\n      );\n    }\n\n    this.configureNetwork({ provider });\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(\n        `${this.contractName} error: contract binary not set. Can't deploy new instance.\\n` +\n          `This contract may be abstract, not implement an abstract parent's methods completely\\n` +\n          `or not invoke an inherited contract's constructor correctly\\n`\n      );\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  async at(address) {\n    if (\n      address == null ||\n      typeof address !== \"string\" ||\n      address.length !== 42\n    ) {\n      throw new Error(\n        `Invalid address passed to ${this.contractName}.at(): ${address}`\n      );\n    }\n\n    await this.detectNetwork();\n    const onChainCode = await this.interfaceAdapter.getCode(address);\n    await utils.checkCode(onChainCode, this.contractName, address);\n    return new this(address);\n  },\n\n  async deployed() {\n    if (this.reloadJson) {\n      this.reloadJson(); //truffle test monkey-patches in this method\n    }\n    utils.checkProvider(this);\n    await this.detectNetwork();\n    utils.checkNetworkArtifactMatch(this);\n    utils.checkDeployment(this);\n    return new this(this.address);\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[`${network_id}`] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // guard interfaceAdapter!\n    if (this.interfaceAdapter == null) {\n      throw new Error(\"Provider not set or invalid\");\n    }\n    // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n    if (this.network_id && this.networks[this.network_id] != null) {\n      const { gasLimit } = await this.interfaceAdapter.getBlock(\"latest\");\n      return { id: this.network_id, blockLimit: gasLimit };\n    }\n    // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n    const chainNetworkID = await this.interfaceAdapter.getNetworkId();\n    const { gasLimit } = await this.interfaceAdapter.getBlock(\"latest\");\n    return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = `${network_id}`;\n  },\n\n  setNetworkType(networkType = \"ethereum\") {\n    this.configureNetwork({ networkType });\n  },\n\n  setWallet(wallet) {\n    this.configureNetwork();\n\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  // accepts 4 input formats\n  //  - (<name>, <address>)\n  //  - (<contractType>) - must have a deployed instance with an address\n  //  - (<contractInstance>)\n  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })\n  link(name, address) {\n    switch (typeof name) {\n      case \"string\":\n        // Case: Contract.link(<libraryName>, <address>)\n        if (this._json.networks[this.network_id] == null) {\n          this._json.networks[this.network_id] = {\n            events: {},\n            links: {}\n          };\n        }\n\n        this.network.links[name] = address;\n        return;\n      case \"function\":\n        // Case: Contract.link(<contractType>)\n        const contract = name;\n\n        if (contract.isDeployed() === false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address);\n\n        // Merge events so this contract knows about library's events\n        Object.keys(contract.events).forEach(topic => {\n          this.network.events[topic] = contract.events[topic];\n        });\n        return;\n      case \"object\":\n        // 2 Cases:\n        //   - Contract.link({<libraryName>: <address>, ... })\n        //   - Contract.link(<instance>)\n        const obj = name;\n        if (\n          obj.constructor &&\n          typeof obj.constructor.contractName === \"string\" &&\n          obj.address\n        ) {\n          // obj is a Truffle contract instance\n          this.link(obj.constructor.contractName, obj.address);\n        } else {\n          // obj is of the form { <libraryName>: <address>, ... }\n          Object.keys(obj).forEach(name => this.link(name, obj[name]));\n        }\n        return;\n      default:\n        const invalidInput =\n          `Input to the link method is in the incorrect` +\n          ` format. Input must be one of the following:${OS.EOL}` +\n          `    - a library name and address                 > (\"MyLibrary\", ` +\n          `\"0x123456789...\")${OS.EOL}` +\n          `    - a contract type                            > ` +\n          `(MyContract)${OS.EOL}` +\n          `    - a contract instance                        > ` +\n          `(myContract)${OS.EOL}` +\n          `    - an object with library names and addresses > ({ <libName>: ` +\n          `<address>, <libName2>: <address2>, ... })${OS.EOL}`;\n        throw new Error(invalidInput);\n    }\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n\n    let network_id;\n\n    // If we have a network id passed\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n\n    temp._property_values = {};\n    temp._json = json;\n\n    bootstrap(temp);\n\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    }\n\n    if (this.currentProvider) {\n      temp.configureNetwork({\n        provider: this.currentProvider,\n        networkType: this.networkType\n      });\n    }\n\n    // Copy over custom key/values to the contract class\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      }\n\n      // If there's not a setter, then the property is immutable.\n      throw new Error(`${key} property is immutable`);\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}