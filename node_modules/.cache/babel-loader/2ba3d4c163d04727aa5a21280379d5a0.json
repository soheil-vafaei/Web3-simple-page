{"ast":null,"code":"import { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction } from \"./node.js\";\nexport * from \"./node.js\"; // Default options\n\nconst defaultOpts = {\n  withStartIndices: false,\n  withEndIndices: false,\n  xmlMode: false\n};\nexport class DomHandler {\n  /**\n   * @param callback Called once parsing has completed.\n   * @param options Settings for the handler.\n   * @param elementCB Callback whenever a tag is closed.\n   */\n  constructor(callback, options, elementCB) {\n    /** The elements of the DOM */\n    this.dom = [];\n    /** The root element for the DOM */\n\n    this.root = new Document(this.dom);\n    /** Indicated whether parsing has been completed. */\n\n    this.done = false;\n    /** Stack of open tags. */\n\n    this.tagStack = [this.root];\n    /** A data node that is still being written to. */\n\n    this.lastNode = null;\n    /** Reference to the parser instance. Used for location information. */\n\n    this.parser = null; // Make it possible to skip arguments, for backwards-compatibility\n\n    if (typeof options === \"function\") {\n      elementCB = options;\n      options = defaultOpts;\n    }\n\n    if (typeof callback === \"object\") {\n      options = callback;\n      callback = undefined;\n    }\n\n    this.callback = callback !== null && callback !== void 0 ? callback : null;\n    this.options = options !== null && options !== void 0 ? options : defaultOpts;\n    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n  }\n\n  onparserinit(parser) {\n    this.parser = parser;\n  } // Resets the handler back to starting state\n\n\n  onreset() {\n    this.dom = [];\n    this.root = new Document(this.dom);\n    this.done = false;\n    this.tagStack = [this.root];\n    this.lastNode = null;\n    this.parser = null;\n  } // Signals the handler that parsing is done\n\n\n  onend() {\n    if (this.done) return;\n    this.done = true;\n    this.parser = null;\n    this.handleCallback(null);\n  }\n\n  onerror(error) {\n    this.handleCallback(error);\n  }\n\n  onclosetag() {\n    this.lastNode = null;\n    const elem = this.tagStack.pop();\n\n    if (this.options.withEndIndices) {\n      elem.endIndex = this.parser.endIndex;\n    }\n\n    if (this.elementCB) this.elementCB(elem);\n  }\n\n  onopentag(name, attribs) {\n    const type = this.options.xmlMode ? ElementType.Tag : undefined;\n    const element = new Element(name, attribs, undefined, type);\n    this.addNode(element);\n    this.tagStack.push(element);\n  }\n\n  ontext(data) {\n    const {\n      lastNode\n    } = this;\n\n    if (lastNode && lastNode.type === ElementType.Text) {\n      lastNode.data += data;\n\n      if (this.options.withEndIndices) {\n        lastNode.endIndex = this.parser.endIndex;\n      }\n    } else {\n      const node = new Text(data);\n      this.addNode(node);\n      this.lastNode = node;\n    }\n  }\n\n  oncomment(data) {\n    if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n      this.lastNode.data += data;\n      return;\n    }\n\n    const node = new Comment(data);\n    this.addNode(node);\n    this.lastNode = node;\n  }\n\n  oncommentend() {\n    this.lastNode = null;\n  }\n\n  oncdatastart() {\n    const text = new Text(\"\");\n    const node = new CDATA([text]);\n    this.addNode(node);\n    text.parent = node;\n    this.lastNode = text;\n  }\n\n  oncdataend() {\n    this.lastNode = null;\n  }\n\n  onprocessinginstruction(name, data) {\n    const node = new ProcessingInstruction(name, data);\n    this.addNode(node);\n  }\n\n  handleCallback(error) {\n    if (typeof this.callback === \"function\") {\n      this.callback(error, this.dom);\n    } else if (error) {\n      throw error;\n    }\n  }\n\n  addNode(node) {\n    const parent = this.tagStack[this.tagStack.length - 1];\n    const previousSibling = parent.children[parent.children.length - 1];\n\n    if (this.options.withStartIndices) {\n      node.startIndex = this.parser.startIndex;\n    }\n\n    if (this.options.withEndIndices) {\n      node.endIndex = this.parser.endIndex;\n    }\n\n    parent.children.push(node);\n\n    if (previousSibling) {\n      node.prev = previousSibling;\n      previousSibling.next = node;\n    }\n\n    node.parent = parent;\n    this.lastNode = null;\n  }\n\n}\nexport default DomHandler;","map":{"version":3,"names":["ElementType","Element","Text","Comment","CDATA","Document","ProcessingInstruction","defaultOpts","withStartIndices","withEndIndices","xmlMode","DomHandler","constructor","callback","options","elementCB","dom","root","done","tagStack","lastNode","parser","undefined","onparserinit","onreset","onend","handleCallback","onerror","error","onclosetag","elem","pop","endIndex","onopentag","name","attribs","type","Tag","element","addNode","push","ontext","data","node","oncomment","oncommentend","oncdatastart","text","parent","oncdataend","onprocessinginstruction","length","previousSibling","children","startIndex","prev","next"],"sources":["/Users/soheilvafaei/Documents/project/web/resume/ex7/node_modules/cheerio/node_modules/domhandler/lib/esm/index.js"],"sourcesContent":["import { ElementType } from \"domelementtype\";\nimport { Element, Text, Comment, CDATA, Document, ProcessingInstruction, } from \"./node.js\";\nexport * from \"./node.js\";\n// Default options\nconst defaultOpts = {\n    withStartIndices: false,\n    withEndIndices: false,\n    xmlMode: false,\n};\nexport class DomHandler {\n    /**\n     * @param callback Called once parsing has completed.\n     * @param options Settings for the handler.\n     * @param elementCB Callback whenever a tag is closed.\n     */\n    constructor(callback, options, elementCB) {\n        /** The elements of the DOM */\n        this.dom = [];\n        /** The root element for the DOM */\n        this.root = new Document(this.dom);\n        /** Indicated whether parsing has been completed. */\n        this.done = false;\n        /** Stack of open tags. */\n        this.tagStack = [this.root];\n        /** A data node that is still being written to. */\n        this.lastNode = null;\n        /** Reference to the parser instance. Used for location information. */\n        this.parser = null;\n        // Make it possible to skip arguments, for backwards-compatibility\n        if (typeof options === \"function\") {\n            elementCB = options;\n            options = defaultOpts;\n        }\n        if (typeof callback === \"object\") {\n            options = callback;\n            callback = undefined;\n        }\n        this.callback = callback !== null && callback !== void 0 ? callback : null;\n        this.options = options !== null && options !== void 0 ? options : defaultOpts;\n        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n    }\n    onparserinit(parser) {\n        this.parser = parser;\n    }\n    // Resets the handler back to starting state\n    onreset() {\n        this.dom = [];\n        this.root = new Document(this.dom);\n        this.done = false;\n        this.tagStack = [this.root];\n        this.lastNode = null;\n        this.parser = null;\n    }\n    // Signals the handler that parsing is done\n    onend() {\n        if (this.done)\n            return;\n        this.done = true;\n        this.parser = null;\n        this.handleCallback(null);\n    }\n    onerror(error) {\n        this.handleCallback(error);\n    }\n    onclosetag() {\n        this.lastNode = null;\n        const elem = this.tagStack.pop();\n        if (this.options.withEndIndices) {\n            elem.endIndex = this.parser.endIndex;\n        }\n        if (this.elementCB)\n            this.elementCB(elem);\n    }\n    onopentag(name, attribs) {\n        const type = this.options.xmlMode ? ElementType.Tag : undefined;\n        const element = new Element(name, attribs, undefined, type);\n        this.addNode(element);\n        this.tagStack.push(element);\n    }\n    ontext(data) {\n        const { lastNode } = this;\n        if (lastNode && lastNode.type === ElementType.Text) {\n            lastNode.data += data;\n            if (this.options.withEndIndices) {\n                lastNode.endIndex = this.parser.endIndex;\n            }\n        }\n        else {\n            const node = new Text(data);\n            this.addNode(node);\n            this.lastNode = node;\n        }\n    }\n    oncomment(data) {\n        if (this.lastNode && this.lastNode.type === ElementType.Comment) {\n            this.lastNode.data += data;\n            return;\n        }\n        const node = new Comment(data);\n        this.addNode(node);\n        this.lastNode = node;\n    }\n    oncommentend() {\n        this.lastNode = null;\n    }\n    oncdatastart() {\n        const text = new Text(\"\");\n        const node = new CDATA([text]);\n        this.addNode(node);\n        text.parent = node;\n        this.lastNode = text;\n    }\n    oncdataend() {\n        this.lastNode = null;\n    }\n    onprocessinginstruction(name, data) {\n        const node = new ProcessingInstruction(name, data);\n        this.addNode(node);\n    }\n    handleCallback(error) {\n        if (typeof this.callback === \"function\") {\n            this.callback(error, this.dom);\n        }\n        else if (error) {\n            throw error;\n        }\n    }\n    addNode(node) {\n        const parent = this.tagStack[this.tagStack.length - 1];\n        const previousSibling = parent.children[parent.children.length - 1];\n        if (this.options.withStartIndices) {\n            node.startIndex = this.parser.startIndex;\n        }\n        if (this.options.withEndIndices) {\n            node.endIndex = this.parser.endIndex;\n        }\n        parent.children.push(node);\n        if (previousSibling) {\n            node.prev = previousSibling;\n            previousSibling.next = node;\n        }\n        node.parent = parent;\n        this.lastNode = null;\n    }\n}\nexport default DomHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}