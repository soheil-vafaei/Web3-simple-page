{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tie = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:format:utils:circularity\");\n\nfunction tie(untied) {\n  return tieWithTable(untied, []);\n}\n\nexports.tie = tie;\n\nfunction tieWithTable(untied, seenSoFar) {\n  if (untied.kind === \"error\") {\n    return untied;\n  }\n\n  let reference;\n\n  switch (untied.type.typeClass) {\n    case \"array\":\n      const untiedAsArray = untied; //dammit TS\n\n      reference = untiedAsArray.reference;\n\n      if (reference === undefined) {\n        //we need to do some pointer stuff here, so let's first create our new\n        //object we'll be pointing to\n        //[we don't want to alter the original accidentally so let's clone a bit]\n        let tied = Object.assign(Object.assign({}, untiedAsArray), {\n          value: [...untiedAsArray.value]\n        }); //now, we can't use a map here, or we'll screw things up!\n        //we want to *mutate* value, not replace it with a new object\n        //note: this used to be a for-in loop, changed to avoid problems with VSCode\n\n        for (let index = 0; index < tied.value.length; index++) {\n          tied.value[index] = tieWithTable(tied.value[index], [tied, ...seenSoFar]);\n        }\n\n        return tied;\n      } else {\n        return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {\n          reference\n        });\n      }\n\n    case \"struct\":\n      const untiedAsStruct = untied; //dammit TS\n\n      reference = untiedAsStruct.reference;\n\n      if (reference === undefined) {\n        //we need to do some pointer stuff here, so let's first create our new\n        //object we'll be pointing to\n        //[we don't want to alter the original accidentally so let's clone a bit]\n        let tied = Object.assign(Object.assign({}, untiedAsStruct), {\n          value: untiedAsStruct.value.map(component => Object.assign({}, component))\n        }); //now, we can't use a map here, or we'll screw things up!\n        //we want to *mutate* value, not replace it with a new object\n        //note: this used to be a for-in loop, changed to avoid problems with VSCode\n\n        for (let index = 0; index < tied.value.length; index++) {\n          tied.value[index] = Object.assign(Object.assign({}, tied.value[index]), {\n            value: tieWithTable(tied.value[index].value, [tied, ...seenSoFar])\n          });\n        }\n\n        return tied;\n      } else {\n        return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {\n          reference\n        });\n      }\n\n    case \"tuple\":\n      //currently there are no memory tuples, but may as well\n      //can't be circular, just recurse\n      //note we can just recurse with a straight tie here; don't need tieWithTable\n      const untiedAsTuple = untied; //dammit TS\n      //we need to do some pointer stuff here, so let's first create our new\n      //object we'll be pointing to\n\n      let tied = Object.assign({}, untiedAsTuple);\n      tied.value = tied.value.map(component => Object.assign(Object.assign({}, component), {\n        value: tie(component.value)\n      }));\n      return tied;\n\n    default:\n      //other types either:\n      //1. aren't containers and so need no recursion\n      //2. are containers but can't go in or contain memory things\n      //and so still need no recursion\n      //(or, in the case of mappings, can't contain *nontrivial* memory\n      //things)\n      return untied;\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA,MAAMA,KAAK,GAAG,qBAAY,gCAAZ,CAAd;;AAIA,SAAgBC,GAAhB,CAAoBC,MAApB,EAAgD;EAC9C,OAAOC,YAAY,CAACD,MAAD,EAAS,EAAT,CAAnB;AACD;;AAFDE;;AAIA,SAASD,YAAT,CACED,MADF,EAEEG,SAFF,EAEqE;EAEnE,IAAIH,MAAM,CAACI,IAAP,KAAgB,OAApB,EAA6B;IAC3B,OAAOJ,MAAP;EACD;;EACD,IAAIK,SAAJ;;EACA,QAAQL,MAAM,CAACM,IAAP,CAAYC,SAApB;IACE,KAAK,OAAL;MACE,MAAMC,aAAa,GAA6BR,MAAhD,CADF,CAC0D;;MACxDK,SAAS,GAAGG,aAAa,CAACH,SAA1B;;MACA,IAAIA,SAAS,KAAKI,SAAlB,EAA6B;QAC3B;QACA;QACA;QACA,IAAIC,IAAI,mCAAQF,aAAR,GAAqB;UAAEG,KAAK,EAAE,CAAC,GAAGH,aAAa,CAACG,KAAlB;QAAT,CAArB,CAAR,CAJ2B,CAK3B;QACA;QACA;;QACA,KAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,IAAI,CAACC,KAAL,CAAWE,MAAvC,EAA+CD,KAAK,EAApD,EAAwD;UACtDF,IAAI,CAACC,KAAL,CAAWC,KAAX,IAAoBX,YAAY,CAACS,IAAI,CAACC,KAAL,CAAWC,KAAX,CAAD,EAAoB,CAClDF,IADkD,EAElD,GAAGP,SAF+C,CAApB,CAAhC;QAID;;QACD,OAAOO,IAAP;MACD,CAfD,MAeO;QACL,uCAAYP,SAAS,CAACE,SAAS,GAAG,CAAb,CAArB,GAAoC;UAAEA;QAAF,CAApC;MACD;;IACH,KAAK,QAAL;MACE,MAAMS,cAAc,GAA8Bd,MAAlD,CADF,CAC4D;;MAC1DK,SAAS,GAAGS,cAAc,CAACT,SAA3B;;MACA,IAAIA,SAAS,KAAKI,SAAlB,EAA6B;QAC3B;QACA;QACA;QACA,IAAIC,IAAI,mCACHI,cADG,GACW;UACjBH,KAAK,EAAEG,cAAc,CAACH,KAAf,CAAqBI,GAArB,CAAyBC,SAAS,IAAIC,kBAAMD,SAAN,CAAtC;QADU,CADX,CAAR,CAJ2B,CAQ3B;QACA;QACA;;QACA,KAAK,IAAIJ,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,IAAI,CAACC,KAAL,CAAWE,MAAvC,EAA+CD,KAAK,EAApD,EAAwD;UACtDF,IAAI,CAACC,KAAL,CAAWC,KAAX,IAAiBK,gCACZP,IAAI,CAACC,KAAL,CAAWC,KAAX,CADY,GACK;YACpBD,KAAK,EAAEV,YAAY,CAACS,IAAI,CAACC,KAAL,CAAWC,KAAX,EAAkBD,KAAnB,EAA0B,CAACD,IAAD,EAAO,GAAGP,SAAV,CAA1B;UADC,CADL,CAAjB;QAID;;QACD,OAAOO,IAAP;MACD,CAlBD,MAkBO;QACL,uCAAYP,SAAS,CAACE,SAAS,GAAG,CAAb,CAArB,GAAoC;UAAEA;QAAF,CAApC;MACD;;IACH,KAAK,OAAL;MAAc;MACZ;MACA;MACA,MAAMa,aAAa,GAA6BlB,MAAhD,CAHF,CAG0D;MACxD;MACA;;MACA,IAAIU,IAAI,qBAAQQ,aAAR,CAAR;MACAR,IAAI,CAACC,KAAL,GAAaD,IAAI,CAACC,KAAL,CAAWI,GAAX,CAAeC,SAAS,IAAIC,gCACpCD,SADoC,GAC3B;QACZL,KAAK,EAAEZ,GAAG,CAACiB,SAAS,CAACL,KAAX;MADE,CAD2B,CAA5B,CAAb;MAIA,OAAOD,IAAP;;IACF;MACE;MACA;MACA;MACA;MACA;MACA;MACA,OAAOV,MAAP;EAjEJ;AAmED","names":["debug","tie","untied","tieWithTable","exports","seenSoFar","kind","reference","type","typeClass","untiedAsArray","undefined","tied","value","index","length","untiedAsStruct","map","component","Object","untiedAsTuple"],"sourceRoot":"","sources":["../../../../lib/format/utils/circularity.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}