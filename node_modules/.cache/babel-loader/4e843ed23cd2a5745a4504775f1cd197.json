{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:abi-data:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeAbi(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\") {\n    //I don't want tuples to be considered a reference type, but it makes sense\n    //to group them for this purpose\n    let dynamic;\n\n    try {\n      dynamic = (0, allocate_1.abiSizeInfo)(dataType, info.allocations.abi).dynamic;\n    } catch (error) {\n      return (0, errors_1.handleDecodingError)(dataType, error, options.strictAbiMode);\n    }\n\n    if (dynamic) {\n      return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n    } else {\n      return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n    }\n  } else {\n    debug(\"pointer %o\", pointer);\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n  }\n}\n\nexports.decodeAbi = decodeAbi;\n\nfunction* decodeAbiReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let {\n    strictAbiMode: strict,\n    abiPointerBase: base,\n    lengthOverride\n  } = options;\n  base = base || 0; //in case base was undefined\n\n  const {\n    allocations: {\n      abi: allocations\n    },\n    state\n  } = info;\n  debug(\"pointer %o\", pointer); //this variable holds the location we should look to *next*\n  //stack pointers point to calldata; other pointers point to same location\n\n  const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n\n  if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n    //length overrides are only applicable when you're decoding a pointer\n    //from the stack!  otherwise they must be ignored!\n    lengthOverride = undefined;\n  }\n\n  let rawValue;\n\n  try {\n    rawValue = yield* (0, read_1.default)(pointer, state);\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error, strict);\n  }\n\n  let rawValueAsBN = Conversion.toBN(rawValue);\n  debug(\"rawValue: %O\", rawValue);\n  debug(\"rawValueAsBN: %O\", rawValueAsBN);\n  let rawValueAsNumber;\n\n  try {\n    rawValueAsNumber = rawValueAsBN.toNumber();\n  } catch (_a) {\n    let error = {\n      kind: \"OverlargePointersNotImplementedError\",\n      pointerAsBN: rawValueAsBN\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      //again with the TS failures...\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  let startPosition = rawValueAsNumber + base;\n  debug(\"startPosition %d\", startPosition);\n  let dynamic;\n  let size;\n\n  try {\n    ({\n      dynamic,\n      size\n    } = (0, allocate_1.abiSizeInfo)(dataType, allocations));\n  } catch (error) {\n    return (0, errors_1.handleDecodingError)(dataType, error, strict);\n  }\n\n  if (!dynamic) {\n    //this will only come up when called from stack.ts\n    let staticPointer = {\n      location,\n      start: startPosition,\n      length: size\n    };\n    return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n  }\n\n  let length;\n  let lengthAsBN;\n  let rawLength;\n\n  switch (dataType.typeClass) {\n    case \"bytes\":\n    case \"string\":\n      //initial word contains length (unless an override was given)\n      if (lengthOverride !== undefined) {\n        lengthAsBN = lengthOverride; //note in this case we do *not* increment start position;\n        //if a length override is given, that means the given start\n        //position skips over the length word!\n      } else {\n        try {\n          rawLength = yield* (0, read_1.default)({\n            location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error, strict);\n        }\n\n        lengthAsBN = Conversion.toBN(rawLength);\n        startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n        //so it'll be set up to read the data\n      }\n\n      if (strict && lengthAsBN.gtn(state[location].length)) {\n        //you may notice that the comparison is a bit crude; that's OK, this is\n        //just to prevent huge numbers from DOSing us, other errors will still\n        //be caught regardless\n        throw new errors_1.StopDecodingError({\n          kind: \"OverlongArrayOrStringStrictModeError\",\n          lengthAsBN,\n          dataLength: state[location].length\n        });\n      }\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_b) {\n        //note: if we're in this situation, we can assume we're not in strict mode,\n        //as the strict case was handled above\n        return {\n          //again with the TS failures...\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      }\n\n      let childPointer = {\n        location,\n        start: startPosition,\n        length\n      };\n      return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n\n    case \"array\":\n      if (dataType.kind === \"static\") {\n        //static-length array\n        lengthAsBN = dataType.length; //note we don't increment start position; static arrays don't\n        //include a length word!\n      } else if (lengthOverride !== undefined) {\n        debug(\"override: %o\", lengthOverride); //dynamic-length array, but with length override\n\n        lengthAsBN = lengthOverride; //we don't increment start position; if a length override was\n        //given, that means the pointer skipped the length word!\n      } else {\n        //dynamic-length array, read length from data\n        //initial word contains array length\n        try {\n          rawLength = yield* (0, read_1.default)({\n            location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return (0, errors_1.handleDecodingError)(dataType, error, strict);\n        }\n\n        lengthAsBN = Conversion.toBN(rawLength);\n        startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n        //to next word, as first word was used for length\n      }\n\n      if (strict && lengthAsBN.gtn(state[location].length)) {\n        //you may notice that the comparison is a bit crude; that's OK, this is\n        //just to prevent huge numbers from DOSing us, other errors will still\n        //be caught regardless\n        throw new errors_1.StopDecodingError({\n          kind: \"OverlongArraysAndStringsNotImplementedError\",\n          lengthAsBN,\n          dataLength: state[location].length\n        });\n      }\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_c) {\n        //again, if we get here, we can assume we're not in strict mode\n        return {\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      } //note: I've written this fairly generically, but it is worth noting that\n      //since this array is of dynamic type, we know that if it's static length\n      //then size must be EVM.WORD_SIZE\n\n\n      let baseSize;\n\n      try {\n        baseSize = (0, allocate_1.abiSizeInfo)(dataType.baseType, allocations).size;\n      } catch (error) {\n        return (0, errors_1.handleDecodingError)(dataType, error, strict);\n      }\n\n      let decodedChildren = [];\n\n      for (let index = 0; index < length; index++) {\n        decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n          location,\n          start: startPosition + index * baseSize,\n          length: baseSize\n        }, info, Object.assign(Object.assign({}, options), {\n          abiPointerBase: startPosition\n        }))); //pointer base is always start of list, never the length\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedChildren\n      };\n\n    case \"struct\":\n      return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n\n    case \"tuple\":\n      return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n  }\n}\n\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\n\nfunction* decodeAbiReferenceStatic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  debug(\"static\");\n  debug(\"pointer %o\", pointer);\n  const location = pointer.location;\n\n  switch (dataType.typeClass) {\n    case \"array\":\n      //we're in the static case, so we know the array must be statically sized\n      const lengthAsBN = dataType.length;\n      let length;\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_a) {\n        //note: since this is the static case, we don't bother including the stronger\n        //strict-mode guard against getting DOSed by large array sizes, since in this\n        //case we're not reading the size from the input; if there's a huge static size\n        //array, well, we'll just have to deal with it\n        let error = {\n          kind: \"OverlongArraysAndStringsNotImplementedError\",\n          lengthAsBN\n        };\n\n        if (options.strictAbiMode) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      let baseSize;\n\n      try {\n        baseSize = (0, allocate_1.abiSizeInfo)(dataType.baseType, info.allocations.abi).size;\n      } catch (error) {\n        return (0, errors_1.handleDecodingError)(dataType, error, options.strictAbiMode);\n      }\n\n      let decodedChildren = [];\n\n      for (let index = 0; index < length; index++) {\n        decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n          location,\n          start: pointer.start + index * baseSize,\n          length: baseSize\n        }, info, options));\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedChildren\n      };\n\n    case \"struct\":\n      return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n\n    case \"tuple\":\n      return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n  }\n}\n\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic; //note that this function takes the start position as a *number*; it does not take a pointer\n\nfunction* decodeAbiStructByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const {\n    allocations: {\n      abi: allocations\n    }\n  } = info;\n  const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n\n  const typeId = dataType.id;\n  const structAllocation = allocations[typeId];\n\n  if (!structAllocation) {\n    let error = {\n      kind: \"UserDefinedTypeNotFoundError\",\n      type: dataType\n    };\n\n    if (options.strictAbiMode || options.allowRetry) {\n      throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the allocation!\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  let decodedMembers = [];\n\n  for (let index = 0; index < structAllocation.members.length; index++) {\n    const memberAllocation = structAllocation.members[index];\n    const memberPointer = memberAllocation.pointer;\n    const childPointer = {\n      location,\n      start: startPosition + memberPointer.start,\n      length: memberPointer.length\n    };\n    let memberName = memberAllocation.name;\n    let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n    decodedMembers.push({\n      name: memberName,\n      value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n        abiPointerBase: startPosition\n      })) //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n\n    });\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: decodedMembers\n  };\n} //note that this function takes the start position as a *number*; it does not take a pointer\n\n\nfunction* decodeAbiTupleByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n  //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n  //However it may be worth revisiting this in the future if performance turns out to be a problem\n  //(changing this may be pretty hard though)\n  let decodedMembers = [];\n  let position = startPosition;\n\n  for (const {\n    name,\n    type: memberType\n  } of dataType.memberTypes) {\n    const memberSize = (0, allocate_1.abiSizeInfo)(memberType, info.allocations.abi).size;\n    const childPointer = {\n      location,\n      start: position,\n      length: memberSize\n    };\n    decodedMembers.push({\n      name,\n      value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n        abiPointerBase: startPosition\n      })) //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n\n    });\n    position += memberSize;\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: decodedMembers\n  };\n}","map":{"version":3,"mappings":"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","names":["debug","decodeAbi","dataType","pointer","info","options","Format","Types","isReferenceType","typeClass","dynamic","allocations","abi","error","strictAbiMode","decodeAbiReferenceByAddress","decodeAbiReferenceStatic","Basic","Decode","decodeBasic","exports","strict","abiPointerBase","base","lengthOverride","state","location","undefined","rawValue","rawValueAsBN","Conversion","toBN","rawValueAsNumber","toNumber","kind","pointerAsBN","errors_1","type","startPosition","size","staticPointer","start","length","lengthAsBN","rawLength","Evm","Utils","WORD_SIZE","gtn","dataLength","childPointer","Bytes","decodeBytes","baseSize","baseType","decodedChildren","index","push","Object","value","decodeAbiStructByPosition","decodeAbiTupleByPosition","typeLocation","typeId","id","structAllocation","allowRetry","decodedMembers","members","memberAllocation","memberPointer","memberName","name","memberType","specifyLocation","position","memberTypes","memberSize"],"sourceRoot":"","sources":["../../../../lib/abi-data/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}