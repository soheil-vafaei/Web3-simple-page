{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeString = exports.decodeBytes = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"codec:bytes:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst errors_1 = require(\"../../errors\");\n\nconst utf8_1 = __importDefault(require(\"utf8\"));\n\nfunction* decodeBytes(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    state\n  } = info;\n  const {\n    strictAbiMode: strict\n  } = options; //if this is undefined it'll still be falsy so OK\n\n  let bytes;\n\n  try {\n    bytes = yield* (0, read_1.default)(pointer, state);\n  } catch (error) {\n    debug(\"segfault, pointer %o, state: %O\", pointer, state);\n    return (0, errors_1.handleDecodingError)(dataType, error, strict);\n  }\n\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer); //note: this function does not check padding\n\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      //we assume this is a dynamic bytestring!\n      //static ones should go to decodeBasic!\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asHex: Conversion.toHexString(bytes)\n        }\n      };\n\n    case \"string\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodeString(bytes)\n      };\n  }\n}\n\nexports.decodeBytes = decodeBytes;\n\nfunction decodeString(bytes) {\n  //the following line takes our UTF-8 string... and interprets each byte\n  //as a UTF-16 bytepair.  Yikes!  Fortunately, we have a library to repair that.\n  let badlyEncodedString = String.fromCharCode.apply(undefined, bytes);\n\n  try {\n    //this will throw an error if we have malformed UTF-8\n    let correctlyEncodedString = utf8_1.default.decode(badlyEncodedString); //NOTE: we don't use node's builtin Buffer class to do the UTF-8 decoding\n    //here, because that handles malformed UTF-8 by means of replacement characters\n    //(U+FFFD).  That loses information.  So we use the utf8 package instead,\n    //and... well, see the catch block below.\n\n    return {\n      kind: \"valid\",\n      asString: correctlyEncodedString\n    };\n  } catch (_a) {\n    //we're going to ignore the precise error and just assume it's because\n    //the string was malformed (what else could it be?)\n    let hexString = Conversion.toHexString(bytes);\n    return {\n      kind: \"malformed\",\n      asHex: hexString\n    };\n  }\n}\n\nexports.decodeString = decodeString;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA,MAAMA,KAAK,GAAG,qBAAY,oBAAZ,CAAd;;AAEA;;AACA;;AAKA;;AACA;;AAEA,UAAiBC,WAAjB,CACEC,QADF,EAEEC,OAFF,EAGEC,IAHF,EAI8B;EAAA,IAA5BC,OAA4B,uEAAF,EAAE;EAE5B,MAAM;IAAEC;EAAF,IAAYF,IAAlB;EACA,MAAM;IAAEG,aAAa,EAAEC;EAAjB,IAA4BH,OAAlC,CAH4B,CAGe;;EAE3C,IAAII,KAAJ;;EACA,IAAI;IACFA,KAAK,GAAG,OAAO,oBAAKN,OAAL,EAAcG,KAAd,CAAf;EACD,CAFD,CAEE,OAAOI,KAAP,EAAc;IACdV,KAAK,CAAC,iCAAD,EAAoCG,OAApC,EAA6CG,KAA7C,CAAL;IACA,OAAO,kCAAoBJ,QAApB,EAA8BQ,KAA9B,EAAqCF,MAArC,CAAP;EACD;;EAEDR,KAAK,CAAC,SAAD,EAAYE,QAAZ,CAAL;EACAF,KAAK,CAAC,YAAD,EAAeG,OAAf,CAAL,CAd4B,CAgB5B;;EAEA,QAAQD,QAAQ,CAACS,SAAjB;IACE,KAAK,OAAL;MACE;MACA;MACA,OAAO;QACLC,IAAI,EAAEV,QADD;QAELW,IAAI,EAAE,OAFD;QAGLC,KAAK,EAAE;UACLC,KAAK,EAAEC,UAAU,CAACC,WAAX,CAAuBR,KAAvB;QADF;MAHF,CAAP;;IAQF,KAAK,QAAL;MACE,OAAO;QACLG,IAAI,EAAEV,QADD;QAELW,IAAI,EAAE,OAFD;QAGLC,KAAK,EAAEI,YAAY,CAACT,KAAD;MAHd,CAAP;EAbJ;AAmBD;;AAzCDU;;AA2CA,SAAgBD,YAAhB,CAA6BT,KAA7B,EAA8C;EAC5C;EACA;EACA,IAAIW,kBAAkB,GAAGC,MAAM,CAACC,YAAP,CAAoBC,KAApB,CAA0BC,SAA1B,EAAqCf,KAArC,CAAzB;;EACA,IAAI;IACF;IACA,IAAIgB,sBAAsB,GAAGC,eAAKC,MAAL,CAAYP,kBAAZ,CAA7B,CAFE,CAGF;IACA;IACA;IACA;;IACA,OAAO;MACLP,IAAI,EAAE,OADD;MAELe,QAAQ,EAAEH;IAFL,CAAP;EAID,CAXD,CAWE,WAAM;IACN;IACA;IACA,IAAII,SAAS,GAAGb,UAAU,CAACC,WAAX,CAAuBR,KAAvB,CAAhB;IACA,OAAO;MACLI,IAAI,EAAE,WADD;MAELE,KAAK,EAAEc;IAFF,CAAP;EAID;AACF;;AAxBDV","names":["debug","decodeBytes","dataType","pointer","info","options","state","strictAbiMode","strict","bytes","error","typeClass","type","kind","value","asHex","Conversion","toHexString","decodeString","exports","badlyEncodedString","String","fromCharCode","apply","undefined","correctlyEncodedString","utf8_1","decode","asString","hexString"],"sourceRoot":"","sources":["../../../../lib/bytes/decode/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}